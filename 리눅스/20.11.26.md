- **배운 내용**

과정 진행을 위한 가상머신 작업

디렉토리 이동 관련 명령어

PWD 명령어

CD 명령어

절대 경로

상대 경로

쉘 내/외장 명령어

로그인 된 사용자의 홈 디렉토리로 이동

디렉토리 관리 명령어

ls 명령어

mkdir 명령어

정리
---

# 내용 정리

💡 **팁**

디렉토리 경로 입력하다가 Tab키 누를 시 자동완성됨

외워야 할 ls 명령어 팁

## 과정 진행을 위한 가상머신 작업

---

```bash
VM1 ——>       COPY          ——> VM2
VM2 ——>  네트워크 설정 작업
```

```
link clone : 원본을 참조하여 생성되는 클론
      장점 : 용량이 작다.
	    단점 : 원본에 문제가 생기는 경우에 사용이 불가능
full clone : 원본과 별도의 파일로 생성되는 클론
		  장점 : 원본과 별개이기 때문에 원본에 문제가 생겨도 가상머신 사용에 문제가 없다.
      단점 : 원본과 별도의 파일이기 때문에 용량측면에서는 좋지 않다.
```

가상머신 내부에서 설정

**[root@server1 ~]# hostnamectl set-hostname server2.example.com**

네트워크 설정

유선의 설정 아이콘 클릭

설정 창에서 네트워크를 끈 이후에 다시 켜고 확인한다.

```bash
# ifconfig
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.10.252  netmask 255.255.255.0  broadcast 192.168.10.255
        inet6 fe80::cad1:b013:a595:bcd6  prefixlen 64  scopeid 0x20<link>
        inet6 fe80::4ddd:a89c:3593:4a4b  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:5c:83:f4  txqueuelen 1000  (Ethernet)
        RX packets 162648  bytes 243584170 (232.2 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 72239  bytes 4365695 (4.1 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 72  bytes 6120 (5.9 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 72  bytes 6120 (5.9 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

virbr0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 192.168.122.1  netmask 255.255.255.0  broadcast 192.168.122.255
        ether 52:54:00:da:17:0b  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

SERVER2 네트워크 설정이 완료된 이후 가상머신 설정

```bash
SERVER 2 의 하드웨어 세팅 CPU 1, Memory 1gb
SERVER 2 부팅
SERVER 1 부팅
SERVER 1에서 ssh를 이용하여 SERVER 2 접근 테스트
ssh root@192.168.10.252
[server2] # init 3
[server2] # systemctl set-default multi-user.target
[server2] # init 0
SERVER2의 메모리를 512MB로 변경
SERVER2의 스냅샷 저장
```

## 디렉토리 이동 관련 명령어

---

```bash
- pwd 명령어
     # pwd

- cd 명령어
    경로(PATH)
     - 상대경로
     - 절대경로

     홈디렉토리로 이동
     # cd   
	   # cd ~
     # cd $HOME

     # cd ~fedora   /* fedora의 홈 디렉토리로 이동 */
     # cd ~/fedora  /* root밑의 fedora 디렉토리로 이동 */
     # cd -         /* 바로 이전 디렉토리로 이동 */
     # cd ../dir1
```

### PWD 명령어

---

현재 사용자가 위치하고 있는 디렉토리를 출력해주는 명령어.

작업간의 에러를 최소화 하기 위하여 이동 후, 작업 전 필수적으로 확인 해 주는 것이 좋다.

Print Work Directory

### CD 명령어

---

Change Directory

```bash
# whatis cd
cd (1)               - bash built-in commands, see bash(1)
cd (1p)              - change the working directory

bash built-in commands : 이 내용이 나온다면 이 명령어는 내장 명령어이다.

# cd        # 작업 디렉토리를 이동하기 위하여 명령어를 작성
# cd [PATH] # cd 명령어를 이용하여 [PATH]로 작업 디렉토리 변경

```

### **절대경로**

---

이동하는 기준이 최상위 디렉토리(/)이며, root(/) 디렉토리를 기준으로 이동할 때 사용한다.


```bash
A   : 최상위 디렉토리인 /디렉토리를 뜻 한다.
B,c : 처음 위치한 /는 최상위 디렉토리를 나타내지만 뒤에 나와 있는 /는 구분자의 역할이다.
      따라서 /etc/sysconfig/network-scripts/ 와 /etc/sysconfig/network-scripts 는 같은 뜻을 가지게 된다
```

### 상대경로

---

이동하는 기준이 현재 디렉토리이며, 현재 디렉토리를 기준으로 위, 아래로 이동하는 할 때 사용한다. 

```bash
**# cd /etc**
**# pwd**
/etc
**# cd sysconfig 
# cd network-scripts** 
**# ls -a** /* .디렉토리 , ..디렉토리 */
.  ..  ifcfg-ens33

**# cd .**     /* 현재 디렉토리 (cd /etc/sysconfig/network-scripts/와 같은 뜻) */
**# pwd**
/etc/sysconfig/network-scripts/
**# cd ..** /* 상위 디렉토리 (내 기준에서 상위 디렉토리로 이동) */
**# pwd**
/etc/sysconfig/

# cd ../.. /*상위 디렉토리의 상위 디렉토리로 이동 */
```

```bash
.  디렉토리는 현재 디렉토리
.. 디렉토리는 상위 디렉토리
```

```bash
./man-db.crone 
↓
현재 디렉토리 아래 man-db.crone
```

```bash
**# cd /test/dir1
# tree /test**
/test
├── dir1
│   └── file1
└── dir2
    ├── dir2-1
    └── file2
```

### 쉘 내/외장 명령어

---

- **쉘 내장 명령어**

    bash shell에 같이 존재하는 명령어

- **쉘 외장 명령어**

    /usr/bin /usr/sbin.. 특정 디렉토리에 설치 되어 있는 명령어

```bash
# type 명령어
명령어 타입 확인

**쉘 내장 명령어**
[root@server1 ~]# type cd
cd is a shell builtin

**쉘 외장 명령어**
[root@server1 ~]# type init
init is /usr/sbin/init
```

### 로그인 된 사용자의 홈 디렉토리 이동

---

```bash
# ssh fedora@localhost 
```

```bash
# cd /test
# pwd
/test
# cd ~fedora
# pwd
/home/fedora
# cd /test
# cd ~/fedora
# pwd
/root/fedora
```

## 디렉토리 관리 명령어

---

- ls 명령어

     # ls -l dir1

     # ls -ld dir1

- mkdir 명령어
- rmdir 명령어

### ls 명령어

---

디렉토리에 있는 내용을 확인하고자 할 때 (ls 명령에 대해서 확인 : # man ls)

[명령어 형식]

```bash
# ls -l 
# ls –l dir1 

# ls -ld 
# ls –ld dir1 

# ls -altr
```

**옵션**

**-a (all): 모든 파일 표시, 여기에는 숨김 파일(점(.)으로 시작하는 파일)도 표시한다.**

**-l (long):** 디렉토리가 지정되는 경우 디렉토리의 내용을 자세히 보여준다. 또한 파일의 내용 이 지정되는 경우 파일의 속성 정보를 자세히 보여준다. 파일 종류, 링크 수, 소유자명, 그룹명, 파일 크기, 최종 수정일 및 용량, 파일명 표시한다.

-lR : 해당하는 디렉토리명을 출력한뒤 디렉토리 내부의 파일과 디렉토리를 출력한다.

-ld : 현 디렉토리 정보를 자세히 출력

**-R :** 해당 디렉토리와 서브디렉토리의 모든 내용을 표시

-F (file): 디렉토리인 경우에는 디렉토리 "/"표시를 하고 실행 파일인 경우는 뒤에 "*"표시를 한다.

**-i :** Index NODE인 inode를 표시해주기 위한 옵션이다. 파일의 속성정보를 담고있는 inode의 구분번호를 표시해 주고 있다. 

      ls –l로 명령어를 입력한 경우의 출력되는 결과들이 저장되어 있다. 

-n : 파일의 소유자와 그룹을 숫자로( UID : GID )표시한다.

**-d :** 찾고자 하는 디렉토리에 관한 정보만을 표시한다.

```bash
# ls -l
합계 0
drwxr-xr-x. 2 root root 19 11월 26 16:05 dir1
-rw-r--r--. 1 root root  0 11월 26 16:05 file1

ls -l 출력 결과 해석
------------------------------------------------------------------------------------
d|rwxr-xr-x|.|2|root|root|19|11월 26 16:05|dir1

d             : 파일의 형식을 보여준다.
		            ls에서 많이 나타나는 파일의 형식
                 - : 일반파일
			               실행파일, 데이터 파일, 로그, 웬만한 것들은 모두 일반 파일로 분류
                 d : 디렉토리
				             디렉토리(폴더)
						    장치파일 : /dev : c 캐릭터 파일 b 블록파일
rwxr-xr-x     : 파일의 권한
.             : 보안적인 요소 (ACL 권한이 포함되어 있는지의 유무)
						    . -> ACL이 설정 되어 있지 않다.
						    + -> ACL이 설정 되어 있다.
2             : 링크
						    디스크에 존재하는 파일에서 몇 개의 접근 지점이 존재하는가?
root          : 개인 소유자 uid
root          : 그룹 소유자 gid
19            : 용량
11월 26 16:05 : 수정 시간
dir1          : 파일 이름, 디렉토리 이름
								접근을 위해서 사용해야 하는 오브젝트
------------------------------------------------------------------------------------
```

```bash
**# ls -ld /* 현 디렉토리 정보를 자세히 출력( .디렉토리 출력) */**
drwxr-xr-x. 3 root root 29 Mar 25 13:23 .
# ls -l dir1 /* dir1디렉토리의 내용을 출력 */
total 0
-rw-r--r--. 1 root root 0 Mar 25 13:23 file2
# ls -ld dir1 /* dir1디렉토리의 정보를 출력 */
drwxr-xr-x. 2 root root 18 Mar 25 13:23 dir1
**# ls -lR /test /* -R: Recursive, 하위 디렉토리까지 */
/test: <해당하는 디렉토리명을 출력한뒤 디렉토리 내부의 파일과 디렉토리를 출력한다.>**
total 0
drwxr-xr-x. 2 root root 18 Mar 25 13:23 dir1
-rw-r--r--. 1 root root  0 Mar 25 13:23 file1

/test/dir1:
total 0
-rw-r--r--. 1 root root 0 Mar 25 13:23 file2
```

**파일을 생성, 확인**

일반 파일의 경우에는 파일의 이름을 지정할 때 문자로 지정, 숫자 지정

숨김 파일 → 파일의 이름을 지정할 때 처음에 .으로 시작

```bash
touch .file1

# ls
# touch .file1
# ls
# ls -a
.  ..  .file1
```

**ls -f 실습**

```bash
# cd /test 
# rm -rf /test/* 

# cp /etc/passwd file1    /* 일반 파일 */
# ln -s file1 file2       /* 링크 파일 */
# cp /bin/ls file3        /* 실행 파일 */
# mkdir dir1              /* 디렉토리 파일 */
# cp /var/log/wtmp file4

# ls -F   (dir1/  file1  file2@  file3*  file4)
# ls (dir1   file1  file2   file3  file4)
```

```bash
# ls
dir1  file1  file2  file3  file4
# ls -F       /* 파일 형식까지 간략히 볼 수 있다 */
dir1/  file1  file2@  file3*  file4
# file *      /* 파일 형식을 자세히 볼 수 있다 */
dir1:  directory
file1: ASCII text
file2: symbolic link to file1
file3: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=bed150f5bac8514e69b3b98eb6fd3e75d6b277c8, stripped, too many notes (256)
file4: dBase III DBT, version number 0, next free block index 8
```

리눅스 설치

디스크 설정(auto)

F/S > table > inode table

inode table?

커널이 디스크에 접근 하여 파일을 액세스 하기 위하여

**파일 또는 디렉토리만 출력**

```bash
# ls -l | grep  ^-  /* -로 시작하는 파일만 출력한다 */
-rw-r--r--. 1 root root   2707 11월 26 16:51 file1
-rwxr-xr-x. 1 root root 267000 11월 26 16:51 file3
-rw-r--r--. 1 root root   4608 11월 26 16:52 file4

# alias lsd='ls -l | grep "^d"'
[root@server1 test]# alias lsf='ls -l | grep "^-"'
[root@server1 test]# alias
alias asf='ls -l | grep  ^-'
alias cp='cp -i'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias grep='grep --color=auto'
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias lsd='ls -l | grep "^d"'
alias lsf='ls -l | grep "^-"'
alias mv='mv -i'
alias rm='rm -i'
alias which='(alias; declare -f) | /usr/bin/which --tty-only --read-alias --read-functions --show-tilde --show-dot'
alias xzegrep='xzegrep --color=auto'
alias xzfgrep='xzfgrep --color=auto'
alias xzgrep='xzgrep --color=auto'
alias zegrep='zegrep --color=auto'
alias zfgrep='zfgrep --color=auto'
alias zgrep='zgrep --color=auto'
# lsf
합계 276
drwxr-xr-x. 2 root root      6 11월 26 16:51 dir1
-rw-r--r--. 1 root root   2707 11월 26 16:51 file1
lrwxrwxrwx. 1 root root      5 11월 26 16:51 file2 -> file1
-rwxr-xr-x. 1 root root 267000 11월 26 16:51 file3
-rw-r--r--. 1 root root   4608 11월 26 16:52 file4
# lsd
drwxr-xr-x. 2 root root      6 11월 26 16:51 dir1
```

**ls -h (human)**

사람이 보기 편하게 출력된다.

```bash
# ls -l file1
-rw-r--r--. 1 root root 4848471 11월 26 17:12 file1
# ls -lh file1
-rw-r--r--. 1 root root 4.7M 11월 26 17:12 file1
```

**ls -altr**

이전파일이 상단에 출력된다.

-t : time sort, -r : reverse sort

```bash
ls -l
합계 8528
drwxr-xr-x. 2 root root       6 11월 26 16:51 dir1
-rw-r--r--. 1 root root 4848471 11월 26 17:12 file1
lrwxrwxrwx. 1 root root       5 11월 26 16:51 file2 -> file1
-rwxr-xr-x. 1 root root  267000 11월 26 16:51 file3
-rw-r--r--. 1 root root    4608 11월 26 16:52 file4
# ls -lt
합계 8528
-rw-r--r--. 1 root root 4848471 11월 26 17:12 file1
-rw-r--r--. 1 root root    4608 11월 26 16:52 file4
drwxr-xr-x. 2 root root       6 11월 26 16:51 dir1
-rwxr-xr-x. 1 root root  267000 11월 26 16:51 file3
lrwxrwxrwx. 1 root root       5 11월 26 16:51 file2 -> file1
# ls -ltr
합계 8528
lrwxrwxrwx. 1 root root       5 11월 26 16:51 file2 -> file1
-rwxr-xr-x. 1 root root  267000 11월 26 16:51 file3
drwxr-xr-x. 2 root root       6 11월 26 16:51 dir1
-rw-r--r--. 1 root root    4608 11월 26 16:52 file4
-rw-r--r--. 1 root root 4848471 11월 26 17:12 file1
```

```bash
**ls 명령어에서 이정도는 알아두자.**
l 자세하게 출력
a 모든파일 출력(숨김파일 포함)
i inode 번호 출력
h 용량을 사람이 보기 편하게 변경하여 출력
t 시간순 정렬
u 접근시간 으로 변경
r 역방향 정렬때 사용(t옵션과 같이 쓴다.)
F 파일형식 확인
```

Access: 파일에 접근한 시간

Modify: 파일이 마지막으로 수정된 시간

Change: 파일의 inode가 변경된 시간

inode는 언제 변경되는가?

```bash
ls -l 정보가 변경될 때
권한, 소유자..
```

### mkdir 명령어

---

디렉토리를 만드는 명령어

```bash
# mkdir -p dir2/dir3/dir4/dir5/dir6
/* 디렉토리 경로로 생성 (디렉토리를 만들 때 상위 디렉토리가 없을 시 상위 디렉토리까지 생성)

```

- **rmdir 명령어**

```bash
# mkdir dir1              /* 현 디렉토리에 dir1 디렉토리 1개 생성 */
# mkdir dir1 dir2         /* 현 디렉토리에 dir1, dir2 디렉토리 2개 생성 */
# mkdir -p dir3/dir2/dir1 /* dir3 디렉토리 안에 dir2를 생성하고 dir2 안에 dir1을 생성 */
```

rmdir의 특징 : 빈 디렉토리만 삭제 가능

삭제 하는 경우에는 rm 명령어를 사용합니다.

디렉토리를 삭제하는 명령어인 rmdir은 디렉토리가 비어있어야 삭제가 되기 때문에 보통 rm -rf 명령을 이용하여 삭제합니다.

## 정리

---

pwd : 현재 작업 디렉토리 확인

cd : 작업 디렉토리 이동

. : 현재 디렉토리

.. : 상위 디렉토리

. .. 동일한 디렉토리: /

절대경로 : 항상 시작점이 /로 시작하여 원하는 경로를 선택

상대경로 : 현재 작업 디렉토리를 시작점으로 하는 경로를 선택

ls → 파일의 정보를 확인 할 때 사용하는 명령어

```bash
ls -l, ls -a, ls -h, ls -i, ls -F
```

mkdir : 디렉토리 만드는 명령어

rmdir : 디렉토리 삭제하는 명령어

stat : 파일의 시간 정보를 확인하기 위한 명령어

atime mtime, ctime
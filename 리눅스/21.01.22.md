# SELinux 모드 변경

문제 해결을 위해 SELinux 모드를 사용하여 SELinux 보호를 일시적으로 비활성화할 수 있습니다. 이 섹 션에서는 강제 모드와 허용 모드 간 SELinux 모드를 일시적으로 변경하는 방법에 대해 알아봅니다. 또한 부팅 시 결정되는 기본 SELinux 모드를 설정하는 방법에 대해서도 알아봅니다.1

## 현재 SELinux 모드 변경

```bash
[SERVER1]# getenforce 
Enforcing
[SERVER1]# setenforce 
usage:  setenforce [ Enforcing | Permissive | 1 | 0 ]
[SERVER1]# setenforce  0
[SERVER1]# getenforce 
Permissive
[SERVER1]# setenforce  1
[SERVER1]# getenforce 
Enforcing
```

SELinux 모드를 일시적으로 설정하는 다른 방법은 부팅 시 커널에 매개 변수를 전달하는 것입니다. enforcing=0의 커널 인수를 전달하면 시스템이 허용 모드로 부팅됩니다. 값 1에서는 강제 모드로 지정됩 니다. selinux=0 인수를 지정하면 SELinux를 비활성화할 수 있습니다. 값 1에서는 SELinux가 활성화됩 니다.

기본 SELinux 모드 설정

부팅 시 SELinux 모드를 결정하는 구성 파일은 /etc/selinux/config입니다. 여기에는 몇 가지 유용한 주석이 포함되어 있습니다.

```bash
[SERVER1]# vi /etc/selinux/config

# This file controls the state of SELinux on the system.
# SELINUX= can take one of these three values:
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
SELINUX=enforcing
# SELINUXTYPE= can take one of three values:
#     targeted - Targeted processes are protected,
#     minimum - Modification of targeted policy. Only selected processes are protected.
#     mls - Multi Level Security protection.
SELINUXTYPE=targeted

[SERVER1]# reboot
# ssh root@192.168.10.210
Password: 
Last login: Fri Apr 17 16:55:33 2020
[SERVER1]# getenforce 
Disabled
```

/etc/selinux/config를 사용하여 부팅 시 기본 SELinux 모드를 변경합니다. 아래 예에서는 강제 모드 로 설정되어 있습니다.

selinux= 및/또는 enforcing= 커널 인수를 전달하면 /etc/selinux/config에 지정된 기본값이 재정의 됩니다.

### 실습:SELinux 모드 변경

server1에서 root로 로그인합니다. 현재 SELinux 모드를 표시합니다.

```bash
[SERVER1]# getenforce 
Enforcing
```

기본 SELinux 모드를 허용으로 변경하고 재부팅합니다.

```bash
[SERVER1]# vi /etc/selinux/config
# This file controls the state of SELinux on the system.
# SELINUX= can take one of these three values:
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
SELINUX=permissive
# SELINUXTYPE= can take one of three values:
#     targeted - Targeted processes are protected,
#     minimum - Modification of targeted policy. Only selected processes are protected.
#     mls - Multi Level Security protection.
SELINUXTYPE=targeted

[SERVER1]# reboot
```

server1가 기동되면 root로 로그인한 다음 현재 SELinux 모드를 표시합니다.

```bash
[SERVER1]# getenforce
Permissive
```

기본 SELinux 모드를 강제로 변경합니다.

```bash
[SERVER1]# vi /etc/selinux/config
# This file controls the state of SELinux on the system.
# SELINUX= can take one of these three values:
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
SELINUX=enforcing
# SELINUXTYPE= can take one of three values:
#     targeted - Targeted processes are protected,
#     minimum - Modification of targeted policy. Only selected processes are protected.
#     mls - Multi Level Security protection.
SELINUXTYPE=targeted
```

현재 SELinux 모드를 강제로 설정합니다.

```bash
[SERVER1]# setenforce 1
[SERVER1]# getenforce
Enforcing
```

# SELINUX 컨텍스트 변경

## 초기 SELinux 컨텍스트

일반적으로 파일의 상위 디렉터리의 SELinux 컨텍스트에 따라 초기 SELinux 컨텍스트가 결정됩니다. 상위 디렉터리의 컨텍스트는 새로 만들어진 파일에 할당됩니다. vim, cp, touch 명령에서 이와 같이 작동합 니다. 하지만, 파일이 다른 위치에서 만들어지고 사용 권한이 유지된 경우(mv 또는 cp -a) 원래 SELinux 컨텍스트는 변경되지 않습니다.

```bash
[SERVER1]# dnf -y install httpd
[SERVER1]# ls -Zd /var/www/html/
drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 /var/www/html/
[SERVER1]# touch /var/www/html/index.html
[SERVER1]# ls -lZ /var/www/html/index.html 
-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 /var/www/html/index.html
```

## 파일의 SELinux 컨텍스트 변경

파일의 SELinux 컨텍스트를 변경하는 데 사용하는 명령은 chcon 및 restorecon 두 개입니다. chcon 명령은 파일의 컨텍스트를 명령의 인수로 지정된 컨텍스트로 변경합니다. -t 옵션을 사용하여 컨텍스트의 유형 구성 요소만 지정하는 경우가 많습니다.

restorecon 명령은 파일 또는 디렉터리의 SELinux 컨텍스트를 변경하는 데 선호되는 방법입니다. chcon과 달리 이 명령을 사용할 경우 컨텍스트를 명시적으로 지정하지 않습니다. 이 명령은 SELinux 정 책에 규칙을 사용하여 파일의 컨텍스트를 결정합니다.

[참고]

```bash
chcon은 파일의 SELinux 컨텍스트를 변경하는데 사용하지 않아야 합니다. 컨텍스트를 명시적으로 지정할 때 실수를 할 수 있습니다. 부팅 시 시스템의 파일 시스템이 재레이블되지 않을 경우 파일 컨텍스트가 기본값으로 다시 변경됩니다.
```

```bash
[SERVER1]# mkdir /virtual
[SERVER1]# ls -Zd /virtual/
drwxr-xr-x. root root unconfined_u:object_r:default_t:s0 /virtual/
[SERVER1]# ls -Zd /var/www/html
drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 /var/www/html

[SERVER1]# ls -Zd /virtual/
drwxr-xr-x. root root unconfined_u:object_r:default_t:s0 /virtual/
[SERVER1]# ls -Zd /var/www/html
drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 /var/www/html
[SERVER1]# chcon -t httpd_sys_content_t /virtual
[SERVER1]# ls -Zd /virtual/
drwxr-xr-x. root root unconfined_u:object_r:httpd_sys_content_t:s0 /virtual/
[SERVER1]# restorecon -Rv /virtual/
restorecon reset /virtual context unconfined_u:object_r:httpd_sys_content_t:s0->unconfined_u:object_r:default_t:s0
[SERVER1]# ls -Zd /virtual/
drwxr-xr-x. root root unconfined_u:object_r:default_t:s0 /virtual/
[SERVER1]#

chcon 명령은 영구설정은 되지 않기 때문에 재부팅시에는 사용 불가능
```

## SELinux 기본 파일 컨텍스트 규칙 정의

semanage fcontext 명령을 사용하여 restorecon이 기본 파일 컨텍스트를 설정할 때 사용하는 규칙을 표시하거나 수정할 수 있습니다. 

이 명령은 정규 표현식을 사용하여 경로 및 파일 이름을 지정합니다. fcontext 규칙에서 사용되는 가장 일반적인 확장 정규식은 `(/.*)?`이며, “선택적으로 / 뒤에 임의 개수의 문자가 오는 형식과 일치함”을 의미합니다. 식 앞에 나열된 디렉터리와 해당 디렉터리 내의 모든 것에 순환적으로 일치시킵니다.

restorecon 명령은 policycoreutil 패키지의 일부이며, semanage는 policycoreutil-python 패키지 의 일부입니다.

```bash
[SERVER1]# rm -rf /tmp/*
[SERVER1]# touch /tmp/file1 /tmp/file2
[SERVER1]# ls -Z /tmp/file*
-rw-r--r--. root root unconfined_u:object_r:user_tmp_t:s0 /tmp/file1
-rw-r--r--. root root unconfined_u:object_r:user_tmp_t:s0 /tmp/file2

[SERVER1]# mv /tmp/file1 /var/www/html/
[SERVER1]# mv /tmp/file2 /var/www/html/
[SERVER1]# ls -lZl /var/www/html/
합계 0
-rw-r--r--. 1 unconfined_u:object_r:user_tmp_t:s0 root root 0  4월 17 17:53 file1
-rw-r--r--. 1 unconfined_u:object_r:user_tmp_t:s0 root root 0  4월 17 17:53 file2
-rw-r--r--. 1 unconfined_u:object_r:httpd_sys_content_t:s0 root root 0  4월 17 17:38 index.html
[SERVER1]#

[SERVER1]# semanage fcontext -l | grep '/var/www'
/var/www(/.*)?                                     all files          system_u:object_r:**httpd_sys_content_t**:s0

[SERVER1]# restorecon -Rv /var/www
restorecon reset /var/www/html/file1 context unconfined_u:object_r:user_tmp_t:s0->unconfined_u:object_r:**httpd_sys_content_t**:s0
restorecon reset /var/www/html/file2 context unconfined_u:object_r:user_tmp_t:s0->unconfined_u:object_r:**httpd_sys_content_t**:s0
[SERVER1]# ls -lZ /var/www/html/file*
-rw-r--r--. root root unconfined_u:object_r:**httpd_sys_content_t**:s0 /var/www/html/file1
-rw-r--r--. root root unconfined_u:object_r:**httpd_sys_content_t**:s0 /var/www/html/file2

```

semanage를 사용한 새로운 디렉토리에 컨텍스트 추가하기

```bash
[SERVER1]# mkdir /virtual
[SERVER1]# touch /virtual/index.html
[SERVER1]# mkdir /virtual/cgi-page
[SERVER1]# ls -lZd /virtual
drwxr-xr-x. root root unconfined_u:object_r:default_t:s0 /virtual

[SERVER1]# semanage fcontext -a -t httpd_sys_content_t '/virtual(/.*)?'
[SERVER1]# restorecon -RFvv /virtual/
restorecon reset /virtual context unconfined_u:object_r:default_t:s0->system_u:object_r:httpd_sys_content_t:s0
restorecon reset /virtual/index.html context unconfined_u:object_r:default_t:s0->system_u:object_r:httpd_sys_content_t:s0
restorecon reset /virtual/cgi-page context unconfined_u:object_r:default_t:s0->system_u:object_r:httpd_sys_content_t:s0
[SERVER1]# ls -lZd /virtual
drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 /virtual
[SERVER1]# ls -lZR /virtual
/virtual:
drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 cgi-page
-rw-r--r--. root root system_u:object_r:httpd_sys_content_t:s0 index.html

/virtual/cgi-page:

```

```bash
참고
boolean/ semanage 
boolean   기능에 대한 on/off
semanage  컨텍스트에 대한 설정
```

# WEB

# 단원목표

---

- HTTP 개요
- 웹서버 개요
- 간단한 웹서버 구축
- 아파치 웹서버
- 웹보안
- http.conf 파일 해석
- http status code

---

## HTTP(Hypertext Transfer Protocol) 개요

■ HTTP (Hypertext Transfer Protocol) ; 하이퍼텍스트 전송 규약

**-> http://www.daum.net:80 (port 80)**

HTTP는 웹 상에서 파일(텍스트, 그래픽 이미지, 사운드, 비디오 그리고 기타 멀티미디어 파일)을 주고받는데 필요한 프로토콜로서 TCP/IP와 관련된 하나의 응용 프로토콜이다.

HTTP의 한 부분을 이루는 중요한 개념들은 - 그 이름에도 내포되어 있듯이 - 모든 파일들이 다른 파일들에 대한 참조 링크를 가질 수 있다는 것이며, 그 링크를 선택하면, 또다른 내용이 추가적으로 전달되는 식의 아이디어로 되어 있다. 웹 서버는 모두 HTTP 데몬을 가지고 있는데, 이 프로그램은 HTTP 요청을 기다리고 있다가 요청이 들어오면 그것을 처리하도록 설계되어 있다. HTTP의 입장에서의 웹 브라우저는 서버에 요구를 전달하는 하나의 클라이언트이다. 사용자가 URL을 입력하거나, 하이퍼텍스트 링크를 클릭 함으로써 파일을 요구하면, 브라우저는 HTTP 요구를 URL에 적혀있는 IP 주소에 전달한다. 지정된 서버상의 HTTP 데몬은 그 요구를 받아서, 필요한 작업이 혹 있다면 처리를 한 뒤에 요구된 파일을 찾아서 보내준다.

- HTTP 프로토콜은 WWW(World Wide Web)에서 사용되는 프로토콜이다.
- HTTP 프로토콜은 간단(Simple)한 비상태기반 프로토콜(Stateless Protocol)이다.
- 클라이언트 측면 요청(Client-Side Request)와 서버측면 응답(Server-Side Response)으로 구성된다.
- 요청과 응답은 3가지 부분으로 구성이 된다.
① 요청 코드(Request Method)/응답 코드(Response Code)
② 헤더(Header)
③ 바디(Body)

■ HTTPS (Secure Hypertext Transfer Protocol)

**-> https://www.daum.net:443 (port 443)**

HTTPS는 넷스케이프에 의해 개발되고 그들의 브라우저에 구현된 웹 프로토콜로서, 사용자의 페이지 요청들과 웹서버에 의해 반환되는 페이지들을 암호화하고 해석한다. HTTPS는 실제로 넷스케이프의 SSL을 정규 HTTP 응용계층 하에서 서브 계층으로서 사용한다 (HTTP가 하부계층인 TCP/IP와의 상호작용을 위해 80번 포트를 사용하는데 비해, HTTPS는 443번 포트를 사용한다). SSL은 RC4 스트림 암호화 알고리즘을 위해 40 비트 크기의 키를 사용하는데, 이는 상업적 데이터의 교환을 위한 암호화 정도에 적합하다고 간주된다.

NetPlaza (http://www.netplaza.com)와 같은 웹사이트에 방문해서 그들의 카탈로그를 보기 위해 넷스케이프 브라우저를 사용한다고 가정하라. 주문할 준비가 되었을 때, 사용자는 URL이 https://로 시작되는 웹페이지 주문서를 받게 될 것이다. 사용자가 그 페이지를 판매자에게 보내기 위하여 "보내기" 단추를 클릭하면, 브라우저의 HTTPS 계층이 그 페이지를 암호화한다. 서버가 받았음을 알리는 회신내용 역시 암호화된 형식으로 도착되지만, 그 내용은 브라우저의 HTTPS 서브 계층에 의해 해석된다.

HTTPS와 SSL은 서버로부터의 X.509 디지털 인증서 사용을 지원하므로, 필요한 경우 사용자는 발신자를 믿을 수 있음을 증명할 수 있다. SSL은 넷스케이프가 W3C에 표준으로 제안한 개방형이며, 비독점적 프로토콜이다. HTTPS를 EIT가 개발하고 표준으로 제안한 HTTP의 보안 강화판인 SHTTP와 혼동하면 안된다.

■ S-HTTP (Secure HTTP)

S-HTTP는 월드와이드웹 상의 파일들이 안전하게 교환될 수 있게 해주는 HTTP의 확장판이다. 각 S-HTTP 파일은 암호화되며, 전자서명을 포함한다. S-HTTP는 잘 알려진 또다른 보안 프로토콜인 SSL의 대안이다. 두 가지의 주요 차이점은, S-HTTP는 틀림없는 사용자라는 것을 입증하기 위한 인증서를 클라이언트에서 보낼 수 있는 반면에, SSL에서는 오직 서버만이 인증할 수 있다는 점이다. S-HTTP는 은행을 대리해 서버가 있는 곳, 또는 사용자ID와 패스워드를 사용하는 것보다 좀더 안전한 사용자로부터 인증이 필요한 상황에서 보다 많이 사용될 것 같다.

S-HTTP는 어떠한 단일 암호화 시스템을 사용하지 않지만, RSA 공개키/개인키 암호화 시스템은 지원한다. SSL은 TCP 계층보다 더 상위의 프로그램 계층에서 동작한다. S-HTTP는 HTTP 응용의 상위 계층에서 동작한다. 두 개의 보안 프로토콜들 모두가 한 사용자에 의해 사용될 수 있지만, 주어진 문서에 대해서는 오직 그중 하나만이 사용될 수 있다. Terisa Systems은 인터넷 보안도구 내에 SSL과 S-HTTP 모두를 포함한다.

AOL, 컴퓨서브, IBM, 넷스케이프, Prodigy, 그리고 Spyglass 등이 S-HTTP를 지원한다. 새로 나오는 브라우저들은 SSL과 S-HTTP를 모두 지원한다. S-HTTP는 IETF에 표준안으로 상정되었다. RFC 2660에 S-HTTP에 대해 자세한 설명이 나와있다.

S-HTTP에 관해 설명하고 있는 IETF의 RFC 2660 초안입니다. (http://www.ietf.org/rfc/rfc2660.txt)

## 웹 서버(Web Server) 개요

(1) 웹서버(Web Server)란?

웹 브라우저를 이용하여 World Wide Web을 사용하는 클라이언트에게 미리 저장된 하이퍼 텍스트를 제공하는 서버를 지칭한다.

```bash
(웹브라우저) <--------------> (웹서버)
Internet explore	Apache(httpd)
Firefox	IIS
Mozilla	.....
Crome
```

(2) 웹서버(Web Server)의 종류

```bash
종류                           설명
NCSA Server                   아파치 서버의 모태.(NCSA httpd 1.3.X)
CERN Server                   스위스에 있는 유럽 핵물리 연구기관으로 World Wide Web 프로젝트가 시작된곳.
Apache Server                 NCSA서버의 개량형, 성능과 기능면에서 우수. 하나의 port(default:80)에서 일반 Web과 Proxy 동시 지원 각 기능의 MoDule화 가장 많이 사용되는 Web Server이다.
Apache-SSL Server             아파치 서버의 보안성을 높혔다. 무료로사용, 128bit 엔크립션사용(암호화)
Netscape Enterprise Server    상업용 서버 인데, 현재 거의 사용 하지 않는다.
IIS                           Internet Information Server, window NT Server용. HTTP(Hypertext Transfer Protocol) 바이트 범위 지원.SQL데이터를 HTML 형식으로 변환. CGI 응용프로그램이 모든 환수 변수를 받음. HTML 페이지와 기타 문서의 내용에 색인 붙이기. SSL 키를 만들기 위한 그래픽 도구
AOL Server                   다양한 플랫폼을 지원.
```

(3) 고성능의 웹서버가 개발되기 위한 요건

```bash
요건                       설명
동시처리(Concurrency)                   서버는 동시에 여러개의 클라이언트 요청을 수행해야만 한다.
효율성(Efficiency)                     서버는 지연(latency)을 최소화해야하고, 대역폭을 최대로 활용해야 하며, 불필요하게 CPU(들)을 동작시키는 것을 피해야 한다.
프로그래밍 단순화(Programming simplicity) 서버의 디자인은 효율적인 동시처리에 대한 운영 전략의 적용을 단순화할 수 있어야 한다.
적응성(Adaptability)                   신규 혹은 개선된 트랜스포트 프로토콜(HTTP 1.1과 같은)을 지원하는데 있어서 최소한의 관리 비용이 들도록 해야한다.
```

(4) 웹서버의 구조

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3972e689-55c9-4970-885e-9e5888962c9a/_2020-03-24__12.32.37.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3972e689-55c9-4970-885e-9e5888962c9a/_2020-03-24__12.32.37.png)

```bash
① Client는 웹브라우저를 통해 HTTP 요청 
② 웹서버는 요청에 대한 내용을 분석
③ 요청된 내용에 맞는 컨텐츠를 찾는다.
④ Client에게 파일을 보낸다.
```

(4-1) 동기(멀티스레드) 웹서버 구조

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3dd27d7c-caa3-43c0-aeae-47e56f40e621/_2020-03-24__12.33.02.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3dd27d7c-caa3-43c0-aeae-47e56f40e621/_2020-03-24__12.33.02.png)

```bash
① 각 쓰레드는 accept()함수실행시 클라이언트 접속요청이 올때까지 동기적으로 블록당한다.
② 클라이언트가 서버에 연결되면, 접속이 accept된다. (블럭이 풀린다)
③ 새로 접속된 클라이언트의 HTTP 요청이 동기적으로 네트워크 연결을 통하여 읽혀진다.
④ 요청에 대한 것을 분석한다.
⑤ 요청된 파일을 동기적으로 읽는다.
⑥ 파일의 내용이 동기적으로 클라이언트에게 전송된다.
```

(4-2) 비동기 웹서버 구조

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f6eedf19-d977-427d-a26c-b3e9a393ecaa/_2020-03-24__12.33.25.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f6eedf19-d977-427d-a26c-b3e9a393ecaa/_2020-03-24__12.33.25.png)

```bash
① 웹서버는 acceptor에게 비동기 accept 처리를 초기화하도록 알려준다.
② acceptor는 운영체계의 기능을 이용하여 비동기 accept 요청을 초기화하고, 그 자신을 완료 핸들러(Completion 
   Handler)와 완료 발송자(Completion Dispatcher)의 참조로써 넘기게 된다. (이것은 비동기 accept의 완료여부
   를 acceptor에게 알려주는데 사용된다.)
③ 웹서버는 완료 발송자의 이벤트 루프를 실행한다.
④ 클라이언트가 웹서버에 접속한다.
⑤ 비동기 accept 명령이 완료하면, 운영체계는 완료 발송자에게 통지한다.
⑥ 완료 발송자는 acceptor에게 통지한다.
⑦ acceptor는 HTTP 핸들러를 생성한다.
⑧ HTTP 핸들러는 클라이언트로 부터 전송되는 요청 데이터를 비동기적으로 읽는 작업을 초기화하고 그 자신을 완
   료 핸들러(Completion Handler)와 완료 발송자(Completion Dispatcher)의 참조로써 넘기게 된다. (이것은 비동
   기 읽기작업의 완료여부를 acceptor에게 알려주는데 사용된다.)
```

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/443d7391-9a62-4ee4-b62e-4151c385e0bf/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/443d7391-9a62-4ee4-b62e-4151c385e0bf/Untitled.png)

[참고] 쓰레드(thread)

```bash
쓰레드(thread)는 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 말한다. 일반적으로 한 프로그램은 하나의 스레드를 가지고 있지만, 프로그램 환경에 따라 둘 이상의 스레드를 동시에 실행할 수 있다. 이러한 실행 방식을 멀티스레드(multithread)라고 한다.

사용자 쓰레드
사용자 스레드는 커널 영역의 상위에서 지원되며 일반적으로 사용자 레벨의 라이브러리를 통해 구현되며, 라이브러리는 스레드의 생성 및 스케줄링 등에 관한 관리 기능을 제공한다. 동일한 메모리 영역에서 스레드가 생성 및 관리되므로 속도가 빠른 장점이 있는 반면, 여러 개의 사용자 스레드 중 하나의 스레드가 시스템 호출 등으로 중단되면 나머지 모든 스레드 역시 중단되는 단점이 있다. 이는 커널이 프로세스 내부의 스레드를 인식하지 못하며 해당 프로세스를 대기 상태로 전환시키기 때문이다.

커널 쓰레드
커널 스레드는 운영체제가 지원하는 스레드 기능으로 구현되며, 커널이 스레드의 생성 및 스케줄링 등을 관리한다. 스레드가 시스템 호출 등으로 중단되더라도, 커널은 프로세스 내의 다른 스레드를 중단시키지 않고 계속 실행시켜준다. 다중처리기 환경에서 커널은 여러 개의 스레드를 각각 다른 처리기에 할당할 수 있다. 다만, 사용자 스레드에 비해 생성 및 관리하는 것이 느리다.
```

## 간단한 웹서버 (Apache Web Server) 구성

아파치는 "open source" 라이선스에 따라 배포되어 마음대로 쓸 수 있는 웹서버이다. 버전 1.3은 리눅스, Solaris, Digital UNIX, AIX와 같은 대부분의 유닉스 기반 운영체계, Rhapsody, BeOS, BS2000/OSD 등과 같이 유닉스/포직스에서 파생된 시스템들, 그리고 AmigaOS 및 윈도우NT/95/98 등에서 실행된다. Netcraft에서 1998년 9월에 실시한 웹서버 실태조사에 따르면, 전세계 인터넷 서버의 50% 이상이 아파치에서 운영되고 있다고 한다. 마이크로소프트에서 나온 윈도우기반의 웹서버, 넷스케이프, 그리고 다른 회사들이 수 적인 면에서 보면 늘어가고 있지만, 아파치는 아마도 유닉스 기반의 시스템이 널리 퍼져 있는 기업이나 대학에서 대중적 인기를 계속 유지할 것으로 보인다.

아파치의 Market share에 대한 부분은 **http://www.netcraft.com/survey** 사이트를 참고한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/84747ca2-6b20-489a-9749-3078e3b8b9ae/_2020-03-27__3.44.50.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/84747ca2-6b20-489a-9749-3078e3b8b9ae/_2020-03-27__3.44.50.png)

아파치는 HTTP의 최신판인 버전 1.1을 따른다. 몇몇 유즈넷 뉴스그룹과 버그 보고시스템을 통한 무료지원이 제공된다. 몇몇 회사들은 비용을 받고 지원해주기도 한다.

- **아피치(Apache) 공식 홈페이지 :** **http://www.apache.org**
- 1995년까지 대부분의 많이 사용하는 웹서는 NCSA httpd 1.3 프로그램을 사용했다.
- NCSA httpd 프로그램에서 아파치(**A** **PA**t**CH**y s**E**rver) 웹서버가 나왔다.
- 현재는 일반적인 웹서버로 광범위하게 사용중이다.(전 세계의 웹서버의 60% 이상)

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7e2d2de7-ebc9-467c-88bc-92d2d1e1a78a/_2020-03-27__3.45.25.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7e2d2de7-ebc9-467c-88bc-92d2d1e1a78a/_2020-03-27__3.45.25.png)

### (1) 간단한 웹서버 구성

INDEX

**------------------------------**

1. 실습준비

2. 관리자를 위한 웹기본 설정

3. 사용자를 위한 웹기본 설정

**------------------------------**

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0ac1a5a9-df56-493f-92f7-dd91c5181db0/_2020-03-27__3.45.58.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0ac1a5a9-df56-493f-92f7-dd91c5181db0/_2020-03-27__3.45.58.png)

### (1-1) 실습준비

```bash
----- DNS Server ---------- WEB Server -----
    (192.168.10.200)      (192.168.10.210)

--------------------------------------------

[그림] 실습 구조(Master/Slave DNS Server)
```

```bash
(DNS 서버쪽) 192.168.10.200 
- /etc/resolv.conf 파일 설정
- Master DNS 서버만 구축
  -> 웹서버 등록

(WEB 서버쪽) 192.168.10.210
- /etc/resolv.conf 파일 설정
- (Optional) /etc/hosts 파일설정
```

> DNS 서버 확인

> /etc/resolv.conf 파일 설정

**[SERVER1]# cat /etc/resolv.conf**

```
# Generated by NetworkManager
search example.com
nameserver 192.168.10.200
nameserver 8.8.8.8
```

**[SERVER1]# cd /var/named/**

**[SERVER1]# cat server.zone**

```
$TTL          4                                                        
@             IN         SOA      ns1.example.com.  root.example.com.  (
0             ;          serial                                        
1D            ;          refresh                                       
1H            ;          retry                                         
1W            ;          expire                                        
3H            )          ;        minimum                              
NS            @                                                        
A             127.0.0.1                                                
AAAA          ::1                                                      
IN            NS         ns1                                           
ns1           IN         A        192.168.10.200                       
www           IN         A        192.168.10.210                       
nfs           IN         A        192.168.10.220                       
ftp           IN         A        192.168.10.220                       
example.com.  IN         MX       10                mail.example.com.  
mail          IN         A        192.168.10.220                       
iscsi         IN         A        192.168.10.220
```

**[SERVER1]# nslookup [www.example.com](http://www.example.com/)**

```
Server:		192.168.10.200
Address:	192.168.10.200#53

Name:	www.example.com
Address: 192.168.10.210
```

(웹 서버쪽) 192.168.10.210

**[SERVER2]# cat /etc/resolv.conf**

```
# Generated by NetworkManager
search example.com
nameserver 192.168.10.200
```

DNS 서버쪽을 지정했기 때문에 DNS 서버쪽에서 도메인을 등록한 경우 정상적으로 동작할 것이다.
만약 DNS 서버가 없는 환경이라면 /etc/hosts 파일을 사용하면 된다.

> 관리자를 위한 웹 기본 설정

```bash
패키지: httpd
------ Web Server ------------ Web Client ------

httpd(80)
- /etc/httpd/conf/httpd.conf            <----  메인 설정 파일
- /var/www/html/index.html              <----  http://www.example.com/
- /home/<사용자>/public_html/index.html   <----  http://www.example.com/~user01/
```

> 패키지 확인

**[SERVER2]# dnf -y install httpd**

**[SERVER2]# rpm -qa | grep httpd**

```
centos-logos-httpd-80.5-2.el8.noarch
httpd-filesystem-2.4.37-21.module_el8.2.0+382+15b0afa8.noarch
**httpd-2.4.37-21.module_el8.2.0+382+15b0afa8.x86_64**
httpd-tools-2.4.37-21.module_el8.2.0+382+15b0afa8.x86_64
```

**[SERVER2]# rpm -ql httpd**

> 데몬 확인 및 포트 확인

**[SERVER2]# httpd -v**

```
Server version: Apache/2.4.37 (centos)
Server built:   Jun  8 2020 20:14:33
```

**[SERVER2]# cat /etc/services | grep ^http**

```
http            80/tcp          www www-http    # WorldWideWeb HTTP
http            80/udp          www www-http    # HyperText Transfer Protocol
http            80/sctp                         # HyperText Transfer Protocol
https           443/tcp                         # http protocol over TLS/SSL
https           443/udp                         # http protocol over TLS/SSL
https           443/sctp                        # http protocol over TLS/SSL
http-mgmt       280/tcp                 # http-mgmt
http-mgmt       280/udp                 # http-mgmt
http-rpc-epmap  593/tcp                 # HTTP RPC Ep Map
http-rpc-epmap  593/udp                 # HTTP RPC Ep Map
httpx           4180/tcp                # HTTPX
httpx           4180/udp                # HTTPX
http-wmap       8990/tcp                # webmail HTTP service
http-wmap       8990/udp                # webmail HTTP service
https-wmap      8991/tcp                # webmail HTTPS service
https-wmap      8991/udp                # webmail HTTPS service
```

> 주 설정 파일 확인

**[SERVER2]# cd /etc/httpd/conf**

**[SERVER2]# ls -l**

```
합계 28
-rw-r--r--. 1 root root 11899  6월  9 05:12 httpd.conf
-rw-r--r--. 1 root root 13064  6월  9 05:15 magic
```

> index.html 파일 생성 및 확인

**[SERVER2]# cd /var/www/html**

**[SERVER2]# ls**

```

```

초기 설치시에는 아무런 파일이 없다. 

**[SERVER2]# echo "SERVER2 TEST web" > /var/www/html/index.html**

**[SERVER2]# ls -l**

```
합계 4
-rw-r--r--. 1 root root 17  8월  3 06:27 index.html
```

**[SERVER2]# systemctl start httpd**

**[SERVER2]# systemctl status httpd**

**[SERVER2]# systemctl enable httpd**

> 웹서비스 확인

■ 웹서비스를 확인하는 여러가지 방법

- GUI 웹브라우저를 사용하는 방법(EX: firefox)
- TUI 웹브라우저를 사용하는 방법(EX: lynx/curl)
- telnet 명령어를 사용하는 방법(EX: telnet <서버 IP> 80)
- netstat 명령어를 사용하는 방법(EX: netstat -an | :80)

■ GUI 웹브라우저를 사용하는 방법

```
# firefox http://www.example.com &
```

**[SERVER2]# curl [www.example.com](http://www.example.com/)**

```
SERVER2 TEST web
```

> lynx [TUI 웹 브라우저 설치]

**[SERVER2]# dnf -y install dnf-plugins-core**

**[SERVER2]# dnf -y install [https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm](https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm)**

**[SERVER2]# dnf config-manager --set-enabled PowerTools**

**[SERVER2]# dnf repolist**

**[SERVER2]# dnf -y install lynx**

**[SERVER2]# lynx [www.example.com](http://www.example.com/)**

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6b640abc-d497-4ca2-869b-7f672b80f3b7/_2020-08-02__10.19.20.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6b640abc-d497-4ca2-869b-7f672b80f3b7/_2020-08-02__10.19.20.png)

**[SERVER2]# lynx -head [http://www.example.com](http://www.example.com/)**

```
HTTP/1.1 200 OK
Date: Sun, 02 Aug 2020 21:42:58 GMT
Server: Apache/2.4.37 (centos)
Last-Modified: Sun, 02 Aug 2020 21:27:16 GMT
ETag: "11-5abebafb1f691"
Accept-Ranges: bytes
Content-Length: 17
Connection: close
Content-Type: text/html; charset=UTF-8

q                                       <----- 'q' 입력
Are you sure you want to quit? (y) y    <----- 'y' 입력
```

**[SERVER1]# dnf -y install dnf-plugins-core ; dnf -y install [https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm](https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm) ; dnf config-manager --set-enabled PowerTools ; dnf repolist ; dnf -y install lynx**

**[SERVER1]# dnf -y install lynx**

> 서버 외부에서 접속하기

**[SERVER1]# nslookup [www.example.com](http://www.example.com/)**

```
Server:		192.168.10.200
Address:	192.168.10.200#53

Name:	www.example.com
Address: 192.168.10.210
```

**[SERVER1]# lynx [www.example.com](http://www.example.com/)**

```
Looking up www.example.com first
Looking up www.example.com
Making HTTP connection to www.example.com
Alert!: Unable to connect to remote host.

lynx: Can't access startfile http://www.example.com/
```

**[SERVER2]# firewall-cmd --list-services**

```
 cockpit dhcpv6-client ssh
```

**[SERVER2]# firewall-cmd --permanent --add-service=http**

**[SERVER2]# firewall-cmd --reload**

**[SERVER1]# lynx [www.example.com](http://www.example.com/)**

■ telnet 명령어를 사용하는 방법

[SERVER1]# dnf -y install telnet

[SERVER1]# telnet [www.example.com](http://www.example.com/) 80

```
Trying 192.168.10.210...
Connected to www.example.com.
Escape character is '^]'.
GET  << 입력

HTTP/1.1 400 Bad Request
Date: Sun, 02 Aug 2020 21:49:18 GMT
Server: Apache/2.4.37 (centos)
Content-Length: 226
Connection: close
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>400 Bad Request</title>
</head><body>
<h1>Bad Request</h1>
<p>Your browser sent a request that this server could not understand.<br />
</p>
</body></html>
Connection closed by foreign host.
```

■ netstat 명령어를 사용하는 방법

**[SERVER2]# netstat -antp**      (-a: all, -n: numeric, -t: tcp, -u: udp, -p: program)

```
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:5355            0.0.0.0:*               LISTEN      993/systemd-resolve 
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      857/sshd            
tcp        0      0 192.168.10.210:22       192.168.10.1:54741      ESTABLISHED 22352/sshd: root [p 
tcp6       0      0 :::5355                 :::*                    LISTEN      993/systemd-resolve 
tcp6       0      0 :::80                   :::*                    LISTEN      22992/httpd         
tcp6       0      0 :::22                   :::*                    LISTEN      857/sshd            
tcp6       0      0 192.168.10.210:80       192.168.10.200:55548    TIME_WAIT   -
```

[참고] netstat -an 명령어의 사용법에 대해서

```bash
# netstat -an      /* 모든 서비스: TCP + UDP + 소켓 */
# netstat -ant     /* TCP 서비스만 */
# netstat -anu     /* UDP 서비스만 */

# netstat -anp     /* 모든 서비스: TCP + UDP + 소켓, 프로그램이름/PID 표시 */
# netstat -antp /* TCP 서비스만, 프로그램 이름/PID 표시 */
# netstat -anup    /* UDP 서비스만, 프로그램 이름/PID 표시 */
```

> 사용자를 위한 웹 기본 설정

[전제조건] user01,user02,fedora 사용자가 존재해야 한다.

**[SERVER2]# useradd user01**

**[SERVER2]# useradd user02**

**[SERVER2]# passwd user01**

**[SERVER2]# passwd user02**

**[SERVER2]# tail -2 /etc/passwd**

```
user01:x:1001:1001::/home/user01:/bin/bash
user02:x:1002:1002::/home/user02:/bin/bash
```

> user01 사용자 홈디렉토리에 public_html 디렉토리와 index.html 파일 생성

**[SERVER2]# su - user01**

**[user01@server2 ~]$ mkdir public_html**

**[user01@server2 ~]$ cd public_html**

**[user01@server2 public_html]$ vi index.html**

```
Web Server(SERVER2 : user01)
```

> 사용자 홈디렉토리 퍼미션 변경

**[user01@server2 public_html]$ cd**

**[user01@server2 ~]$ ls -ld .**

```
drwx------. 3 user01 user01 97 Aug  3 07:10 .
```

**[user01@server2 ~]$ chmod 755 /home/user01**

**[user01@server2 ~]$ ls -ld .**

```
drwxr-xr-x. 3 user01 user01 97 Aug  3 07:10 .
```

**[user01@server2 ~]$ exit**

> /etc/httpd/conf/httpd.conf 파일 수정 및 적용

**[SERVER2]# vi /etc/httpd/conf/httpd.conf   (CENTOS 8 버전 이전에 사용)**

```
/UserDir          <------ Last Line Mode에서 '/UserDir' 입력

E486: Pattern not found: UserDir
```

**[SERVER2]# cd /etc/httpd/conf.d**

**[SERVER2]# ls**

```
README  autoindex.conf  userdir.conf  welcome.conf
```

**[SERVER2]# vi /etc/httpd/conf.d/userdir.conf**

```
[수정전]
..... (중략) .....
<IfModule mod_userdir.c>
    #
    # UserDir is disabled by default since it can confirm the presence
    # of a username on the system (depending on home directory
    # permissions).
    #
    UserDir disable          

    #
    # To enable requests to /~user/ to serve the user's public_html
    # directory, remove the "UserDir disable" line above, and uncomment
    # the following line instead:
    #
    #UserDir public_html

</IfModule>
..... (중략) .....

[수정후]
..... (중략) .....
<IfModule mod_userdir.c>
    #
    # UserDir is disabled by default since it can confirm the presence
    # of a username on the system (depending on home directory
    # permissions).
    #
**#--->    UserDir disable           <----- '기존 라인 주석처리'**

    #
    # To enable requests to /~user/ to serve the user's public_html
    # directory, remove the "UserDir disable" line above, and uncomment
    # the following line instead:
    #
    **UserDir public_html            <----- '기존 라인 주석처리 해제'**
```

**[SERVER2]# systemctl restart httpd**

만약 에러메세지가 발생한다면 무시하고 넘어가나. 또는 아래 내용을 참고하여 /etc/hosts 파일에 긴 이름의 호스트 이름을 등록하고 httpd 서비스를 재시작하면 된다.

[참고] httpd 서비스 start 시 에러메세지 제어

```
# systemctl restart httpd
httpd: Could not reliably determine the server's fully qualified domain name, using 127.0.0.1 for ServerName
# vi /etc/hosts 
192.168.10.210  server2.example.com  server2
# systemctl restart httpd
```

**[SERVER2]# lynx [www.example.com/~user01](http://www.example.com/~user01)**

**[SERVER2]# setsebool -P httpd_enable_homedirs on**

**[SERVER2]# restorecon -R /home**

**[SERVER2]# lynx [www.example.com/~user01](http://www.example.com/~user01)**

(정리) 사용자 웹페이지

```bash
----- Web Client -----                      ----- Web Server -----
http://DAUM/~user01  ---------------------> httpd(80)
																						/home/<사용자>/public_html/index.html 
																						# cat /etc/httpd/conf.d/userdir.conf
																						UserDir public_html
```

(1-4) 사용자를 위한 웹 기본 설정2

```bash
(웹 요청 비교)
http://www.example.com/~user01/
http://www.example.com/user01/     (http://cafe.naver.com/testcafe)
```

사용자 웹 페이지 및 하위 웹페이지의 구성

> /etc/httpd/conf/httpd.conf 파일 설정

**[SERVER2]# vi /etc/httpd/conf/httpd.conf**

```
    #
    # Alias: Maps web paths into filesystem paths and is used to
    # access content that does not live under the DocumentRoot.
    # Example:
    # Alias /webpath /full/filesystem/path
    #
    # If you include a trailing / on /webpath then the server will
    # require it to be present in the URL.  You will also likely
    # need to provide a <Directory> section to allow access to
    # the filesystem path.
Alias /user01/ "/home/user01/public_html/"     <----- 새로운 라인 추가
```

**[SERVER2]# systemctl restart httpd**

**[SERVER2]# lynx [www.example.com/user01](http://www.example.com/user01)**

**[SERVER2]# lynx [www.example.com/user01/](http://www.example.com/user01/)**

**[SERVER2]# vi /etc/httpd/conf/httpd.conf**

```
    #
    # Alias: Maps web paths into filesystem paths and is used to
    # access content that does not live under the DocumentRoot.
    # Example:
    # Alias /webpath /full/filesystem/path
    #
    # If you include a trailing / on /webpath then the server will
    # require it to be present in the URL.  You will also likely
    # need to provide a <Directory> section to allow access to
    # the filesystem path.
Alias /user01/ "/home/user01/public_html/"     
Alias /user01  "/home/user01/public_html/"     <----- 새로운 라인 추가
```

**[SERVER2]# systemctl restart httpd**

**[SERVER2]# lynx [www.example.com/user01](http://www.example.com/user01)**

> Alias 비교

```bash
Alias /user01/ "/home/user01/public_html/"  http://www.example.com/user01/
Alias /user01 "/home/user01/public_html/"   http://www.example.com/user01   << 
```

```bash
(추가적인 실습)
# cat /etc/httpd/conf/httpd.conf
DocumentRoot "/var/www/html"

# mkdir –p /var/www/html/user100
# echo hello > /var/www/html/user100/index.html

# firefox http://www.example.com/user100/
```

# 아파치 웹서버(Apache Web Server)

## 아파치 웹서버에 관련한 파일/디렉토리

```bash
종 류                            설 명
/etc/httpd/conf/httpd.conf      아파치 웹서버 주 설정 파일
/etc/httpd/conf.d/*.conf        아파치 웹서버 주 설정 파일에 포함된 하위 설정 파일
/etc/httpd/logs                 /var/log/httpd/, 아파치 웹서버 로그 디렉토리
/etc/httpd/modules              /usr/lib/httpd/modules/, 아파치 웹서버 모듈 디렉토리
/etc/httpd/run/httpd.pid        /var/run/, 실행 중인 아파치 데몬의 PID 번호를 저장하는 파일
/etc/mime.types                 CUPS을 위한 MIME 타입 설명 파일
/etc/rc.d/init.d/httpd          아파치 데몬을 제어할 수 있는 스크립트
/usr/sbin/httpd                 아파치 웹데몬
/usr/sbin/htpasswd              특정 디렉토리를 제어할 때 사용하는 사용자 패스워드 입력 프로그램
/usr/sbin/apxs                  DSO(Dynamic Shared Object) 기반 아파치 모듈을 컴파일할 때 사용되는 유틸러티
```

### (Alias for Apache Web Server)

```bash
# vi ~/.bashrc
..... (중략) .....
#
# Alias for Web Server
#
alias WEB='cd /etc/httpd/conf'
alias WWW='cd /var/www/html'
alias httpd.conf='vi /etc/httpd/conf/httpd.conf'
alias wlog='tail -f /etc/httpd/logs/access_log'
alias welog='tail -f /etc/httpd/logs/error_log'

# . ~/.bashrc    (# source ~/.bashrc)
```

(1) 기본 설정 상태 확인

```bash
# cd /etc/httpd 
# ls -lR         (# find .)
.:
total 16
drwxr-xr-x 2 root root 4096 Mar 14 20:04 conf
drwxr-xr-x 2 root root 4096 Feb 28 01:49 conf.d
lrwxrwxrwx 1 root root   19 Feb 24 00:50 logs -> ../../var/log/httpd
lrwxrwxrwx 1 root root   27 Feb 24 00:50 modules -> ../../usr/lib/httpd/modules
lrwxrwxrwx 1 root root   13 Feb 24 00:50 run -> ../../var/run

./conf:
total 52
-rw-r--r-- 1 root root 33760 Mar 14 19:38 httpd.conf
-rw-r--r-- 1 root root 13139 Nov 13 08:47 magic

./conf.d:
total 64
-rw-r--r-- 1 root root  295 Nov 13 08:47 manual.conf
-rw-r--r-- 1 root root 1796 Apr 22  2005 perl.conf
-rw-r--r-- 1 root root  560 Jan 14 07:16 php.conf
-rw-r--r-- 1 root root  566 Nov 13 08:47 proxy_ajp.conf
-rw-r--r-- 1 root root 1671 Jan  7  2007 python.conf
-rw-r--r-- 1 root root  392 Nov 13 08:47 README
-rw-r--r-- 1 root root  332 Jan 21  2009 squid.conf
-rw-r--r-- 1 root root 9677 Nov 13 08:47 ssl.conf
-rw-r--r-- 1 root root  352 Jan  9  2007 webalizer.conf
-rw-r--r-- 1 root root  299 Nov 13 08:47 welcome.conf
```

(2) /etc/httpd/conf/httpd.conf 파일 분석

httpd.conf 파일은 3가지 섹션으로 구분한다.

- Section 1 : Global environment
- Section 2 : "Main" server configuration
- Section 3 : Virtual hosts  < conf.d 디렉토리에 따로 정의

### 지시자 파일

**(Section 1)** 중요한 지시자(Directive)

- ServerType
- ServerRoot
- StartServers
MinSpareServers
MaxSpareServers
- MaxClients
- LoadModule

**(Section 2)** 중요한 지시자(Directive)

- Listen
- User/Group
- DocumentRoot
- <Directory "/path/to/somedir"> </Directory>
- AccessFileName
- Log file locations and formats
- Modules specific configuration blocks
- MIME type definitions and handlers: /etc/mime.types

**(Section 3)** 중요한 지시자(Directive)

- NameVirtualHost
- <VirtualHost 10.100.0.50> ... </VirtualHost>
- ServerName
- Documentation

-> "Section 3"의 설정은 "Section 2"에 설정을 덮어 쓰게 된다.

[참고] 이 문서의 마지막 부분은 "Appendix A. httpd.conf 파일 해석" 부분을 참고한다.

(3) Apache Web Server 실행

```bash
		(현재) # systemctl (restart/start/stop) httpd
		(부팅) # systemctl enable httpd
(httpd 명령어 사용법)
# httpd -t                  /* httpd.conf 파일의 문법 점검(Syntax Check) */
# httpd -v                  /* httpd 버전 확인 */
# httpd -f httpd_test.conf  /* httpd_test.conf 파일의 설정대로 데몬을 띄운다. */
```

```bash
② httpd -v 옵션 사용
# httpd -v
Server version: Apache/2.4.37 (centos)
Server built:   Jun  8 2020 20:14:33
-> Apache 2.4.37 버전을 사용하고 있다.

       # man httpd 
       -v     Print the version of httpd, and then exit.
```

```bash
③ httpd -f httpd.conf 옵션 사용
# systemctl stop httpd
-> 만약 이전 실습에서 httpd 데몬이 떠 있었다면 서비스를 종료 한다.

# cd /etc/httpd/conf 
# cp httpd.conf httpd_test.conf 
# httpd -f /etc/httpd/conf/httpd_test.conf 
# pgrep -lf httpd
26344 httpd -f /etc/httpd/conf/httpd_test.conf
26345 httpd -f /etc/httpd/conf/httpd_test.conf
26346 httpd -f /etc/httpd/conf/httpd_test.conf
26347 httpd -f /etc/httpd/conf/httpd_test.conf
26348 httpd -f /etc/httpd/conf/httpd_test.conf
26349 httpd -f /etc/httpd/conf/httpd_test.conf
26350 httpd -f /etc/httpd/conf/httpd_test.conf
26351 httpd -f /etc/httpd/conf/httpd_test.conf
26352 httpd -f /etc/httpd/conf/httpd_test.conf
```

```bash
④ 아파치 서비스 restart(원래 상태의 데몬으로 변경한다.)
# ps -ef | grep httpd
httpd -f /etc/httpd/conf/httpd_test.conf라인으로 검색된 PID를 강제 종료
# kill -9 PID
# systemctl start httpd
# pgrep -lf httpd 
-> 기본 설정 파일을 가지고 데몬이 떠 있는지 확인한다.
```

(4) 아파치 웹서버 설정

(4-1) 아파치 웹서버 기본 설정'

```bash
31 ServerRoot "/etc/httpd"
	이 지시문은 httpd가 상대 경로 이름을 사용하여 구성 파일에서 참조된 파일을 찾는 위치를 지정합 니다.
42 Listen 80
	이 지시문은 httpd에 모든 인터페이스의 포트 80/TCP에서 수신 대기하도록 지시합니다. 선택한 인 터페이스에서만 수신 대기하도록 하려면 IPv4의 경우에는 구문 “Listen 1.2.3.4:80”을, IPv6의 경 우에는 구문 “Listen [2001:db8::1]:80”을 사용할 수 있습니다.
	참고: 여러 listen 지시문이 허용되지만 listen 지시문을 중복해서 사용하면 치명적 오류가 발생하 여 httpd가 시작되지 못할 수도 있습니다.
56 Include conf.modules.d/*.conf
	이 지시문에는 마치 파일이 구성 파일의 Include 문에 삽입된 것과 같이 여러 다른 파일이 포함되어 있습니다. 여러 파일이 지정되면 포함하기 전에 파일 이름의 영숫자순으로 정렬됩니다. 파일 이름은 절대 이름이거나 ServerRoot에 상대적일 수 있으며 *와 같은 와일드카드를 포함할 수 있습니다.
66 User apache
67 Group apache
	이러한 두 개의 지시문은 해당 권한으로 httpd 데몬이 실행되는 사용자 및 그룹을 지정합니다. httpd는 항상 root로 시작되지만 root 권한이 필요한 모든 작업(예: 1024 아래의 포트 번호에 바인 딩)이 수행되면 권한이 삭제되고 권한 없는 사용자로 실행이 계속됩니다. 이것은 보안을 위한 조치 입니다.
86 ServerAdmin root@localhost
	httpd에서 생성하는 일부 오류 페이지는 사용자가 문제를 보고할 수 있는 링크를 포함할 수 있습니 다. 이 지시문을 유효한 이메일 주소로 설정하면 웹 마스터가 사용자에게 보다 쉽게 연락할 수 있습 니다. 이 설정을 기본값인 root@localhost로 두는 것은 권장되지 않습니다.
102 <Directory />
	<Directory> 블록은 지정된 디렉토리 및 모든 하위 디렉토리에 대한 구성 지시문을 설정합니다.
	<Directory> 블록 내의 일반적인 지시문에는 다음이 포함됩니다.
	•AllowOverride None: .htaccess 파일에서 디렉토리별 구성 설정이 확인되지 않습니다. 이 지시
	문을 다른 설정으로 지정하면 성능이 저하될 뿐만 아니라 보안 문제도 발생할 수 있습니다. •Require All Denied: httpd는 이 디렉토리의 콘텐츠를 제공하는 것을 거부하고 클라이언트의
	요청이 있을 때 HTTP/1.1 403 Forbidden 오류를 반환합니다.
	•Require All Granted: 이 디렉토리에 대한 액세스를 허용합니다. 일반 콘텐츠 트리 외부의 디렉
	토리에 대해 이 지시문을 설정하면 보안 문제가 발생할 수 있습니다.
	•Options [[+|-]OPTIONS]...: 디렉토리에 대한 특정 옵션을 설정(또는 해제)합니다. 예를 들어 Indexes 옵션은 디렉토리가 요청되고 해당 디렉토리에 index.html 파일이 없는 경우 디렉토리 목록을 표시합니다.
119 DocumentRoot "/var/www/html"
	이 설정은 httpd가 요청된 파일을 검색할 위치를 결정합니다. 여기에 지정된 디렉토리를 httpd(일 반 사용 권한과 SELinux)에서 읽을 수 있어야 하고 액세스를 허용하기 위해 해당 <Directory> 블록 을 선언해야 합니다.
163 <IfModule dir_module>
	이 블록은 지정된 확장 모듈이 로드되는 경우에만 해당 콘텐츠를 적용합니다. 이 경우 dir_module이 로드되므로 DirectoryIndex 지시문을 사용하여 디렉토리가 요청될 때 사용될 파일 을 지정할 수 있습니다.
171 <Files ".ht*">
	<Files> 블록은 <Directory> 블록처럼 작동하지만 여기서는 개별(와일드카드 적용) 파일에 대한 옵션이 사용됩니다. 이 경우 이 블록은 httpd가 보안에 중요한 파일을 .htaccess 및 .htpasswd처 럼 처리하지 못하게 합니다.
182 ErrorLog "logs/error_log"
	이 설정은 httpd 파일이 발생하는 모든 오류를 로깅할 위치를 지정합니다. 이것은 상대 경로 이름이 므로 앞에 ServerRoot 지시문이 붙습니다. 기본 구성에서 /etc/httpd/logs는 /var/log/httpd/에 대한 심볼릭 링크입니다.
217     CustomLog "logs/access_log" combined
	CustomLog 지시문은 로깅할 파일과 LogFormat 지시문으로 정의되는 로그 형식의 두 매개 변수를 사용합니다. 관리자는 이러한 지시문을 사용하여 필요하거나 원하는 정보를 정확히 로깅할 수 있습 니다. 대부분의 로그 구문 분석 도구는 기본 combined 형식이 사용된다고 간주합니다.
316 AddDefaultCharset UTF-8
	이 설정은 text/plain 및 text/html 리소스의 Content-Type 헤더에 charset 부분을 추가합니다. 이 설정은 AddDefaultCharset Off를 사용하여 비활성화할 수 있습니다
353 IncludeOptional conf.d/*.conf
	이 설정은 일반적인 포함과 동일하게 작동하지만 파일을 찾을 수 없으면 오류가 생성되지 않습니다.
```

```bash
① ServerAdmin/ServerName/UserDir 지시자 설정
# vi /etc/httpd/conf/httpd.conf
..... (중략) .....
#
# ServerAdmin: Your address, where problems with the server should be
# e-mailed.  This address appears on some server-generated pages, such
# as error documents.  e.g. admin@your-domain.com
#
[수정전]
ServerAdmin root@localhost
[수정후]
#---> ServerAdmin root@localhost
ServerAdmin root@linux2XX.example.com         <----- '관리자 이메일 주소 입력'

#
# ServerName gives the name and port that the server uses to identify itself.
# This can often be determined automatically, but we recommend you specify
# it explicitly to prevent problems during startup.
#
# If this is not set to valid DNS name for your host, server-generated
# redirections will not work.  See also the UseCanonicalName directive.
#
# If your host doesn't have a registered DNS name, enter its IP address here.
# You will have to access it by its address anyway, and this will make
# redirections work in a sensible way.
#
[수정전]
#ServerName www.example.com:80
[수정후]
#---> #ServerName www.example.com:80
ServerName www.example.com:80        <----- '서버 이름을 입력'

..... (중략) .....
<IfModule mod_userdir.c>
    #
    # UserDir is disabled by default since it can confirm the presence
    # of a username on the system (depending on home directory
    # permissions).
    #
    [수정전]
    UserDir disable
    [수정후]
#--->    UserDir disable
    #UserDir disable            <----- '주석 처리'
    #
    # To enable requests to /~user/ to serve the user's public_html
    # directory, remove the "UserDir disable" line above, and uncomment
    # the following line instead:
    #
    [수정전]
    #UserDir public_html
    [수정후]
#--->    #UserDir public_html
    UserDir public_html         <----- '주석 제거'

</IfModule>
```

```bash
② 서비스 restart
# service httpd restart
Stopping httpd:                                            [  OK  ]
Starting httpd:                                            [  OK  ]
# chkconfig httpd on 
#

③ 웹 확인
# lynx http://www.example.com 
-> 페이지 확인
-> q
-> y
```

참고사항

```bash
테스트를 진행하지 않음

# /usr/local/apache/conf/extra/httpd-mpm.conf

<IfModule mpm_worker_module>

StartServers 3

MaxClients 150

MinSpareThreads 75

MaxSpareThreads 250

ThreadsPerChild 25

MaxRequestWorkers 400

MaxConnectionsPerChild 0

</IfModule>
```

- .htaccess 파일을 이용한 웹 보안

(4-4) 가상 호스트 설정(Virtual Hosting)

■ Client ----- 작업 요청(**적은 경우**) -----> Machine(WEB1, WEB2, WEB3)

■ Client ----- 작업 요청(많은 경우) -----> WEB(Machine1 Machine2 Machine3)

**Virtual Hosting**

■ 이름 기반 가상 호스트(**Name-based Virtual Hosting**)   <<<< 

■ IP 기반 가상 호스트(**IP-based Virtual Hosting**)

■ 포트 기반 가상 호스트(Port-based Virtual Hosting)

■ 혼합된 형태(Mixed Virtual Hosting)

이름 기반 가상 호스트

DNS에 추가

**[SERVER1]# vi /var/named/server.zone**

```
site1	IN	A	192.168.10.210
```

**[SERVER1]# systemctl restart named-chroot**

**[SERVER2]# nslookup [site1.example.com](http://site1.example.com/)**

```
Server:		192.168.10.200
Address:	192.168.10.200#53

Name:	site1.example.com
Address: 192.168.10.210
```

**[SERVER2]# mkdir -p /srv/site1/www**

**[SERVER2]# cd /etc/httpd/conf.d**

**[SERVER2]# vi /etc/httpd/conf.d/vitual1.conf**

```
<Directory /srv/site1/www>
Require all granted
AllowOverride None
</Directory>

<VirtualHost 192.168.10.210:80>
DocumentRoot /srv/site1/www
ServerName site1.example.com
ServerAdmin webmaster@site1.example.com
ErrorLog "logs/site1_error_log"
CustomLog "logs/site1_access_log" combined
</VirtualHost>
```

**[SERVER2]# echo "site1 web" > /srv/site1/www/index.html**

**[SERVER2]# semanage fcontext -a -t httpd_sys_content_t '/srv/site1/www/(/.*)?'**

**[SERVER2]# restorecon -Rv /srv/**

**[SERVER2]# systemctl restart httpd**

**[SERVER1]# lynx [site1.example.com](http://site1.example.com/)**

- 숨김
- Appendix A. httpd.conf 파일의 해석
- Appendix B. HTTP Status Code and Reason Phrase

SSL 사용

```bash
# vi /etc/httpd/conf.d/vitual1.conf
<Directory /srv/site1/www>
Require all granted
AllowOverride None
</Directory>

<VirtualHost 192.168.10.210:80>
DocumentRoot /srv/site1/www
ServerName site1.example.com
ServerAdmin webmaster@site1.example.com
ErrorLog "logs/site1_error_log"
CustomLog "logs/site1_access_log" combined
</VirtualHost>

<VirtualHost 192.168.10.210:443>
ServerName site1.example.com
**SSLEngine on
SSLCertificateFile /etc/pki/tls/certs/example.com.crt 
SSLCertificateKeyFile /etc/pki/tls/private/example.com.key
SSLCertificateChainFile /etc/pki/tls/private/example.com.csr**
DocumentRoot /srv/site1/www
ServerName site1.example.com
ServerAdmin webmaster@site1.example.com
ErrorLog "logs/site1_error_log"
CustomLog "logs/site1_access_log" combined
</VirtualHost>
```

**[SERVER2]# firewall-cmd --permanent --add-service=https**

**[SERVER2]# firewall-cmd --reload**

**[SERVER2]# systemctl restart httpd**

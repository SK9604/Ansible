init > systemd

과거에는 프로세스(init)였는데 현재는 서비스 형태(systemd)로 구현이 되어있다.

# 단원목표

---

- systemd에 관하여
- service 체계와 systemctl을 사용한 서비스 체계의 차이점
- systemctl 유닛 구성
- systemctl 관리

---

- systemd 서비스 및 소켓 유닛에 의해 시작된 시스템 데몬 및 네트워크 서비스를 나열합니다.
- systemctl을 사용하여 시스템 데몬 및 네트워크 서비스를 제어합니다.

# systemd

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6a5ee3da-15f0-4a45-bb5a-76b6e6b7403e/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6a5ee3da-15f0-4a45-bb5a-76b6e6b7403e/Untitled.png)

시스템 시작 및 서버 프로세스는 systemd 시스템 및 서비스 관리자에 의해 관리됩니다. 이 프로그램은 부팅할 때 및 실행 중인 시스템에서 시스템 리소스, 서버 데몬 및 기타 프로세스를 활성화하는 방법을 제공합니다. **데몬은 다양한 작업을 수행하는 백그라운드에서 대기하거나 실행되는 프로세스입니다**. 관례적으로 대부분의 데몬 프로그램의 이름은 소켓을 사용합니다. 소켓은 데몬을 통해 만들거나 데몬과 분리하여 systemd와 같은 기타 프로세스를 통해 만들 수 있습니다. systemd는 클라이언트에서 연결을 설정하면 해당 소켓을 데몬에 전달합니다.

서비스는 하나 이상의 데몬을 참조할 수 있지만, 대신에 서비스 시작 또는 중지를 통해 시스템 상태 변경을 한 번만 수행할 수 있고(예: 네트워크 인터페이스를 설정하기 위해) 그 후에는 데몬 프로세스가 실행되지 않습니다.

간단한 이력

오랫동안 Linux와 UNIX 시스템의 프로세스 ID 1은 init 프로세스였습니다. 이 프로세스는 시스템의 다른 서비스를 활성화하는 일을 수행했습니다. 자주 사용되는 데몬은 System V 및 LSB(Linux Standard Base) init 스크립트를 사용하여 부팅할 때 시스템에서 시작되었습니다. 덜 자주 사용되는 데몬은 필요할 때마다 inetd 또는 xinetd와 같은 다른 서비스에 의해 시작되었습니다. 이 시스템에는 systemd에 의해설명되는 여러 가지 제약사항들이 있습니다.

Red Hat Enterprise Linux 7에서 프로세스 ID 1은 새 init 시스템인 systemd입니다. systemd가 제공하는 새로운 몇 가지 기능은 다음과 같습니다.

•시스템 부팅 속도를 높이는 병렬화 기능

•별도의 서비스를 요구하지 않고 필요할 때 데몬 시작

•자동 서비스 종속성 관리는 네트워크를 사용할 수 없을 때 네트워크 서비스를 시작하지 않는 것과 같이 긴 타임아웃을 방지합니다.

•Linux 제어 그룹을 사용하여 관련 프로세스를 한꺼번에 추적하는 방법

```bash
init - 스크립트
무조건 순서대로 실행하는 것이 단점이다.
init - DHCP
상당히 불편하다. DHCP가 올라올때까지 기다렸다가 실행하는 것이기 때문에 에러는 아니다.
```

[참고]

systemd에서 쉘 기반 서비스 스크립트는 몇몇 기존 서비스에만 국한되어 사용됩니다. 따라서 /etc/sysconfig에 있는 파일과 같이 쉘 변수를 포함한 구성 파일이 바뀌고 있습니다. 아직 사용되는 파일은 systemd 환경 파일로 포함되며 NAME=VALUE 쌍으로 읽힙니다. 이것은 더이상 쉘 스크립트로 작성되지 않습니다.

## systemctl 및 systemd 유닛

systemctl 명령은 units라는 다양한 유형의 systemd 개체를 관리하는 데 사용됩니다. systemctl -t help를 사용하여 사용 가능한 유닛의 유형 목록은 표시할 수 있습니다.

[중요]

systemctl 옵션을 사용하지 않으면 -l은 유닛 이름, 프로세스 트리 항목 및 유닛 설명을 축약 또는 "줄임말"할 수 있습니다.

일반적인 몇몇 유닛 유형은 아래와 같습니다.

서비스 유닛의 확장자는 .service이며 시스템 서비스를 나타냅니다. 이 유닛 유형은 웹 서버와 같이 자 주 액세스하는 데몬을 시작하는 데 사용됩니다.

•소켓 유닛의 확장자는 .socket이며 IPC(프로세스 내 통신) 소켓을 나타냅니다. 클라이언트 연결이 이루어지면 소켓의 제어가 데몬 또는 새로 시작된 서비스에 전달됩니다. 소켓 유닛은 부팅할 때 서비스 시작을 지연시키고 덜 자주 사용되는 서비스를 필요할 때 시작하는 데 사용됩니다. 이러한 서비스들은 xinetd를 수퍼서버로 활용하여 필요할 때 시작하기 위해 사용하는 서비스와 원칙적으로 유사합니다.

•경로 유닛의 확장자는 .path이며 특정 파일 시스템 변경이 발생할 때까지 서비스 활성화를 지연시키는데 사용됩니다. 이것은 인쇄 시스템과 같은 스풀 디렉토리를 사용하는 서비스에 주로 사용됩니다.

## 서비스 상태

서비스 상태는 systemctl status name.type을 사용하여 볼 수 있습니다. 유닛 유형이 제공되지 않으면 systemctl은 서비스 유닛의 상태(있는 경우)를 표시합니다.

```bash
# systemctl status sshd.service
sshd.service - OpenSSH server daemon
Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled)
Active: active (running) since Thu 2014-02-27 11:51:39 EST; 7h ago
Main PID: 1073 (sshd)
CGroup: /system.slice/sshd.service
└─1073 /usr/sbin/sshd -D
Feb 27 11:51:39 server0.example.com systemd[1]: Started OpenSSH server daemon.
Feb 27 11:51:39 server0.example.com sshd[1073]: Could not load host key: /et...y
Feb 27 11:51:39 server0.example.com sshd[1073]: Server listening on 0.0.0.0 ....
Feb 27 11:51:39 server0.example.com sshd[1073]: Server listening on :: port 22.
Feb 27 11:53:21 server0.example.com sshd[1270]: error: Could not load host k...y
Feb 27 11:53:22 server0.example.com sshd[1270]: Accepted password for root f...2
Hint: Some lines were ellipsized, use -l to show in full.

Active: inactive (dead)
```

서비스 상태를 나타내는 여러 키워드를 상태 출력에서 확인할 수 있습니다.

```bash
키워드: 설명:
로드됨        유닛 구성 파일이 처리되었습니다.
활성(실행 중) 하나 이상의 연속된 프로세스로 실행 중입니다.
활성(종료됨)  1회 구성을 성공적으로 완료했습니다.
활성(대기 중) 실행 중이지만 이벤트를 기다리고 있습니다.
비활성        실행 중이 아닙니다.
활성화        부팅할 때 시작됩니다.
비활성화      부팅할 때 시작되지 않습니다
정적          활성화할 수 없지만 활성화된 유닛에 의해 자동으로 시작될 수도 있습니다.
```

[참고]

```bash
systemctl status NAME 명령은 Red Hat Enterprise Linux의 이전 버전에서 사용된 service NAME status 명령을 대신합니다.
```

### [EX] systemctl로 유닛 파일 나열

```bash
모든 유닛의 상태를 쿼리하여 시스템 시작을 확인합니다.
# systemctl
•서비스 유닛의 상태만 쿼리합니다.
# systemctl --type=service
•실패 또는 유지 보수 상태인 유닛을 조사합니다. 선택적으로 전체 출력을 보려면 -l 옵션을 추가합니다.
# systemctl status rngd.service -l
•특정 유닛이 활성 상태인지 확인하고 그 유닛이 부팅할 때 시작되도록 활성화되는지 표시하기 위해 status 인수를 사용할 수도 있습니다. 대체 명령도 활성 및 활성화 상태를 간편하게 표시할 수 있습니다.
# systemctl is-active sshd
# systemctl is-enabled sshd
•로드된 모든 유닛의 활성 상태를 나열합니다. 선택적으로 유닛의 유형을 제한합니다. --all 옵션은 비활성 유닛을 추가적으로 표시합니다.
# systemctl list-units --type=service
# systemctl list-units --type=service --all
•모든 유닛의 활성화 및 비활성화 설정을 봅니다. 선택적으로 유닛의 유형을 제한합니다.
# systemctl list-unit-files --type=service
•실패한 서비스만 봅니다.
# systemctl --failed --type=service
```

### [EX] systemd 유닛 상태 식별

```bash
시스템의 모든 서비스 유닛을 나열합니다.
# systemctl list-units --type=service
2. 시스템의 활성 및 비활성 소켓 유닛을 모두 나열합니다.
# systemctl list-units --type=socket --all
3. chronyd 서비스의 상태를 확인합니다. 이 서비스는 네트워크 시간 동기화(NTP)에 사용됩니다.
3.1. chronyd 서비스의 상태를 표시합니다. 활성 데몬의 프로세스 ID를 확인합니다.
# systemctl status chronyd
3.2. 나열된 데몬이 실행 중인지 확인합니다.
# ps -p PID
4. sshd 서비스의 상태를 확인합니다. 이 서비스는 안전하게 암호화된 시스템 간 통신에 사용됩니다.
4.1. 시스템을 부팅할 때 sshd 서비스가 활성화되어 시작되는지 확인합니다.
# systemctl is-enabled sshd
4.2. 상태 정보 전체를 표시하지 않고 sshd 서비스가 실행 중인지 확인합니다.
# systemctl is-active sshd
4.3. sshd 서비스의 상태를 표시합니다.
# systemctl status sshd
5. 모든 서비스 유닛의 활성화 또는 비활성화 상태를 나열합니다.
# systemctl list-unit-files --type=service
```

### [EX] 실행 중인 시스템에서 시스템 데몬 시작 및 중지

```bash
시작 중, 중지 중, 재시작 중, 재로드 중 및 확인 중 상태는 서비스를 관리할 때 수행되는 일반적인 작업입니다.
•sshd 서비스의 상태를 확인합니다.
# systemctl status sshd.service
sshd.service - OpenSSH server daemon
Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled)
Active: active (running) since Thu 2014-02-27 11:51:39 EST; 7h ago
Main PID: 1073 (sshd)
CGroup: /system.slice/sshd.service
└─1073 /usr/sbin/sshd -D
•프로세스가 실행 중인지 확인합니다.
# ps -up 1073
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
root 1073 0.1 0.0 82992 3612 ? Ss 15:15 0:00 /usr/sbin/sshd -D
•서비스를 중지하고 상태를 확인합니다.
# systemctl stop sshd.service
# systemctl status sshd.service
sshd.service - OpenSSH server daemon
Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled)
Active: inactive (dead) since Thu 2014-02-27 18:51:39 EST; 2s ago
Main PID: 1073 (code=exited, status=0/SUCCESS)
•서비스를 시작하고 상태를 봅니다. 프로세스 ID가 변경되었습니다.
# systemctl start sshd.service
# systemctl status sshd.service
sshd.service - OpenSSH server daemon
Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled)
Active: active (running) since Thu 2014-02-27 18:52:39 EST; 2s ago
Main PID: 1253 (sshd)
CGroup: /system.slice/sshd.service
└─1253 /usr/sbin/sshd -D
•단일 명령에서 서비스를 중지한 후 시작합니다.
# systemctl restart sshd.service
# systemctl status sshd.service
sshd.service - OpenSSH server daemon
Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled)
Active: active (running) since Thu 2014-02-27 18:54:39 EST; 2s ago
Main PID: 1268 (sshd)
CGroup: /system.slice/sshd.service
└─1268 /usr/sbin/sshd -D
•서비스를 완전히 중지 및 시작하지 않고 구성 파일을 읽고 재로드하기 위한 명령을 시행합니다. 프로세
스 ID는 변경되지 않습니다.
# systemctl reload sshd.service
# systemctl status sshd.service
sshd.service - OpenSSH server daemon
Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled)
Active: active (running) since Thu 2014-02-27 18:55:09 EST; 32s ago
Main PID: 1268 (sshd)
CGroup: /system.slice/sshd.service
└─1268 /usr/sbin/sshd -D
```

## 유닛 종속성

다른 서비스의 종속성으로 서비스가 시작될 수도 있습니다. 소켓 유닛이 활성화되고 동일한 이름의 서비스 유닛은 활성화되지 않은 경우, 네트워크 소켓에 대한 요청이 이루어지면 서비스가 자동으로 시작됩니다. 파일 시스템 조건이 충족되면 경로 유닛에 의해 서비스가 시작될 수도 있습니다.

systemctl list-dependencies UNIT 명령을 사용하여 특정 유닛과 함께 시작되어야 하는 다른 유닛의 트리를 표시할 수 있습니다. 이 명령의 --reverse 옵션은 어떤 유닛이 지정된 유닛을 시작하여 실행되도록 해야 하는지를 보여줍니다.

## 서비스 마스킹

시스템은 방화벽과 같은 특정 기능용으로 설치된 서비스(iptables 및 firewalld)와 충돌할 수 있습니다. 관리자가 의도하지 않게 서비스를 시작하지 못하도록 하기 위해 그 서비스에 마스크를 지정할 수 있습니다. 마스킹은 서비스가 시작된 경우 아무 일도 일어나지 않도록 구성 디렉토리에 링크를 만듭니다.

```bash
# systemctl mask network
ln -s '/dev/null' '/etc/systemd/system/network.service'
# systemctl unmask network
rm '/etc/systemd/system/network.service'
```

비활성화된 서비스는 부팅할 때 또는 다른 유닛 파일에 의해 자동으로 시작되지 않지만 수동으로 시작할 수는 있습니다. 마스킹된 서비스는 수동으로 또는 자동으로 시작할 수 없습니다

# 시스템 데몬을 활성화하여 부팅 시 시작 또는 중지

적절한 systemd 구성 디렉토리에 링크가 생성되는 부팅 시에 서비스가 시작됩니다. 이 링크는 systemctl 명령으로 생성 및 제거됩니다.

```bash

•서비스 상태를 확인합니다.
[root@serverX ~]# systemctl status sshd.service
•서비스를 비활성화하고 상태를 확인합니다. 서비스를 비활성화하면 서비스가 중지되지 않는지 확인합니다.
[root@serverX ~]# systemctl disable sshd.service
[root@serverX ~]# systemctl status sshd.service
•서비스를 활성화하고 상태를 확인합니다.
[root@serverX ~]# systemctl enable sshd.service
[root@serverX ~]# systemctl is-enabled sshd.service
```

# systemctl 명령 요약

실행 중인 시스템에서 서비스를 시작 및 중지하고, 부팅할 때 서비스가 자동으로 시작되도록 활성화 또는 비활성화할 수 있습니다

```bash
명령:                        작업:
systemctl status UNIT       유닛 상태에 대한 세부 정보를 봅니다.
systemctl stop UNIT         실행 중인 시스템에서 서비스를 중지합니다.
systemctl start UNIT        실행 중인 시스템에서 서비스를 시작합니다.
systemctl restart UNIT      실행 중인 시스템에서 서비스를 다시 시작합니다.
systemctl reload UNIT       실행 중인 서비스의 구성 파일을 재로드합니다.
systemctl mask UNIT         수동으로 및 부팅할 때 서비스가 시작되지 않도록 완전히 비활성화합니다.
systemctl unmask UNIT       마스킹된 서비스를 사용 가능하도록 만듭니다.
systemctl enable UNIT       부팅할 때 서비스가 시작되도록 구성합니다.
systemctl disable UNIT      부팅할 때 서비스가 시작되지 않도록 비활성화합니다.
systemctl list-dependencies UNIT 지정된 유닛이 필요로 하며 요구하는 유닛을 나열합니다.
```

키워드: 설명:
로드됨 유닛 구성 파일이 처리되었습니다.
활성(실행 중) 하나 이상의 연속된 프로세스로 실행 중입니다.
활성(종료됨) 1회 구성을 성공적으로 완료했습니다.
활성(대기 중) 실행 중이지만 이벤트를 기다리고 있습니다.
비활성 실행 중이 아닙니다.
활성화 부팅할 때 시작됩니다.
비활성화 부팅할 때 시작되지 않습니다
정적 활성화할 수 없지만 활성화된 유닛에 의해 자동으로 시작될 수도 있습니다.

[EX] systemctl을 사용하여 서비스 관리

```bash
시작하기 전에
serverX 시스템을 재설정합니다.
1. systemctl restart 및 systemctl reload 명령의 결과를 관찰합니다.
1.1. sshd 서비스의 상태를 표시합니다. 데몬의 프로세스 ID를 확인합니다.
$ sudo systemctl status sshd
shd.service - OpenSSH server daemon
Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled)
Active: active (running) since Tue 2014-06-10 09:09:50 EDT; 35min ago
Process: 1061 ExecStartPre=/usr/sbin/sshd-keygen (code=exited, status=0/SUCCESS)
Main PID: 1077 (sshd)
CGroup: /system.slice/sshd.service
└─1077 /usr/sbin/sshd -D
...
1.2. sshd 서비스를 다시 시작하고 상태를 봅니다. 데몬의 프로세스 ID가 변경되었습니다.
$ sudo systemctl restart sshd
$ sudo systemctl status sshd
sshd.service - OpenSSH server daemon
Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled)
Active: active (running) since Tue 2014-06-10 09:48:00 EDT; 1s ago
Process: 2851 ExecStartPre=/usr/sbin/sshd-keygen (code=exited, status=0/SUCCESS)
Main PID: 2852 (sshd)
CGroup: /system.slice/sshd.service
└─2852 /usr/sbin/sshd -D
...
1.3. sshd 서비스를 재로드하고 상태를 봅니다. 데몬의 프로세스 ID가 변경되지 않았으며 연결이 중
단되지 않았습니다.
$ sudo systemctl reload sshd
$ sudo systemctl status sshd
sshd.service - OpenSSH server daemon
Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled)
Active: active (running) since Tue 2014-06-10 09:48:00 EDT; 12s ago
Process: 2860 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
Process: 2851 ExecStartPre=/usr/sbin/sshd-keygen (code=exited, status=0/SUCCESS)
Main PID: 2852 (sshd)
CGroup: /system.slice/sshd.service
└─2852 /usr/sbin/sshd -D
...

chronyd 서비스가 실행 중인지 확인합니다.
$ sudo systemctl stat chronyd
chronyd.service - NTP client/server
Loaded: loaded (/usr/lib/systemd/system/chronyd.service; enabled)
Active: active (running) since Tue 2014-06-10 09:09:44 EDT; 43min ago
Process: 490 ExecStartPost=/usr/libexec/chrony-helper add-dhclient-servers (code=exited, status=0/
SUCCESS)
Process: 450 ExecStart=/usr/sbin/chronyd -u chrony $OPTIONS (code=exited, status=0/SUCCESS)
Main PID: 467 (chronyd)
CGroup: /system.slice/chronyd.service
└─467 /usr/sbin/chronyd -u chrony
...
3. chronyd 서비스를 중지하고 상태를 봅니다.
$ sudo systemctl stop chronyd
$ sudo systemctl status chronyd
chronyd.service - NTP client/server
Loaded: loaded (/usr/lib/systemd/system/chronyd.service; enabled)
Active: inactive (dead) since Tue 2014-06-10 09:53:36 EDT; 4s ago
Process: 490 ExecStartPost=/usr/libexec/chrony-helper add-dhclient-servers (code=exited, status=0/
SUCCESS)
Process: 450 ExecStart=/usr/sbin/chronyd -u chrony $OPTIONS (code=exited, status=0/SUCCESS)
Main PID: 467 (code=exited, status=0/SUCCESS)
...
4. 시스템을 부팅할 때 chronyd 서비스가 활성화되어 시작되는지 확인합니다.
$ sudo systemctl is-enabled chronyd
enabled
5. 시스템을 재부팅합니다.
$ sudo reboot
6. serverX 시스템에 로그인하고 chronyd 서비스의 상태를 확인합니다.
$ sudo systemctl status chronyd
chronyd.service - NTP client/server
Loaded: loaded (/usr/lib/systemd/system/chronyd.service; enabled)
Active: active (running) since Tue 2014-06-10 09:55:22 EDT; 9min ago
Process: 487 ExecStartPost=/usr/libexec/chrony-helper add-dhclient-servers (code=exited, status=0/
SUCCESS)
Process: 451 ExecStart=/usr/sbin/chronyd -u chrony $OPTIONS (code=exited, status=0/SUCCESS)
Main PID: 474 (chronyd)
CGroup: /system.slice/chronyd.service
└─474 /usr/sbin/chronyd -u chrony
...
7. 시스템을 부팅할 때 시작되지 않도록 chronyd 서비스를 비활성화한 다음 서비스의 상태를 봅니다.
$ sudo systemctl disable chronyd
$ sudo systemctl status chronyd
chronyd.service - NTP client/server

Loaded: loaded (/usr/lib/systemd/system/chronyd.service; disabled)
Active: active (running) since Tue 2014-06-10 09:55:22 EDT; 9min ago
~~Main PID: 474 (chronyd)
CGroup: /system.slice/chronyd.service
└─474 /usr/sbin/chronyd -u chrony
...
8. 시스템을 재부팅합니다.
$ sudo reboot
9. serverX 시스템에 다시 로그인하고 chronyd 서비스의 상태를 확인합니다.
$ sudo systemctl status chronyd
chronyd.service - NTP client/server
Loaded: loaded (/usr/lib/systemd/system/chronyd.service; disabled)
Active: inactive (dead)~~
```

# 부팅 프로세스 제어

목표

이 섹션을 마치면 부팅 과정에 영향을 줄 수 있고 systemd 대상을 사용하여 일반적인 부팅 문제를 복구할 수 있습니다.

시스템 대상 선택

systemd 대상은 원하는 상태에 도달하기 위해 시작해야 하는 systemd 유닛 집합입니다. 중요한 대상은다음 표에 나와 있습니다.

```bash
대상                     목적
graphical.target         시스템의 멀티 유저, 그래픽 및 텍스트 기반 로그인 지원
multi-user.target        시스템이 멀티 유저, 텍스트 기반 로그인만 지원
rescue.target sulogin    프롬프트, 기본 시스템 초기화 완료
emergency.target sulogin 프롬프트, initramfs 피벗 완료 및 시스템 루트 마운트/읽기 전용
```

대상이 다른 대상의 일부가 될 수 있습니다. 예를 들어, graphical.target에는 multi-user.target이

포함되어 있으며 이 대상은 basic.target 등에 의존합니다. 이러한 의존성은 다음 명령을 사용하여 볼수 있습니다.

```bash
# systemctl list-dependencies graphical.target | grep target
```

사용 가능한 모든 명령의 개요는 다음 명령으로 볼 수 있습니다

```bash
# systemctl list-units --type=target --all
```

디스크에 설치된 모든 명령의 개요는 다음 명령으로 볼 수 있습니다

```bash
# systemctl list-unit-files --type=target
```

런타임 시 대상 선택

실행 중인 시스템에서 관리자는 systemctl isolate 명령(예: systemctl isolate multiuser.target)을 사용하여 다른 대상으로 전환할 수 있습니다.

모든 대상을 격리할 수 있습니다. 단위 파일에 AllowIsolate=yes가 설정된 모든 대상을 격리 할 수 있습니다. 예를 들어, graphical.target 대상은 격리할 수 있지만 cryptsetup.target 대상은 격리할 수 없습니다.

기본 대상 설정

시스템이 시작되고 initramfs에서 systemd로 컨트롤이 전달되면 systemd가 default.target 대상 활성화를 시도합니다. 일반적으로 default.target 대상은 graphical.target 또는 multiuser.target에 대한 심볼릭 링크(/etc/systemd/system/에서)입니다.

systemctl 도구는 링크를 관리하기 위한 get-default 및 set-default의 두 명령을 제공합니다.

```bash
# systemctl get-default
multi-user.target
# systemctl set-default graphical.target
rm '/etc/systemd/system/default.target'
ln -s '/usr/lib/systemd/system/graphical.target' '/etc/systemd/system/default.target'
# systemctl get-default
graphical.target
```

부팅 시 다른 대상 선택

부팅 시 다른 대상을 선택하려면 부트 로더에서 커널 명령줄에 특수 옵션 systemd.unit==을 추가할 수 있습니다. 예를 들어 시스템을 rescue 쉘로 부팅하려면 대화형 부트 로더 메뉴에서 다음 옵션을 전달합니다

```bash
systemd.unit=rescue.target
```

다른 대상을 선택하는 이 방법을 사용하려면 Red Hat Enterprise Linux 7 시스템에 다음 절차를 사용합니다.

1. 시스템을 (재)부팅합니다.

2. 아무 키를 눌러 부팅 로더 메뉴 카운트다운을 중단합니다.

3. 커서를 시작할 항목으로 이동합니다.

4. e를 눌러 현재 항목을 편집합니다.

5. 커서 키를 linux16으로 시작하는 행으로 이동합니다. 이 행이 커널 명령줄입니다.

6. systemd.unit=desired.target를 추가합니다.

7. Ctrl+x를 눌러 이러한 변경 사항을 적용하여 부팅합니다.

[EX]부팅 대상 선택

```bash
serverX 시스템을 구성하여 기본적으로 multi-user 대상으로 부팅하도록 구성합니다. serverX 시스템을 지금 부팅하지 마십시오. 그럴 경우 그래픽 콘솔을 사용할 수 없습니다.
1.1.
# systemctl set-default multi-user.target
rm '/etc/systemd/system/default.target'
ln -s '/usr/lib/systemd/system/multi-user.target' '/etc/systemd/system/default.target'
2. 이제 multi-user가 새 기본 대상인지 확인합니다.
2.1.
# systemctl get-default
multi-user.target
또는,
# ls -l /etc/systemd/system/default.target
lrwxrwxrwx. 1 root root 41 Mar 10 08:00 /etc/systemd/systemd/default.target -> /usr/lib/systemd/
system/multi-user.target
3. 기본 대상을 다시 graphical 대상으로 설정한 다음 시스템을 재부팅하여 확인합니다. 시스템이 그래픽 콘솔로 돌아오지 않으면 시스템을 재설정합니다.
3.1.
# systemctl set-default graphical.target
3.2.
# systemctl reboot
```

# DNS

도메인을 사용하는 이유: 숫자보다 기억하기가 용이하다. 의미 부여가 가능함.

컴퓨터는 숫자로 대화를 시도

문자 X

문자를 숫자로. IP 체계로 변환 시켜주는 무언가가 필요하다.

이것이 DNS

호스트 → IP

# 단원목표

---

- DNS 개요
- 도메인 관련 용어
- DNS 동작 원리
- DNS 실습
- DNS 보안 및 참고

---

### DNS(Domain Name System) 개요

**■ DNS (Domain Name System)**

DNS는 인터넷 도메인 이름들의 위치를 알아내기 위한 IP 주소로 바꾸어주는 시스템이다. 도메인 이름은 인터넷 주소로서 사람들이 기억하기 쉽고, 의미있게 붙인 이름이지만, 인터넷에서 어떤 컴퓨터를 실제로 찾기 위해서는 숫자 체계로 된 IP 주소[EX:**192.168.10.XX**]가 필요하다.

DNS 서버는 도메인 이름과 이에 대응하는 IP 주소에 관한 데이터베이스를 유지하고 있다가 원하는 컴퓨터에게 제공한다. 예를 들어, 만약 www.terms.co.kr 이라는 도메인 이름을 DNS 서버에게 제공하면, 211.47.67.126 이라는 IP 주소를 알려주는 것이다. 그러나, 도메인이름과 IP 주소를 대응시키는 목록을 중앙에 1개 만을 유지하는 것은 비현실적이고 비효율적이기 때문에, 도메인 이름과 IP 주소 목록은 기관별 체계에 따라 인터넷 도처에 분산되어 있다.

아마도 모든 사용자들이 각자 자신의 인터넷 서비스 공급자(ISP : KT SKT U+ )에게 문의하면, 지리적으로 가까운 곳 어딘가에 자신을 위한 DNS 서버가 존재하고 있다는 것을 확인할 수 있을 것이다.

**■ 네임서버(Name Server)**

네임서버란 , 어떤 이름을 한 형태(www.google.com)에서 다른 형태로 변환(12.54.223.12)시키는 프로그램을 말한다. 예를 들어, 인터넷은 도메인 이름을 IP 주소로 변환하는 도메인 이름 서버, 즉 DNS에 의지하고 있다.

**■ 동적 DNS(DDNS, Dynamic DNS)**

DDNS는 주로 유동 IP 주소를 사용하는 컴퓨터들의 경우에도 DNS 정보를 쉽게 유지할 수 있도록 해주는 방법이다. 일반적으로, 인터넷 서비스 제공사업자는 사용자가 인터넷에 접속해오면 그 시점 현재 사용되지 않는 IP 주소 중 하나를 임의로 골라 할당하게 되는데, 이 주소는 오직 그 사용자가 인터넷에 접속하고 있는 동안에만 독점적으로 제공된다. 이런 방식을 사용하면 각 컴퓨터마다 고정된 IP 주소를 할당하는 방식에 비해 같은 개수의 IP 주소를 가지고도 훨씬 더 많은 수의 컴퓨터를 지원할 수 있게 된다.

그러나 자신의 도메인 이름과 IP 주소를 DNS에 등록해 사용하는 컴퓨터의 경우, 접속할 때마다 자주 IP 주소가 바뀌게 되므로 매우 불편한 일이다. DDNS 서비스 제공자는 사용자 컴퓨터에서 실행되는 특별한 프로그램을 이용, 인터넷 서비스 제공사업자에 의해 IP 주소가 새로이 부여될 때 마다 DNS 데이터베이스를 자동으로 갱신해 준다.

이렇게 하면, 특정 도메인 이름에 대응되는 IP 주소가 자주 바뀌더라도 다른 사용자들이 그 컴퓨터에 접속하기 위해 새로 변경된 IP 주소를 알 필요 없이 전과 같이 도메인 이름을 이용해 쉽게 접속할 수 있게 되는 것이다.

```bash
DNS = 네임서버 - 이름서버
고정 IP - 도메인
유동 IP - 도메인
DNS = 네트워크에서 가장 중요한 서비스 중 하나
의미있는 이름을 IP로 변환해주는 서비스
```

■ 리눅스 서버가 주로 사용되는 서비스 목록:

-> DNS, MAIL, FTP, WEB(WAS), CVS, Cluster Server, ....

■ 일반적인 회사에서 많이 사용되고 있는 서비스 목록:

-> DNS, WEB, MAIL, FTP, DHCP, NTP, DB(Oracle), ....

## 도메인(Domain) 관련 용어

DNS 서버에서 사용하는 도메인에 대한 명확한 용어의 개념을 알아 보자.

URL : "http://**www**.**soldesk.com**" "http://**cafe.daum.net**" "http://**www.yahoo.co.kr**"

**www**	: Hostname

**soldesk.com**	: Domainname

**www.soldesk.com**	: FQDN(**F**ully **Q**ualified **D**omain **N**ame)

```bash
http           protocol
://            여기부터 도메인이다
www.           host
soldesk.com    domainname
```

[참고] 일반적인 Domainname : [www.soldesk.com](http://www.soldesk.com/)

```bash
+----------- soldesk.com ------------+
| [DNS Server]                       |
| IP1 --> www        * (www)         |
| IP2 --> mail                       |
| IP3 --> ftp            * (mail)    |
|                                    |
|                    * (ftp)         |
|                                    |
+------------------------------------+
```

(1). 호스트이름(Host Name)?

인터넷에서 호스트는, 인터넷을 통해 다른 컴퓨터들과 쌍방향 통신이 가능한 컴퓨터를 말한다. 호스트는 특정한 호스트번호를 갖는데, 이는 네트웍 번호와 합해져서, 고유의 IP 주소를 이루게된다. 인터넷 서비스 제공업체를 통한 PPP 사용자의 경우에는, 접속되어있는 동안에만 고유한 IP 주소를 갖게되며, 그 시간동안은 해당 사용자의 컴퓨터도 하나의 호스트가 되는 것이다. 이러한 맥락에서 보면, 호스트란 네트웍의 하나의 노드라고 볼 수도 있다.

(2). 도메인이름(Domain Name)?

인터넷에 연결된 다른 컴퓨터와 통신을 하기 위해서는 컴퓨터가 인터넷에 연결되어 있어야 하고 컴퓨터의 주소를 알고 있어야 한다. 컴퓨터의 주소는 숫자로 표현된 주소와 영문자로 표현된 주소의 2가지가 있다.

203.247.51.32 (IP주소)

숫자로 표현된 주소는 왼쪽 그림과 같이 점으로 구분되어 4단계로 표시되는데, 점으로 구분된 각 숫자에는 0 ∼ 255 까지의 숫자를 사용할 수 있으며, 전세계적으로 중복되지 않도록 사용해야 한다. 숫자로 표현된 이러한 주소를 인터넷 공인 IP 주소라고 한다.

그러나 인터넷 사용자들이 다른 컴퓨터와의 통신을 위해 숫자로 표현된 주소를 사용하게 되면, 주소를 이해하거나 기억하기 어렵다는 단점이 있다. 따라서 숫자로 표현된 주소대신에 영문자로 표현된 주소를 사용할 수 있도록 하였는데, 영문자로 표현된 주소는 우리가 실생활에서 사용하는 영문단어로 구성되어 인터넷 사용자들이 쉽게 기억할 수 있고 편리하게 다른 컴퓨터와 통신할 수 있다.

soldesk.co.kr (도메인주소)

▪ 1 단계: kr

▪ 2 단계: co

▪ 3 단계: soldesk

영문자로 표현된 주소는 왼쪽 그림과 같이 점으로 구분되어 여러 단계로 구성된다. 각 단계는 오른쪽 맨 마지막에서부터 1단계, 2단계, 3단계 등으로 불리며, 전세계적으로 중복 되지 않는 고유한 이름이 부여된다. 이를 인터넷 도메인이라고 하는데, 인터넷 도메인 이름은 인터넷에 연결된 전세계의 어떠한 컴퓨터와도 통신을 가능하게 해준다.

[인터넷 도메인 이름의 부여 원칙]

- 영문자 A~z, 숫자 0~9 또는 하이픈(-)의 조합으로만 표현되며, 영문자의 대, 소문자는 구별하지 않고 같은 것으로 간주한다.
- 첫 글자는 영문자로 시작하여야 하며, 하이픈으로 끝날수 없다 (우리나라에서는 1999년 6월 30일부터 숫자로 시작되는 도메인 이름도 허용되었다. 한글도메인).
- 길이는 각 단계별로 최소 2자에서 최대 63자까지 가능하다.
- 컴마(,), 언더바(_) 등의 기호는 사용할 수 없다.
- 전세계적으로 중복되지 않도록 고유해야 한다 (이미 사용되고 있는 도메인 이름은 쓸 수 없다).

(3). FQDN(Fully Qualified Domain Name)?

FQDN[에프큐디엔]은 시스템을 지칭하는 완전한 이름으로서, 호스트 이름과 그것의 도메인 이름으로 구성된다. 예를 들어, "www"가 호스트 이름이고, "terms.co.kr"이 도메인 이름이라면, FQDN은 "www.terms.co.kr"가 된다. FQDN은 인터넷상의 특정 호스트를 지칭하기 위한 고유한 인터넷 주소를 가져야한다. 인터넷상에 있지 않지만, 전자우편 주소를 위한 이름공간을 공유하는 일부 호스트를 위해서도, 동일한 이름 구조가 사용된다. FQDN을 가지고 있지 않은 호스트는 뱅 경로를 사용하여 지칭되어야한다.

모든 인터넷 컴퓨터들과 대부분의 UUCP 사이트들은 1980년부터 작성된 막후의 많은 양의 소프트웨어 덕분에 이제 FQDN을 해석할 수 있다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a499c599-1b44-4a0d-9e58-5011fe865665/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a499c599-1b44-4a0d-9e58-5011fe865665/Untitled.png)

(4). 인터넷(Internet)?

인터넷은 전세계적인 컴퓨터 네트웍 시스템으로서, 사용자가 어떤 컴퓨터에 있든지 간에 그가 사용권한을 가지고 있다면 그 어떤 다른 컴퓨터에도 접속해서 정보를 얻을 수 있는 "네트웍의 네트웍"이다. 인터넷은 1969년에 미국 정부의 ARPA (Advanced Research Projects Agency)에 의해 태동되었으며, 처음에는 ARPANet으로 알려졌었다. 인터넷의 원래 목표는 한 대학에 있는 연구용 컴퓨터의 사용자가 다른 대학에 있는 연구용 컴퓨터의 사용자와 "대화할 수 있는" 네트웍을 만드는 것이었다. ARPANet 설계의 부산물 중 하나는, 메시지가 한 방향 이상으로 나뉘어 전달되거나 또는 다른 길로 전달될 수 있기 때문에, 적의 군사공격이나 기타 다른 재해로 인해 네트웍의 일부가 파괴된 경우에도 제 기능을 발휘할 수 있다는 것이다.

오늘날 인터넷은 전세계의 수 십억 인구가 액세스할 수 있는 대중 전체를 위한, 협동적이며, 스스로 유지되는 자립 설비이다. 인터넷은 물리적으로 기존의 공중 전화망의 전체 자원의 일부를 활용하고 있으며, 기술적으로는 TCP/IP라고 불리는 일련의 프로토콜들을 사용함으로써 다른 것들과 구별된다. 인터넷 기술에 있어 최근에 나타난 2개의 변화는, 인트라넷과 엑스트라넷이며, 이들 역시 TCP/IP 프로토콜을 사용한다.

많은 인터넷 사용자들을 위하여, 전자우편이 짧은 편지의 처리를 위한 우편서비스를 실용적으로 대체하고 있다. 전자우편은 인터넷에서 가장 널리 사용되는 응용프로그램이다. 사용자는 또한 IRC를 이용하여 다른 컴퓨터의 사용자와 실시간으로 채팅을 할 수 있다. 최근에는 인터넷 전화설비 및 소프트웨어를 이용하여 실시간으로 음성통화까지 가능하게 되었다.

인터넷에서 가장 널리 사용되는 서비스 중의 하나가 월드와이드웹이다. 웹의 가장 두드러진 특성은 즉시 상호 참조를 할 수 있게 해주는 방법인 하이퍼텍스트인데, 대부분의 웹사이트들에서 텍스트 내에 다른 색으로 표시되어 있거나 또는 밑줄로 표시되어 있는 단어나 문장이 바로 그 것이다. 사용자가 이러한 단어나 구절을 선택하면, 이것과 관련 있는 사이트나 페이지로 전환된다. 때로는 이러한 링크는 클릭이 가능하도록 만들어진 이미지(또는 이미지의 일부)에도 숨겨져 있을 수 있다. 마우스의 포인터를 하이퍼텍스트 링크에 갖다대면, 포인터의 모양이 화살표에서 손 모양으로 바뀌는데, 이것은 다른 사이트나 페이지로 전환하기 위해 클릭할 수 있다는 것을 가리킨다.

웹을 사용하면 무수히 많은 량의 정보에 쉽게 액세스할 수 있다. 웹 서핑은 웹 브라우저를 통해 이루어지는데, 유명한 것으로는 넷스케이프 네비게이터와 마이크로소프트의 인터넷익스플로러가 있다. 특정 웹사이트의 모습은 어떤 브라우저를 사용하느냐에 따라 다소 다르게 보일 수도 있다. 또한 최신 버전의 브라우저들은 애니메이션, 가상현실, 소리, 음악파일 등에 있어 이전 버전에 비해 더 많은 특수기능들을 제공한다.

(5). ARPANet (Advanced Research Projects Agency Network)?

아파넷은 인터넷의 기초가 된 네트웍이다. 아파넷은 패킷 스위칭 개념을 이용하여 전용회선으로 서로 연결된 여러 대의 컴퓨터로 구성되었으며, 주로 미 군당국에서 자금을 지원하였다.

아파넷은 이후 1980년대에 들어서면서 새로운 군사용 네트웍인 DDF(Defense Data Network)와 국립과학재단의 후원을 받는 과학 및 학술컴퓨터 네트웍인 NSFNet으로 분리되었다. 1995년에 NSFNet은, 인터넷 백본(vBNS라고 불린다)을 PSINet, UUNET, ANS/AOL, 스프린트,MCI, 및 AGIS-Net99 등과 같은 상용 백본 제공업체의 컨소시움으로 바꾸기 위해, 차례대로 단계적 철수를 시작했다.

## DNS(Domain Name System) 동작 원리

(1). 초기의 도메인 관리

```bash
+-------------Domain-----------------+
|                                    |
|  SERVER -------+------> SERVERA    |
|  HOST.TXT      |                   |
|                +------> SERVERB    |
|                |                   |
|                +------> SERVERC    |
|                |                   |
|                +------> .....      |
|                                    |
+------------------------------------+
 
[Main Server] -------------------> [Domin Server]
  HOST.TXT                           /etc/hosts
(Domain <--> IP)

초기의 도메인 관리
```

(2). 현재의 도메인 관리

BIND는 BSD 기반의 유닉스 시스템을 위해 설계된 DNS 이다. BIND는 서버와 resolver 라이브러리로 구성되어 있다. 네임서버는 클라이언트들이 이름 자원들이나 객체들에 접근하여, 네트웍 내의 다른 객체들과 함께 이러한 정보를 공유할 수 있게 해주는 네트웍 서비스이다. 이것은 사실상, 컴퓨터 네트웍 내의 객체들을 위한 분산 데이터베이스 시스템이다. BIND는 호스트 이름과 주소를 저장하고 검색하는데 사용되기 위한 BSD 네트웍 프로그램(버전 4.3 이상)에 완전히 통합되어 있다.

시스템 관리자는 BIND를 네트웍 호스트들의 file(/etc/hosts) 내에 있는 호스트 테이블 룩업의 대체용으로 사용하도록 시스템을 설정할 수 있다. BSD의 기본 설정은 BIND를 사용하는 것이다.

DNS(Domain Name System), BIND(**B**erkeley **I**nternet **N**ame **D**omain)

- BIND 4.X

- BIND 8.X

- **BIND 9.X**

- BIND 10.X

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4ca7628f-6310-427b-b294-724926a7ef10/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4ca7628f-6310-427b-b294-724926a7ef10/Untitled.png)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c02b815c-b139-4d74-975d-9764480421ef/_2020-03-07__3.35.48.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c02b815c-b139-4d74-975d-9764480421ef/_2020-03-07__3.35.48.png)

```bash
DNS 동작 방식
목적 :  http://www.example.com 으로 접속을 시도 , 현재 해당 도메인에 대한 정보를 전혀 모르는 상태

client 
본인 컴퓨터에서 DNS cache table에서 www.example.com의 정보를 검색
/etc/host.conf > 순서
/etc/hosts > 이 파일에서 먼저 검색
 이 모든 과정에서 검색이후 없으면 DNS SERVER로 검색 요청
/etc/resolv.conf 읽은 이후 nameserver가 처음 들어가는 라인을 검색
해당 라인은 차례대로 총3개까지 인지
resolv.conf에 등록되어 있는 순서대로 도메인 질의

SERVER -> 
방화벽 OPEN  53 *
본인 컴퓨터에서 DNS cache table에서 www.example.com의 정보를 검색
/etc/named.conf 파일 OPEN -
ca 파일을 확인한뒤  Nameless root 도메인으로 www.example.com정보를 요청
Nameless root 도메인은 전체 도메인들 중에 1차 도메인만 관리를 하고 있다. 
모든 정보를 가지고 있는 서버는 아니다. 자신이 가지고 있는 서버팜중에 .com에 대한 정보를 응답한다.

Nameless root 도메인으로 부터 받은 정보를 가지고 .com 서버팜으로  www.example.com에 대한 정보를 재 요청한다.
.com 서버팜은 .com에 대한 모든 목록을 가질수도 있고 어떠한 기준으로 구별지어 다른 서버와의 연동으로 도메인을 관리할수도 있다. 
관리되는 목록중에 example.com 이라는 정보를 찾아 SERVER쪽으로 전송

example.com 네임서버로  www.example.com의 정보를 요청

example.com 네임서버는 www 호스트에 대한 설정을 확인
SERVER	쪽으로 www 호스트에 대한 IP를 응답

client 로 전송하기 전에 서버는 캐시 테이블에 기록
client 는 접속을 하기 전에 캐시 테이블에 기록
```

```bash
------------------------------------------------------
도메인          설  명
------------------------------------------------------
.                 - Nameless Root Domain
.com              - 1차 도메인(국가 도메인 포함)
                    (예) kr, jp, ....
                    (예) .com, .org, ....
.soldesk.com      - 2차 도메인
                    (예) yahoo.com, soldesk.com, daum.net
.yahoo.co.kr      - 3차 도메인
------------------------------------------------------
 
(예) www.yahoo.co.kr
           A    A A
           |    | |
          (a)  (b)(c)
(a) : 3차 도메인
(b) : 2차 도메인
(c) : 1차 도메인
 
            [그림] 도메인 이름 체계
 
 
▪ 수업시에 사용하는 도메인 이름 체계
(예) www.example.com (= www.yahoo.co.kr)
```

```bash
1. DNS를 사용하는 이유는 도메인에서 IP로 변환하기 위한 서비스다.
2. 캐시테이블
	windows는 캐시 테이블이 존재
	리눅스는 캐시 테이블이 기본적으로는 존재하지 않는다.
	특정 서비스를 사용하여 캐시를 생성해야 한다.

http://www.example.com 이라는 웹 서버 존재
여러분의 컴퓨터에서 도메인을 IP로 변환하여 웹서버에 접근 하는 과정

3:30 까지
nsr230@studylab.xyz
```

```bash
사전조건 -
각 라우터는 서로에 대한 라우팅 테이블이 구축 되어 있어야 한다.

13.13.10.2 host에서 DNS[13.13.20.3]를 통하여 13.13.30.3 서버로 통신

1 /etc/resolv.conf 또는 DNS 서버의 설정에 13.13.20.3
웹 브라우저를 통해 www.example.com

1.1 현재 DNS의 IP만 알고 있으며 도메인의 IP를 모르기 때문에 먼저 IP를 획득 하기 위하여 DNS 질의를 한다.
1.2  그러나 arp 테이블에는 아무 내용이 없기 때문에 게이트웨이의 MAC 주소를 먼저 획득 해야 한다.
1.2.1 arp request를 B.C 통신으로 13.13.10.1 IP를 가진 인터페이스를 찾는다. 
1.2.2 arp request를 받은 인터페이스 중에서 13.13.10.1 인터페이스를 제외한 인터페이스들은 해당 프레임을 폐기
1.2.3 13.13.10.1 인터페이스 가진 게이트웨이는 자신을 호출하는 것을 확인하고 자신의 arp 테이블에
.2.3 13.13.10.1 인터페이스 가진 게이트웨이는 자신을 호출하는 것을 확인하고 자신의 arp 테이블에 먼저 등록을 한다.
1.2.4 13.13.10.1 게이트웨이는 호스트의 MAC주소를 알기 때문에 	arp reply를 유니캐스트로 전송한다.
1.2.5 13.13.10.2 host는 13.13.10.1 게이트웨이에서 전송한 arp reply를 확인하고 13.13.10.1 게이트웨이의 MAC 주소를 획득한다.
1.2.5 13.13.10.1 게이트웨이의 MAC 주소를 arp 테이블에 등록한다.
-------HOST가 게이트웨이랑 L2 통신을 하기 위한 사전작업-------------

2. DNS 질의 
2.1 출발지 포트는 랜덤 도착지 포트는 53으로 지정된 UDP 데이터를 생성하여 프레임으로 재생성
2.2 DNS서버로 출발
[각각의 통신 라인에 MAC주소 학습이 없다면 1.2.1 --- 1.2.5의 과정을 반복한다.]
2.3 DNS서버는 13.13.10.2 host가 요청한 www.example.com의 주소를 확인하고 매핑되어 있는 IP 주소를 전송할 준비를 한다.
2.3.1 L7의 DNS에 IP주소를 페이로드로 저장하고 전송할 준비를 끝낸다.
2.4 13.13.10.2 host로 응답 시작
2.5 13.13.10.2 host는 DNS로부터 받은 IP를 캐시 테이블에 등록
-------웹 서버의 IP를 얻는 과정-----
3 WEB서버 통신
3.1 	DNS로 부터 획득한 IP를 가지고 웹서버로 통신 시작
3.1.1 웹은 TCP로 동작을 하기 때문에 http에 대한 요청을 바로 시작 하는 것이 아니라 3way hand shake 동작을 실행한다.
3.1.2 host와 웹서버는 3way hand shake를 통하여 서로에 대한 신뢰관계를 구축 
3.2  호스트는 웹서버로 파일을 요청 [index.html]
3.3 웹서버는 호스트로 부터 받은 요청에 대한 응답으로 index.html파일을 전송
3.4 호스트는 웹서버로 부터 받은 index.html을 웹 브라우저로 출력, 웹브라우저 프로그램의 특정 디렉토리에 캐시로 등록
--웹서버 응답--
```

## DNS 실습 1

### [EX1] /etc/hosts 파일을 사용한 이전 도메인 관리 방식 실습

DNS 개념이 이전되기 이전에는 hosts파일에 도메인 주소와 IP주소를 mapping하여 정보를 제공해왔다. 인터넷 이용자의 증가로 인해 도메인 주소가 늘어나면서 더 이상 hosts파일에 저장 할 수 없는 양이 되었고 이에 따라 Domain Name Server에 질의를 통하여 IP 주소와 도메인 주소의 값을 매핑(Mapping)하였다. DNS 주소를 이용하지 않고 이전에 사용하던 방식의 /etc/hosts 파일을 이용하여 DNS 기능을 대신하여 보자!

```bash
# dnf -y install lynx
① /etc/hosts 파일에 기입할 IP 주소 확인
# nslookup www.naver.com
Server:		168.126.63.1
Address:	168.126.63.1#53

Non-authoritative answer:
www.naver.com	canonical name = www.naver.com.nheos.com.
Name:	www.naver.com.nheos.com
Address: 125.209.222.142
Name:	www.naver.com.nheos.com
Address: 210.89.160.88
-> 정상적으로 요청이 잘된다.

# nslookup www.naver.com
Server:		8.8.8.8
Address:	8.8.8.8#53

Non-authoritative answer:
www.naver.com	canonical name = www.naver.com.nheos.com.
www.naver.com.nheos.com	canonical name = www.naver.com.edgekey.net.
www.naver.com.edgekey.net	canonical name = e6030.a.akamaiedge.net.
Name:	e6030.a.akamaiedge.net
Address: 104.109.244.187
```

```bash
----- DNS Client -----            ----- DNS Server ------              ---- DNS Server -----
http://www.naver.com 
-> /etc/host.conf (/etc/nsswitch.conf)
-> /etc/hosts 
-> DNS(/etc/resolv.conf) ---------> 168.126.63.1(kns.kornet.net) <----->  ns.naver.com

(ㄱ) # cat /etc/host.conf
     order hosts,bind
(ㄴ) # cat /etc/hosts
     ..... (중략) .....
(ㄷ) # cat /etc/resolv.conf
     nameserver 168.126.63.1
===============================================================================================
# cat /etc/host.conf
#multi on
order hosts,bind
# cat /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.10.200  server1.example.com     server1
192.168.10.210  server2.example.com     server2
192.168.10.220  server3.example.com     server3
192.168.10.230  server4.example.com     server4
# cat /etc/resolv.conf 
# Generated by NetworkManager
search example.com
nameserver 8.8.8.8
# vi /etc/resolv.conf
# cat /etc/resolv.conf 
# Generated by NetworkManager
search example.com
#nameserver 8.8.8.8
```

```bash
② /etc/resolv.conf 파일에서 nameserver 삭제
# vi /etc/resolv.conf

[수정전]
search example.com
nameserver 168.126.63.1
[수정후]
search example.com
#nameserver 168.126.63.1        <----- DNS 서버(168.126.63.1:kns.kornet.net)로 설정한 주소를 주석 처리
```

```bash
③ 웹 브라우져에서 확인
# firefox &       /* 브라우져 창에 http://www.naver.com 도메인 주소 입력 */
============================
# lynx www.naver.com
```

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/75bf692c-b686-4135-90ed-fff92fbfe151/_2020-04-07__8.31.24.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/75bf692c-b686-4135-90ed-fff92fbfe151/_2020-04-07__8.31.24.png)

```bash
④ /etc/hosts 파일에 naver 도메인 정의 
# vi /etc/hosts
--------------------------------------------------------------
[수정전]
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.10.200  server1.example.com     server1
192.168.10.252  server2.example.com     server2
[수정후]
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.10.200  server1.example.com     server1
192.168.10.252  server2.example.com     server2
**125.209.222.142 www.naver.com		naver**

================================================================
# cat /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.10.200  server1.example.com     server1
192.168.10.210  server2.example.com     server2
192.168.10.220  server3.example.com     server3
192.168.10.230  server4.example.com     server4
104.109.244.187	www.naver.com		        naver
```

```bash
----- DNS Client -----            ----- DNS Server ------            ---- DNS Server -----
http://www.naver.com 
-> /etc/host.conf 
-> /etc/hosts 
-> DNS(/etc/resolv.conf) ---------> 168.126.63.1(kns.kornet.net) <----->  ns.naver.com

(ㄱ) # cat /etc/host.conf
     order hosts,bind
(ㄴ) # cat /etc/hosts
     125.209.222.142 www.naver.com
(ㄷ) # cat /etc/resolv.conf
     #nameserver 168.126.63.1
```

```bash
⑤ 웹브라우져에서 확인
# firefox & /* 브라우져 창에 http://www.naver.com 도메인 주소 입력 */
```

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/724115c6-0893-4bc1-8d8f-e4db0f21b48f/_2020-04-07__8.28.08.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/724115c6-0893-4bc1-8d8f-e4db0f21b48f/_2020-04-07__8.28.08.png)

```bash
⑥ /etc/hosts 파일에 가상적인 도메인 이름(nodomain.dns.local) 정의
# vi /etc/hosts
--------------------------------------------------------------
[수정전]
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.10.200  server1.example.com     server1
192.168.10.252  server2.example.com     server2
125.209.222.142 www.naver.com           naver

[수정후]
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.10.200  server1.example.com     server1
192.168.10.252  server2.example.com     server2
125.209.222.142 nodomain.dns.local      nodomain  << 변경
--------------------------------------------------------------
```

```bash
nodomain.dns.local 부분에 원하는 다른 도메인명을 적고 다른 도메인으로 접속을 시도해도 된다.
⑦ 웹브라우져에서 확인
# firefox &/* 브라우져 창에 https://nodomain.dns.local 도메인 주소 입력 */
```

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/16a95972-a877-4c59-823a-1be081df7bb5/_2020-04-07__8.33.27.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/16a95972-a877-4c59-823a-1be081df7bb5/_2020-04-07__8.33.27.png)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f439d7b6-dde5-4481-aa60-56d30f8151ee/_2020-04-07__8.33.45.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f439d7b6-dde5-4481-aa60-56d30f8151ee/_2020-04-07__8.33.45.png)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fa533d47-145c-49ec-a10c-f7d2d15c78bf/_2020-04-07__8.34.00.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fa533d47-145c-49ec-a10c-f7d2d15c78bf/_2020-04-07__8.34.00.png)

```bash
(복원) /etc/resolv.conf 파일에 대한 테스트가 끝났다면 파일을 복구 한다.
# cat /etc/resolv.conf
search example.com
nameserver 168.126.63.1
-> nameserver 지시자에 '#' 제거

# vi /etc/hosts
nodomain.dns.local 라인 제거
```

결론

```bash
웹에서 접근할때 필요한건 도메인 주소가 아니라 IP주소이다.

◎ 웹서버에 접근을 할 때 접근이 불가능한 여러가지 경우
	1. 네임서버 설정이 잘못된 경우
	2. host파일에 잘못 등록이 되어 있는데 순서가 host파일을 저 읽어낼 때
	3. 접근하려는 서버의 IP와 실제 DNS에 있는 IP주소가 틀린 경우
```

## DNS 실습 2 (BIND DNS Server 구축)

(DNS Server의 종류)

- Master DNS Server : 해당 도메인을 관리하는 DNS 서버(Primary DNS Server)
- Slave DNS Server : 해당 도메인에 대한 백업 복사(Copy)를 유지하는 DNS 서버(Secondary DNS Server)
- Cache only DNS Server : 캐싱 기능만 갖는 DNS 서버
- Forwarding DNS Server : 포워딩 기능만 갖는 DNS 서버

Slave(또는 Secondary)는 Master(또는 Primary) DNS 서버가 비정상 운행될 때와 부하를 분산시키기 위해 운용하며, 다수가 존재할 수 있다.

보통 도메인을 관리하기 위해서는 Primary, Secondary 서버가 필요하게 되며, Secondary는 원칙적으론 외부 네트워크에 위치시켜 정전 등의 사태로 Primary가 다운되었을 때를 대비한다. 따라서, 도메인을 운영하기 위해서는 최소 2대 (Primary * 1, Secondary * n) 이상의 네임서버가 요구된다. (참고 : 기술적으로 Resolver의 입장에서는 Primary와 Secondary가 구분되지 않기에 Primary 만으로도 운영은 가능하나 권고되진 않는다.)

Cache only server는 도메인에 대한 데이터를 관리하지는 않고, resolving 만을 처리해 준다. 만약, 본사와 지사가 있고 이 회사의 Primary, Secondary Name server가 모두 본사에 위치한다고 할 때, 지사에 위치한 네트워크 유저들은 Local DNS server가 없게 된다. 이럴 경우 도메인 resolving이 요구될 때마다 다른 네트워크(본사)로 접속을 시도하게 되므로 약간의 딜레이가 생기게 되며, 본사 네트워크가 단절 되었을시 지사도 실질적으로 인터넷 사용이 불가능한 단점이 있다. 이럴 때 지사에 Cache only server를 운용하면 효과적으로 문제를 해결할 수 있다. 한번 사용한 주소지에 대해서는 Client(Resolver)요청에 대한 응답을 Cache Server에 남겨두어 재 요청을 하지 않아도 되도록 구성되어 있다. 단, 일정 시간이 지나면 지워지기 때문에 영구보존 되지 않는 정보이다.

```bash
CentOS 7.7 버전에서는 BIND 9.11.4 버전이 설치 되어 있다.

패키지 : bind bind-chroot bind-libs bind-utils
--------------------------------------------
		=========== DNS Server ===========
		named(53)
		/var/named/chroot/etc/named.conf
		/var/named/chroot/etc/named.rfc1912.zones
		DB : /var/named/chroot/var/named 
		==================================
		- Forward Zone File(D==>IP)
		- Reverse Zone File(IP==>D)
		- localhost Zone File(Caching) 
		- hint File(named.ca)
--------------------------------------------
# yum info bind
Loaded plugins: fastestmirror, langpacks
Loading mirror speeds from cached hostfile
 * base: ftp.kaist.ac.kr
 * epel: mirror.xeonbd.com
 * extras: ftp.kaist.ac.kr
 * updates: ftp.kaist.ac.kr
Available Packages
Name        : bind
Arch        : x86_64
Epoch       : 32
Version     : 9.11.4
Release     : 9.P2.el7
Size        : 2.3 M
Repo        : base/7/x86_64
Summary     : The Berkeley Internet Name Domain (BIND) DNS (Domain Name System)
            : server
URL         : http://www.isc.org/products/BIND/
License     : MPLv2.0
Description : BIND (Berkeley Internet Name Domain) is an implementation of the
            : DNS (Domain Name System) protocols. BIND includes a DNS server
            : (named), which resolves host names to IP addresses; a resolver
            : library (routines for applications to use when interfacing with
            : DNS); and tools for verifying that the DNS server is operating
            : properly.

# yum info bind-utils
Loaded plugins: fastestmirror, langpacks
Loading mirror speeds from cached hostfile
 * base: ftp.kaist.ac.kr
 * epel: mirror.xeonbd.com
 * extras: ftp.kaist.ac.kr
 * updates: ftp.kaist.ac.kr
Installed Packages
Name        : bind-utils
Arch        : x86_64
Epoch       : 32
Version     : 9.11.4
Release     : 9.P2.el7
Size        : 584 k
Repo        : installed
From repo   : anaconda
Summary     : Utilities for querying DNS name servers
URL         : http://www.isc.org/products/BIND/
License     : MPLv2.0
Description : Bind-utils contains a collection of utilities for querying DNS
            : (Domain Name System) name servers to find out information about
            : Internet hosts. These tools will provide you with the IP addresses
            : for given host names, as well as other information about
            : registered domains and network addresses.
            : 
            : You should install bind-utils if you need to get information from
            : DNS name servers.
```

### [EX1] DNS 기본 설정 사항 점검

서버의 설정 사항을 확인해 본다.

```bash
① BIND 패키지 설치 유무 확인
bind-libs       /* BIND 프로그램 라이브러리 */
bind-libs-lite  /* DNS 네임서버들에게 질의(Query)하는 명령어 */
bind-utils      /* DNS 쿼리를 위한 유틸리티 모음이 포함되어 있음 */
bind-chroot     /* DNS chroot 구조 */

-> bind 패키지가 설정파일들이 포함된 패키지인데 설치가 되어 있지 않다.
-> 만약 다른 프로그램도 설치가 되어 있지 않다면 설치 해야 한다.
   # yum -y install bind bind-chroot bind-libs bind-utils
② 설정 파일 확인
# ls -F /var/named/
chroot/  data/  dynamic/  named.ca  named.empty  named.localhost  named.loopback  slaves/
# ls -F /var/named/chroot/
dev/  etc/  run/  usr/  var/
# ls -l /var/named/chroot/etc
합계 0
drwxr-x---. 2 root named  6  8월  8  2019 named
drwxr-x---. 3 root named 25  4월  7 21:31 pki
# ls -l /var/named/chroot/var/named/
합계 0

# ls -lR /var/named/
/var/named/:
합계 16K
drwxr-x---. 7 root  named   61  4월  7 21:31 chroot
drwxrwx---. 2 named named    6  8월  8  2019 data
drwxrwx---. 2 named named    6  8월  8  2019 dynamic
-rw-r-----. 1 root  named 2.3K  4월  5  2018 named.ca
-rw-r-----. 1 root  named  152 12월 15  2009 named.empty
-rw-r-----. 1 root  named  152  6월 21  2007 named.localhost
-rw-r-----. 1 root  named  168 12월 15  2009 named.loopback
drwxrwx---. 2 named named    6  8월  8  2019 slaves

/var/named/chroot:
합계 0
drwxr-x---. 2 root named  6  8월  8  2019 dev
drwxr-x---. 4 root named 30  4월  7 21:31 etc
drwxr-x---. 3 root named 19  4월  7 21:31 run
drwxr-xr-x. 3 root root  19  4월  7 21:31 usr
drwxr-x---. 5 root named 52  4월  7 21:31 var

/var/named/chroot/dev:
합계 0

/var/named/chroot/etc:
합계 0
drwxr-x---. 2 root named  6  8월  8  2019 named
drwxr-x---. 3 root named 25  4월  7 21:31 pki

/var/named/chroot/etc/named:
합계 0

/var/named/chroot/etc/pki:
합계 0
drwxr-x---. 2 root named 6  8월  8  2019 dnssec-keys

/var/named/chroot/etc/pki/dnssec-keys:
합계 0

/var/named/chroot/run:
합계 0
drwxr-xr-x. 2 named named 6  8월  8  2019 named

/var/named/chroot/run/named:
합계 0

/var/named/chroot/usr:
합계 0
drwxr-xr-x. 3 root root 18  4월  7 21:31 lib64

/var/named/chroot/usr/lib64:
합계 0
drwxr-xr-x. 2 root root 6  8월  8  2019 bind

/var/named/chroot/usr/lib64/bind:
합계 0

/var/named/chroot/var:
합계 0
drwxrwx---. 2 named named 6  8월  8  2019 log
drwxrwx--T. 2 root  named 6  8월  8  2019 named
lrwxrwxrwx. 1 named named 6  4월  7 21:31 run -> ../run
drwxrwx---. 2 named named 6  8월  8  2019 tmp

/var/named/chroot/var/log:
합계 0

/var/named/chroot/var/named:
합계 0

/var/named/chroot/var/tmp:
합계 0

/var/named/data:
합계 0

/var/named/dynamic:
합계 0

/var/named/slaves:
합계 0

# tree /var/named
/var/named
├── chroot    **<<<<<<<<<<<<<<**
│   ├── dev
│   ├── etc
│   │   ├── named
│   │   └── pki
│   │       └── dnssec-keys
│   ├── run
│   │   └── named
│   ├── usr
│   │   └── lib64
│   │       └── bind
│   └── var
│       ├── log
│       ├── named
│       ├── run -> ../run
│       └── tmp
├── **data       <<<<<<<<<<<<<<**
├── dynamic
├── named.ca   **<<<<<<<<<<<<<<**
├── named.empty   **<<<<<<<<<<<<<<**
├── named.localhost
├── named.loopback
└── slaves     **<<<<<<<<<<<<<<**

19 directories, 4 files

③ DNS 데몬과 포트 확인
# which named
/usr/sbin/named
# named –v
BIND 9.11.4-P2-RedHat-9.11.4-9.P2.el7 (Extended Support Version) <id:7107deb>
# grep -w ^domain /etc/services 
domain          53/tcp                          # name-domain server
domain          53/udp

④ 설치 패키지 확인
# rpm -qa | grep bind
bind-9.11.4-9.P2.el7.x86_64
bind-libs-9.11.4-9.P2.el7.x86_64
bind-libs-lite-9.11.4-9.P2.el7.x86_64
keybinder3-0.3.0-1.el7.x86_64
bind-utils-9.11.4-9.P2.el7.x86_64
rpcbind-0.2.0-48.el7.x86_64
bind-export-libs-9.11.4-9.P2.el7.x86_64
bind-license-9.11.4-9.P2.el7.noarch
bind-chroot-9.11.4-9.P2.el7.x86_64

⑤ 설치된 패키지 중 bind 패키지의 설치된 파일 목록 확인
# rpm -ql bind
/etc/logrotate.d/named
/etc/named
/etc/named.conf
/etc/named.iscdlv.key
/etc/named.rfc1912.zones
/etc/named.root.key
/etc/rndc.conf
/etc/rndc.key
/etc/rwtab.d/named
/etc/sysconfig/named
/run/named
/usr/bin/arpaname
/usr/bin/named-rrchecker
/usr/lib/python2.7/site-packages/isc
/usr/lib/python2.7/site-packages/isc-2.0-py2.7.egg-info
/usr/lib/python2.7/site-packages/isc/__init__.py
/usr/lib/python2.7/site-packages/isc/__init__.pyc
/usr/lib/python2.7/site-packages/isc/__init__.pyo
/usr/lib/python2.7/site-packages/isc/checkds.py
/usr/lib/python2.7/site-packages/isc/checkds.pyc
/usr/lib/python2.7/site-packages/isc/checkds.pyo
/usr/lib/python2.7/site-packages/isc/coverage.py
/usr/lib/python2.7/site-packages/isc/coverage.pyc
/usr/lib/python2.7/site-packages/isc/coverage.pyo
/usr/lib/python2.7/site-packages/isc/dnskey.py
/usr/lib/python2.7/site-packages/isc/dnskey.pyc
/usr/lib/python2.7/site-packages/isc/dnskey.pyo
/usr/lib/python2.7/site-packages/isc/eventlist.py
/usr/lib/python2.7/site-packages/isc/eventlist.pyc
/usr/lib/python2.7/site-packages/isc/eventlist.pyo
/usr/lib/python2.7/site-packages/isc/keydict.py
/usr/lib/python2.7/site-packages/isc/keydict.pyc
/usr/lib/python2.7/site-packages/isc/keydict.pyo
/usr/lib/python2.7/site-packages/isc/keyevent.py
/usr/lib/python2.7/site-packages/isc/keyevent.pyc
/usr/lib/python2.7/site-packages/isc/keyevent.pyo
/usr/lib/python2.7/site-packages/isc/keymgr.py
/usr/lib/python2.7/site-packages/isc/keymgr.pyc
/usr/lib/python2.7/site-packages/isc/keymgr.pyo
/usr/lib/python2.7/site-packages/isc/keyseries.py
/usr/lib/python2.7/site-packages/isc/keyseries.pyc
/usr/lib/python2.7/site-packages/isc/keyseries.pyo
/usr/lib/python2.7/site-packages/isc/keyzone.py
/usr/lib/python2.7/site-packages/isc/keyzone.pyc
/usr/lib/python2.7/site-packages/isc/keyzone.pyo
/usr/lib/python2.7/site-packages/isc/parsetab.py
/usr/lib/python2.7/site-packages/isc/parsetab.pyc
/usr/lib/python2.7/site-packages/isc/parsetab.pyo
/usr/lib/python2.7/site-packages/isc/policy.py
/usr/lib/python2.7/site-packages/isc/policy.pyc
/usr/lib/python2.7/site-packages/isc/policy.pyo
/usr/lib/python2.7/site-packages/isc/rndc.py
/usr/lib/python2.7/site-packages/isc/rndc.pyc
/usr/lib/python2.7/site-packages/isc/rndc.pyo
/usr/lib/python2.7/site-packages/isc/utils.py
/usr/lib/python2.7/site-packages/isc/utils.pyc
/usr/lib/python2.7/site-packages/isc/utils.pyo
/usr/lib/systemd/system/named-setup-rndc.service
/usr/lib/systemd/system/named.service
/usr/lib/tmpfiles.d/named.conf
/usr/lib64/bind
/usr/libexec/generate-rndc-key.sh
/usr/sbin/ddns-confgen
/usr/sbin/dnssec-checkds
/usr/sbin/dnssec-coverage
/usr/sbin/dnssec-dsfromkey
/usr/sbin/dnssec-importkey
/usr/sbin/dnssec-keyfromlabel
/usr/sbin/dnssec-keygen
/usr/sbin/dnssec-keymgr
/usr/sbin/dnssec-revoke
/usr/sbin/dnssec-settime
/usr/sbin/dnssec-signzone
/usr/sbin/dnssec-verify
/usr/sbin/genrandom
/usr/sbin/isc-hmac-fixup
/usr/sbin/lwresd
/usr/sbin/named
/usr/sbin/named-checkconf
/usr/sbin/named-checkzone
/usr/sbin/named-compilezone
/usr/sbin/named-journalprint
/usr/sbin/nsec3hash
/usr/sbin/rndc
/usr/sbin/rndc-confgen
/usr/sbin/tsig-keygen
/usr/share/doc/bind-9.11.4
/usr/share/doc/bind-9.11.4/Bv9ARM.ch01.html
/usr/share/doc/bind-9.11.4/Bv9ARM.ch02.html
/usr/share/doc/bind-9.11.4/Bv9ARM.ch03.html
/usr/share/doc/bind-9.11.4/Bv9ARM.ch04.html
/usr/share/doc/bind-9.11.4/Bv9ARM.ch05.html
/usr/share/doc/bind-9.11.4/Bv9ARM.ch06.html
/usr/share/doc/bind-9.11.4/Bv9ARM.ch07.html
/usr/share/doc/bind-9.11.4/Bv9ARM.ch08.html
/usr/share/doc/bind-9.11.4/Bv9ARM.ch09.html
/usr/share/doc/bind-9.11.4/Bv9ARM.ch10.html
/usr/share/doc/bind-9.11.4/Bv9ARM.ch11.html
/usr/share/doc/bind-9.11.4/Bv9ARM.ch12.html
/usr/share/doc/bind-9.11.4/Bv9ARM.ch13.html
/usr/share/doc/bind-9.11.4/Bv9ARM.html
/usr/share/doc/bind-9.11.4/Bv9ARM.pdf
/usr/share/doc/bind-9.11.4/CHANGES
/usr/share/doc/bind-9.11.4/README
/usr/share/doc/bind-9.11.4/isc-logo.pdf
/usr/share/doc/bind-9.11.4/man.arpaname.html
/usr/share/doc/bind-9.11.4/man.ddns-confgen.html
/usr/share/doc/bind-9.11.4/man.delv.html
/usr/share/doc/bind-9.11.4/man.dig.html
/usr/share/doc/bind-9.11.4/man.dnssec-checkds.html
/usr/share/doc/bind-9.11.4/man.dnssec-coverage.html
/usr/share/doc/bind-9.11.4/man.dnssec-dsfromkey.html
/usr/share/doc/bind-9.11.4/man.dnssec-importkey.html
/usr/share/doc/bind-9.11.4/man.dnssec-keyfromlabel.html
/usr/share/doc/bind-9.11.4/man.dnssec-keygen.html
/usr/share/doc/bind-9.11.4/man.dnssec-keymgr.html
/usr/share/doc/bind-9.11.4/man.dnssec-revoke.html
/usr/share/doc/bind-9.11.4/man.dnssec-settime.html
/usr/share/doc/bind-9.11.4/man.dnssec-signzone.html
/usr/share/doc/bind-9.11.4/man.dnssec-verify.html
/usr/share/doc/bind-9.11.4/man.dnstap-read.html
/usr/share/doc/bind-9.11.4/man.genrandom.html
/usr/share/doc/bind-9.11.4/man.host.html
/usr/share/doc/bind-9.11.4/man.isc-hmac-fixup.html
/usr/share/doc/bind-9.11.4/man.lwresd.html
/usr/share/doc/bind-9.11.4/man.mdig.html
/usr/share/doc/bind-9.11.4/man.named-checkconf.html
/usr/share/doc/bind-9.11.4/man.named-checkzone.html
/usr/share/doc/bind-9.11.4/man.named-journalprint.html
/usr/share/doc/bind-9.11.4/man.named-nzd2nzf.html
/usr/share/doc/bind-9.11.4/man.named-rrchecker.html
/usr/share/doc/bind-9.11.4/man.named.conf.html
/usr/share/doc/bind-9.11.4/man.named.html
/usr/share/doc/bind-9.11.4/man.nsec3hash.html
/usr/share/doc/bind-9.11.4/man.nslookup.html
/usr/share/doc/bind-9.11.4/man.nsupdate.html
/usr/share/doc/bind-9.11.4/man.pkcs11-destroy.html
/usr/share/doc/bind-9.11.4/man.pkcs11-keygen.html
/usr/share/doc/bind-9.11.4/man.pkcs11-list.html
/usr/share/doc/bind-9.11.4/man.pkcs11-tokens.html
/usr/share/doc/bind-9.11.4/man.rndc-confgen.html
/usr/share/doc/bind-9.11.4/man.rndc.conf.html
/usr/share/doc/bind-9.11.4/man.rndc.html
/usr/share/doc/bind-9.11.4/named.conf.default
/usr/share/doc/bind-9.11.4/notes.html
/usr/share/doc/bind-9.11.4/notes.pdf
/usr/share/doc/bind-9.11.4/sample
/usr/share/doc/bind-9.11.4/sample/etc
/usr/share/doc/bind-9.11.4/sample/etc/named.conf
/usr/share/doc/bind-9.11.4/sample/etc/named.rfc1912.zones
/usr/share/doc/bind-9.11.4/sample/var
/usr/share/doc/bind-9.11.4/sample/var/named
/usr/share/doc/bind-9.11.4/sample/var/named/data
/usr/share/doc/bind-9.11.4/sample/var/named/my.external.zone.db
/usr/share/doc/bind-9.11.4/sample/var/named/my.internal.zone.db
/usr/share/doc/bind-9.11.4/sample/var/named/named.ca
/usr/share/doc/bind-9.11.4/sample/var/named/named.empty
/usr/share/doc/bind-9.11.4/sample/var/named/named.localhost
/usr/share/doc/bind-9.11.4/sample/var/named/named.loopback
/usr/share/doc/bind-9.11.4/sample/var/named/slaves
/usr/share/doc/bind-9.11.4/sample/var/named/slaves/my.ddns.internal.zone.db
/usr/share/doc/bind-9.11.4/sample/var/named/slaves/my.slave.internal.zone.db
/usr/share/man/man1/arpaname.1.gz
/usr/share/man/man1/named-rrchecker.1.gz
/usr/share/man/man5/named.conf.5.gz
/usr/share/man/man5/rndc.conf.5.gz
/usr/share/man/man8/ddns-confgen.8.gz
/usr/share/man/man8/dnssec-checkds.8.gz
/usr/share/man/man8/dnssec-coverage.8.gz
/usr/share/man/man8/dnssec-dsfromkey.8.gz
/usr/share/man/man8/dnssec-importkey.8.gz
/usr/share/man/man8/dnssec-keyfromlabel.8.gz
/usr/share/man/man8/dnssec-keygen.8.gz
/usr/share/man/man8/dnssec-keymgr.8.gz
/usr/share/man/man8/dnssec-revoke.8.gz
/usr/share/man/man8/dnssec-settime.8.gz
/usr/share/man/man8/dnssec-signzone.8.gz
/usr/share/man/man8/dnssec-verify.8.gz
/usr/share/man/man8/genrandom.8.gz
/usr/share/man/man8/isc-hmac-fixup.8.gz
/usr/share/man/man8/lwresd.8.gz
/usr/share/man/man8/named-checkconf.8.gz
/usr/share/man/man8/named-checkzone.8.gz
/usr/share/man/man8/named-compilezone.8.gz
/usr/share/man/man8/named-journalprint.8.gz
/usr/share/man/man8/named.8.gz
/usr/share/man/man8/nsec3hash.8.gz
/usr/share/man/man8/rndc-confgen.8.gz
/usr/share/man/man8/rndc.8.gz
/usr/share/man/man8/tsig-keygen.8.gz
/var/log/named.log
/var/named
/var/named/data
/var/named/dynamic
/var/named/named.ca
/var/named/named.empty
/var/named/named.localhost
/var/named/named.loopback
/var/named/slaves

# ls -l /etc/named*
-rw-r--r--. 1 root root   621  8월  8  2019 /etc/named-chroot.files
-rw-r-----. 1 root named 1.8K  8월  8  2019 /etc/named.conf
-rw-r--r--. 1 root named 3.9K  8월  8  2019 /etc/named.iscdlv.key
-rw-r-----. 1 root named  931  6월 21  2007 /etc/named.rfc1912.zones
-rw-r--r--. 1 root named 1.9K  4월 13  2017 /etc/named.root.key

/etc/named:
합계 0

④ named 데몬 start (DNS 서비스 start)
# systemctl start named
# systemctl status named
● named.service - Berkeley Internet Name Domain (DNS)
   Loaded: loaded (/usr/lib/systemd/system/named.service; disabled; vendor preset: disabled)
   Active: active (running) since 화 2020-04-07 21:44:07 KST; 10s ago
  Process: 2422 ExecStart=/usr/sbin/named -u named -c ${NAMEDCONF} $OPTIONS (code=exited, status=0/SUCCESS)
  Process: 2419 ExecStartPre=/bin/bash -c if [ ! "$DISABLE_ZONE_CHECKING" == "yes" ]; then /usr/sbin/named-checkconf -z "$NAMEDCONF"; else echo "Checking of zone files is disabled"; fi (code=exited, status=0/SUCCESS)
 Main PID: 2424 (named)
    Tasks: 5
   CGroup: /system.slice/named.service
           └─2424 /usr/sbin/named -u named -c /etc/named.conf

 4월 07 21:44:07 server1.example.com named[2424]: network unreachable resolving './DNSKEY/IN': 2001:500:2::c#53
 4월 07 21:44:07 server1.example.com named[2424]: network unreachable resolving './NS/IN': 2001:500:2::c#53
 4월 07 21:44:07 server1.example.com named[2424]: network unreachable resolving './DNSKEY/IN': 2001:503:c27::2:30#53
 4월 07 21:44:07 server1.example.com named[2424]: network unreachable resolving './NS/IN': 2001:503:c27::2:30#53
 4월 07 21:44:07 server1.example.com named[2424]: network unreachable resolving './DNSKEY/IN': 2001:dc3::35#53
 4월 07 21:44:07 server1.example.com named[2424]: network unreachable resolving './NS/IN': 2001:dc3::35#53
 4월 07 21:44:08 server1.example.com named[2424]: network unreachable resolving './DNSKEY/IN': 2001:500:2f::f#53
 4월 07 21:44:08 server1.example.com named[2424]: network unreachable resolving './DNSKEY/IN': 2001:500:2d::d#53
 4월 07 21:44:08 server1.example.com named[2424]: managed-keys-zone: Key 20326 for zone . acceptance timer complete: key now trusted
 4월 07 21:44:08 server1.example.com named[2424]: resolver priming query complete
# systemctl enable named
Created symlink from /etc/systemd/system/multi-user.target.wants/named.service to /usr/lib/systemd/system/named.service.
# systemctl is-enabled named
enabled

```

```bash
[참고] /etc/host.conf 파일에 대해서

로컬영역으로 resolving 할지 네임서버로 resolving 할지 순서 지정
# vi /etc/host.conf
order hosts,bind
-> 실습에서는 "order hosts,bind" 정도만 사용한다.

(/etc/host.conf 파일의 다른예)
order hosts,bind /* /etc/hosts파일로 resolving 할지 네임서버로 resolving 할지 순서를 정함 */
multi off /* hosts파일에서 하나의 호스트가 여러 개의 ip를 가질 수 있는지 없는지 정함 */
nospoof on /* 호스트 이름과 ip가 일치 할 때 호스트 이름을 resolving시켜 줌 */
spoofalert on /* 스푸핑(spoofing) 시도를 로그 기록 할 것인지 결정 */

(www.daum.net에 대한 IP 정보를 얻는 과정)
/etc/host.conf
order hosts, bind   :   ①hosts(/etc/hosts) -> ②bind(DNS Server)

http://www.daum.net --------> Local Server
                             ① /etc/hosts
                             ② DNS Server --------> DNS Server
                                    /etc/resolv.conf
(ㄱ) http://www.daum.net 에 대한 IP 정보를 얻기 위해서
(ㄴ) 로컬서버(Local Server)에 /etc/hosts 파일에 www.daum.net에 대한 IP가 존재하는지 확인하여 존재하면
     사용하고, 존재하지 않으면 
(ㄷ) DNS 서버에게 정보를 요청한다. 이때 정보를 요청할 DNS 서버의 IP는 /etc/resolv.conf 파일을 참조하여 
     www.daum.net에 대한 IP 요청을 하게 된다.
```

### [EX2] DNS 서버 구축

```bash
(DNS 설정 파일)

■ /etc/named.conf                             DNS Configuration File
■ /etc/named.rfc1912.zones                    DNS Configuration File

■ /var/named/server.zone                      DNS Forward Lookup Zone File(Domain -> IP)
■ /var/named/chroot/var/named/server.zone     DNS Forward Lookup Zone File(Domain -> IP)
■ /var/named/server.rev                       DNS Reverse Loookup Zone File(IP -> Domain)
■ /var/named/chroot/var/named/server.rev      DNS Reverse Loookup Zone File(IP -> Domain) 

■ /var/named/named.local                      DNS Localhost Forward Lookup Zone File
■ /var/named/named.zero                       DNS Localhost Reverse Lookup Zone File
■ /var/named/chroot/var/named/named.local     DNS Localhost Forward Lookup Zone File
■ /var/named/chroot/var/named/named.zero      DNS Localhost Reverse Lookup Zone File

■ /var/named/named.ca                         DNS Root Domain Lookup File(Hit File)

■ /etc/host.conf                              Name Service Switching Configuration File

■ /etc/resolv.conf                            DNS Client Resolver File
```

```bash
실습시에는 다음과 같은 파일을 설정한다.
■ /var/named/chroot/etc/named.conf                      /* 주설정파일 */
■ /var/named/chroot/etc/named.rfc1912.zones             /* 주설정파일 */ 
■ /var/named/chroot/var/named/named.ca                  /* 힌트 파일 */
■ /var/named/chroot/var/named/server.zone              /* 포워드 존파일 */
■ /var/named/chroot/var/named/server.rev               /* 리버스 존파일 */ 
```

```bash
① 주설정 파일 설정
# vi /etc/named.conf
//
// named.conf
//
// Provided by Red Hat bind package to configure the ISC BIND named(8) DNS
// server as a caching only nameserver (as a localhost DNS resolver only).
//
// See /usr/share/doc/bind*/sample/ for example named configuration files.
//
// See the BIND Administrator is Reference Manual (ARM) for details about the
// configuration located in /usr/share/doc/bind-{version}/Bv9ARM.html

options {
	listen-on port 53 { any; };      <----- '127.0.0.1' 부분을 'any'로 변경
  listen-on-v6 port 53 { none; };  <----- IPv6는 사용하지 않음
	directory 	"/var/named";
	dump-file 	"/var/named/data/cache_dump.db";
	statistics-file "/var/named/data/named_stats.txt";
	memstatistics-file "/var/named/data/named_mem_stats.txt";
	recursing-file  "/var/named/data/named.recursing";
	secroots-file   "/var/named/data/named.secroots";
	allow-query     { localhost; };  <----- 'localhost' 부분을 'any'로 변경
  allow-transfer  { localhost; };  <----- 해당 라인 추가 **(실습에서는 하지 않음)**

	/* 
	 - If you are building an AUTHORITATIVE DNS server, do NOT enable recursion.
	 - If you are building a RECURSIVE (caching) DNS server, you need to enable 
	   recursion. 
	 - If your recursive DNS server has a public IP address, you MUST enable access 
	   control to limit queries to your legitimate users. Failing to do so will
	   cause your server to become part of large scale DNS amplification 
	   attacks. Implementing BCP38 within your network would greatly
	   reduce such attack surface 
	*/
	recursion yes;

	dnssec-enable yes;
	dnssec-validation yes;

	/* Path to ISC DLV key */
	bindkeys-file "/etc/named.root.key";

	managed-keys-directory "/var/named/dynamic";

	pid-file "/run/named/named.pid";
	session-keyfile "/run/named/session.key";
};

logging {
        channel default_debug {
                file "data/named.run";
                severity dynamic;
        };
};

zone "." IN {
	type hint;
	file "named.ca";
};

include "/etc/named.rfc1912.zones";
include "/etc/named.root.key";

존(ZONE) 파일? DNS에서의 정보 파일
존(ZONE) 파일안에서의 주석 처리 
		(ㄱ) ;         -> Window에서 사용하는 주석
		(ㄴ) #         -> Unix/Linux에서 사용하는 주석
		(ㄷ) /*   */   -> C 주석
		(ㄹ) //        -> C++ 주석
"directory  "/var/named"" -> Zone 파일들이 위치할 디렉토리 지정(예) /var/named/exampleXXX.zone ----> /var/named/chroot/var/named/exampleXXX.zone     /var/named/exampleXXX.rev  ----> /var/named/chroot/var/named/exampleXXX.rev
"include "/etc/named.rfc1912.zones"" -> 포함시킬 설정 파일 지정/etc/named.rfc1912.zones 파일에 들어 있는 내용은 /etc/named.caching-nameserver.conf 파일에 존재하는 것이라고 생각하면 된다.

```

```bash
② 주 설정 파일 설정
# vi /etc/named.rfc1912.zones
// named.rfc1912.zones:
//
// Provided by Red Hat caching-nameserver package 
//
// ISC BIND named zone configuration for zones recommended by
// RFC 1912 section 4.1 : localhost TLDs and address zones
// and http://www.ietf.org/internet-drafts/draft-ietf-dnsop-default-local-zones-02.txt
// (c)2007 R W Franks
// 
// See /usr/share/doc/bind*/sample/ for example named configuration files.
//

zone "localhost.localdomain" IN {
	type master;
	file "named.localhost";
	allow-update { none; };
};

zone "localhost" IN {
	type master;
	file "named.localhost";
	allow-update { none; };
};

zone "1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa" IN {
	type master;
	file "named.loopback";
	allow-update { none; };
};

zone "1.0.0.127.in-addr.arpa" IN {
	type master;
	file "named.loopback";
	allow-update { none; };
};

zone "0.in-addr.arpa" IN {
	type master;
	file "named.empty";
	allow-update { none; };
};

zone "example.com" IN {  /* Forward Zone */
        type master;
        file "server.zone";  /* Forward Zone File : /var/named/server.zone */
};

zone "10.168.192.in-addr.arpa"  IN {  /* Reverse Zone */
         type master;
         file "server.rev";  /* Reverse Zone File : /var/named/exampleXXX.rev */
};
```

```bash
# named-checkconf /etc/named.conf 
# named-checkconf /etc/named.rfc1912.zones 
#
-> namedcheckconf 명령어는 주설정 파일(/etc/named.rfc1912.zones)의 문법 점검 하는 명령어이다.
-> "# named-checkconf <주설정파일의이름>"
-> 아무런 메세지가 없으면 정상적으로 설정된것이다.
```

```bash
③ 힌트(Hint) 파일 생성
# cd /var/named 
# mv named.ca named.ca.old 
# vi named.ca
.                       86400   IN      NS      ns1.example.com.
ns1.example.com.        86400   IN      A       192.168.10.200
-> 기존의 힌트파일(EX: named.ca)은 백업을 받고 새로운 파일를 만든다. 
-> DNS을 chroot로 구성하여 동작시키는 경우에는 힌트파일의 소유자는 named로 되어 있어야 한다.

# ls -l named.ca
-rw-r--r--. 1 root root 128  4월  7 22:09 named.ca

실습을 위해 그냥 두고 진행한다.
```

```bash
④ 포워드 존(Forward-Zone) 파일 생성
# cd /var/named
# cp named.empty server.zone
# vi server.zone
[수정전]
$TTL 3H
@       IN SOA  @ rname.invalid. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
        NS      @
        A       127.0.0.1
        AAAA    ::1
[수정후]
$TTL **4**
@       IN SOA  **ns1.example.com. root.example.com.** (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
        NS      @
        A       127.0.0.1
        AAAA    ::1
        **IN      NS      ns1
ns1     IN      A       192.168.10.200**
```

```bash
# named-checkzone example.com server.zone 
zone example.com/IN: loaded serial 0
OK
```

```bash
-> 'OK' 라고 나오면 정상적으로 설정된것이다.
-> "named-checkzone <Domain Name> <Zone File>"

--------------------------------------------------
Zone 파일에 정의 하는 라인 형식
[Domain]  [TTL]  CLASS  RecordType  Data

(a) [Domain]     example.com.    = @    = 
(b) [TTL] 우선순위 - 
직접 지정된 경우(EX: ns1   5  IN A 172.16.9.XXX) -> 네임서버가 하나가 아닌 여러개로 분산되어 잇는 경우에는 A 레코드에 우선순위를 부여하여 먼저 질의를 해줄 서버를 설정한다.
- $TTL 지정된 경우(EX: $TTL 4)
- SOA Record Type 부분의 TTL 필드로 지정된 경우
(c) CLASS    IN (Internet)
(d) RecordType    "[EX3] 도메인 등록" 실습 부분 참조
(e) Data    "[EX3] 도메인 등록" 실습 부분 참조
--------------------------------------------------

ZONE 파일 레코드
- Serial
2차 네임서버가 Zone 파일의 수정여부를 알 수 있도록 하기 위한 옵션입니다.
1차 네임서버와 2차 네임서버를 운영중 일때 1차 네임서버의 Zone 파일의 내용이 변경 되면 반드시 Serial 를 증가 시켜줘야 2차 네임서버가 자신의 현재 Serial 를 비교하여 값이 작다면 Zone 파일의 정보를 갱신을 하게 됩니다. 2차 네임서버를 사용하지 않는다면 Serial 은 의미가 없습니다.

- Refresh
1차 네임서버의 Zone 파일 수정 여부를 2차 네임서버가 검사를 하기위한 옵션입니다.
Zone 파일의 정보 변경이 잦을 경우 이 주기를 10800(3H)이하로 맞추어주는 것이 효과적이며 일반적으로는 43200(12H)정도가 적당합니다.

- Retry
2차 네임서버에서 1차 네임서버로 연결이 되지 않을 경우 재접속을 요구하는 옵션입니다.
Refresh 보다 적어야만 의미가 있기 때문에 주의를 요합니다.

- Expire
Secondary가 Expire에서 지정한 시간동안 primay에 연결하지 못 할 경우, 해당 도메인이 유효하지 않다고 보고, 해당 도메인에 대한 정보를 전송하지 않는 것 입니다.
이 값은 너무 낮게 설정하지 않는 것이 좋습니다.

- Minimum
제 3의 네임서버.. 즉, 다른 네임서버가 본 서버의 Zone 파일의 정보를 가지고 갔을 경우 그 정보에 대해 캐쉬에 살아있는 시간을 설정하는 것입니다. TTL(Time To Live )값이 명시되지 않은 레코드는 본 값을 기본으로 갖게되며 특정 레코드가 변경이 되었을 때, 이것이 다른 네임서버로 정보가 전달되어 업데이트가 되는 주기는 Minimum의 값을 기본으로 합니다. 일반적으로 10800(3H)가 적당합니다.
```

```bash
⑤ 리버스 존(Reverse-Zone) 파일 생성
# cp named.empty server.rev
# vi server.rev
[수정전]
$TTL    86400
@       IN      SOA     localhost. root.localhost.  (
                                      1997022700 ; Serial
                                      28800      ; Refresh
                                      14400      ; Retry
                                      3600000    ; Expire
                                      86400 )    ; Minimum
        IN      NS      localhost.
1       IN      PTR     localhost.
[수정후]
$TTL 4
@       IN SOA  **ns1.example.com. root.example.com.**  (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
        NS      @
        A       127.0.0.1
        AAAA    ::1
        **IN      NS      ns1.example.com.
200     IN      PTR     ns1.example.com.**
```

```bash
# named-checkzone 10.168.192.in-addr.arpa server.rev
zone 10.168.192.in-addr.arpa/IN: loaded serial 0
OK
-> "# named-checkzone <Domain> <Zone File>"
-> 'OK' 라고 나오면 정상적으로 설정된것이다.
```

```bash
⑥ bind 실행 및 확인하기
# systemctl restart named
# systemctl status named
● named.service - Berkeley Internet Name Domain (DNS)
   Loaded: loaded (/usr/lib/systemd/system/named.service; enabled; vendor preset: disabled)
   Active: active (running) since 화 2020-04-07 22:38:11 KST; 7s ago
  Process: 54078 ExecStop=/bin/sh -c /usr/sbin/rndc stop > /dev/null 2>&1 || /bin/kill -TERM $MAINPID (code=exited, status=0/SUCCESS)
  Process: 54095 ExecStart=/usr/sbin/named -u named -c ${NAMEDCONF} $OPTIONS (code=exited, status=0/SUCCESS)
  Process: 54091 ExecStartPre=/bin/bash -c if [ ! "$DISABLE_ZONE_CHECKING" == "yes" ]; then /usr/sbin/named-checkconf -z "$NAMEDCONF"; else echo "Checking of zone files is disabled"; fi (code=exited, status=0/SUCCESS)
 Main PID: 54096 (named)
    Tasks: 5
   CGroup: /system.slice/named.service
           └─54096 /usr/sbin/named -u named -c /etc/named.conf

 4월 07 22:38:10 server1.example.com named[54096]: **zone example.com/IN: loading from master file server.zone failed: permission denied**
 4월 07 22:38:10 server1.example.com named[54096]: **zone example.com/IN: not loaded due to errors.**
 4월 07 22:38:10 server1.example.com named[54096]: zone 1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa/IN: loaded serial 0
 4월 07 22:38:10 server1.example.com named[54096]: **zone 10.168.192.in-addr.arpa/IN: loading from master file server.rev failed: permission denied**
 4월 07 22:38:10 server1.example.com named[54096]: **zone 10.168.192.in-addr.arpa/IN: not loaded due to errors.**
 4월 07 22:38:10 server1.example.com named[54096]: all zones loaded
 4월 07 22:38:10 server1.example.com named[54096]: running
 4월 07 22:38:11 server1.example.com named[54096]: managed-keys-zone: Unable to fetch DNSKEY set '.': failure
 4월 07 22:38:11 server1.example.com systemd[1]: Started Berkeley Internet Name Domain (DNS).
 4월 07 22:38:11 server1.example.com named[54096]: resolver priming query complet

# ls -l
합계 28K
drwxr-x---. 7 root  named   61  4월  7 21:31 chroot
drwxrwx---. 2 named named   23  4월  7 21:44 data
drwxrwx---. 2 named named   60  4월  7 22:38 dynamic
-rw-r--r--. 1 root  root   128  4월  7 22:09 named.ca
-rw-r-----. 1 root  named 2.3K  4월  5  2018 named.ca.old
-rw-r-----. 1 root  named  152 12월 15  2009 named.empty
-rw-r-----. 1 root  named  152  6월 21  2007 named.localhost
-rw-r-----. 1 root  named  168 12월 15  2009 named.loopback
**-rw-r-----. 1 root  root   222  4월  7 22:37 server.rev
-rw-r-----. 1 root  root   204  4월  7 22:20 server.zone**
drwxrwx---. 2 named named    6  8월  8  2019 slaves

# chown root:named server.zone 
# chown root:named server.rev 
# ls -l
합계 28K
drwxr-x---. 7 root  named   61  4월  7 21:31 chroot
drwxrwx---. 2 named named   23  4월  7 21:44 data
drwxrwx---. 2 named named   60  4월  7 22:38 dynamic
-rw-r--r--. 1 root  root   128  4월  7 22:09 named.ca
-rw-r-----. 1 root  named 2.3K  4월  5  2018 named.ca.old
-rw-r-----. 1 root  named  152 12월 15  2009 named.empty
-rw-r-----. 1 root  named  152  6월 21  2007 named.localhost
-rw-r-----. 1 root  named  168 12월 15  2009 named.loopback
**-rw-r-----. 1 root  named  222  4월  7 22:37 server.rev
-rw-r-----. 1 root  named  204  4월  7 22:20 server.zone**
drwxrwx---. 2 named named    6  8월  8  2019 slaves

# systemctl restart named
# systemctl status named
● named.service - Berkeley Internet Name Domain (DNS)
   Loaded: loaded (/usr/lib/systemd/system/named.service; enabled; vendor preset: disabled)
   Active: active (running) since 화 2020-04-07 22:40:39 KST; 4s ago
  Process: 54157 ExecStop=/bin/sh -c /usr/sbin/rndc stop > /dev/null 2>&1 || /bin/kill -TERM $MAINPID (code=exited, status=0/SUCCESS)
  Process: 54170 ExecStart=/usr/sbin/named -u named -c ${NAMEDCONF} $OPTIONS (code=exited, status=0/SUCCESS)
  Process: 54168 ExecStartPre=/bin/bash -c if [ ! "$DISABLE_ZONE_CHECKING" == "yes" ]; then /usr/sbin/named-checkconf -z "$NAMEDCONF"; else echo "Checking of zone files is disabled"; fi (code=exited, status=0/SUCCESS)
 Main PID: 54172 (named)
    Tasks: 5
   CGroup: /system.slice/named.service
           └─54172 /usr/sbin/named -u named -c /etc/named.conf

 4월 07 22:40:39 server1.example.com named[54172]: zone 10.168.192.in-addr.arpa/IN: loaded serial 0
 4월 07 22:40:39 server1.example.com named[54172]: zone 1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa/IN: loaded serial 0
 4월 07 22:40:39 server1.example.com named[54172]: zone localhost/IN: loaded serial 0
 4월 07 22:40:39 server1.example.com named[54172]: zone example.com/IN: loaded serial 0
 4월 07 22:40:39 server1.example.com named[54172]: all zones loaded
 4월 07 22:40:39 server1.example.com named[54172]: running
 4월 07 22:40:39 server1.example.com named[54172]: zone 10.168.192.in-addr.arpa/IN: sending notifies (serial 0)
 4월 07 22:40:39 server1.example.com systemd[1]: Started Berkeley Internet Name Domain (DNS).
 4월 07 22:40:39 server1.example.com named[54172]: zone example.com/IN: sending notifies (serial 0)
 4월 07 22:40:39 server1.example.com named[54172]: managed-keys-zone: Unable to fetch DNSKEY set '.': failure

# chown root:named named.ca
# ls -l 
합계 28K
drwxr-x---. 7 root  named   61  4월  7 21:31 chroot
drwxrwx---. 2 named named   23  4월  7 21:44 data
drwxrwx---. 2 named named   60  4월  7 22:41 dynamic
**-rw-r--r--. 1 root  named  128  4월  7 22:09 named.ca**
-rw-r-----. 1 root  named 2.3K  4월  5  2018 named.ca.old
-rw-r-----. 1 root  named  152 12월 15  2009 named.empty
-rw-r-----. 1 root  named  152  6월 21  2007 named.localhost
-rw-r-----. 1 root  named  168 12월 15  2009 named.loopback
-rw-r-----. 1 root  named  222  4월  7 22:37 server.rev
-rw-r-----. 1 root  named  204  4월  7 22:20 server.zone
drwxrwx---. 2 named named    6  8월  8  2019 slaves
# chmod 640 named.ca
```

(주의) DNS Zone이 chroot 구성으로 된 경우

```bash
/var/named  디렉토리에 존재하는 존(ZONE) 파일들은 그룹이 모두 named로 되어 있어야 한다. 만약 존 파일들의 속성정보중 그룹권(Groupship) 부분이 named로 되어 있지 않으면, named 서비스는 Start 되어도 정상적으로 서비스 되지는 않는다. 이런 경우 /var/log/messages 파일안에 이런 존 파일들을 읽을시에 'Permission denied' 라고 표시가 난다. 

# service named restart 
-> 서비스를 restart 했을때 출력되는 메세지(/var/log/messages) 확인

# tail –20 /var/log/messages
..... (중략) .....
4월 07 22:38:10 server1.example.com named[54096]: zone example.com/IN: loading from master file server.zone failed: **permission denied**
 4월 07 22:38:10 server1.example.com named[54096]: zone example.com/IN: not loaded due to errors.
 4월 07 22:38:10 server1.example.com named[54096]: zone 1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa/IN: loaded serial 0
 4월 07 22:38:10 server1.example.com named[54096]: zone 10.168.192.in-addr.arpa/IN: loading from master file server.rev failed: **permission denied**
 4월 07 22:38:10 server1.example.com named[54096]: zone 10.168.192.in-addr.arpa/IN: not loaded due to errors.
..... (중략) .....
# cd /var/named ; ls -l 
# chown root:named server.*    (# chgrp named example*)
# chown root:named named.ca        (# chgrp named named.ca)

# systemctl restart named
-> 에러메세지가 보이지 않을 것이다.
```

```bash
⑦ 네임서버 테스트
DNS 클라이언트 설정 변경 (네임서버 시작)
# vi /etc/resolv.conf /* 네임 서버를 여러개 적어도 총 3개까지만 인식 */
[수정전]
search example.com
nameserver 168.126.63.1
[수정후]
search example.com 
nameserver 192.168.10.200
```

```bash
# netstat -an | grep :53 /* 네임서버는 53번 포트를 사용함 */
# netstat -an | grep :53
tcp        0      0 192.168.10.200**:53**       0.0.0.0:*               LISTEN     
tcp        0      0 127.0.0.1:53            0.0.0.0:*               LISTEN     
tcp        0      0 192.168.122.1:53        0.0.0.0:*               LISTEN     
udp        0      0 0.0.0.0:5353            0.0.0.0:*                          
udp        0      0 192.168.122.1:53        0.0.0.0:*                          
udp        0      0 192.168.10.200:53       0.0.0.0:*                          
udp        0      0 127.0.0.1:53            0.0.0.0:*                          
udp        0      0 192.168.122.1:53        0.0.0.0:*
-> 현재 53 포트가 서비스 중임을 알수 있다.

# pgrep -lf named (# ps -ef | grep named, # ps aux | grep named)
54172 named
```

```bash
⑧ nslookup 명령어로 DNS 서버 등록 내용 확인
		■ DNS 서버에게 질의(Query) 할수 있는 명령어
		   - nslookup CMD (# nslookup www.daum.net)
		   - dig CMD      (# dig www.daum.net)
		   - host CMD     (# host www.daum.net)
		
		■ nslookup 명령어 사용하는 방식
		   - 대화형 모드(Interractive Mode) 형태로 실행
		     # nslookup 
		     > ns1.example.com
		     > exit
		   - 비대화형 모드(Non-Interractive Mode) 형태로 실행
		     # nslookup ns1.example.com
```

```bash
# nslookup
> ns1.example.com       <----- 'ns1.example.com' 입력
Server:		192.168.10.200
Address:	192.168.10.200#53

Name:	ns1.example.com
Address: 192.168.10.200
> exit                           <----- 'exit' 입력
# nslookup ns1.example.com
Server:		192.168.10.200
Address:	192.168.10.200#53

Name:	ns1.example.com
Address: 192.168.10.200
# nslookup 192.168.10.200
200.10.168.192.in-addr.arpa	name = ns1.example.com.

# dig ns1.example.com

; <<>> DiG 9.11.4-P2-RedHat-9.11.4-9.P2.el7 <<>> ns1.example.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 53733
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 2, ADDITIONAL: 3

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;ns1.example.com.		IN	A

;; ANSWER SECTION:
ns1.example.com.	4	IN	A	192.168.10.200

;; AUTHORITY SECTION:
example.com.		4	IN	NS	example.com.
example.com.		4	IN	NS	ns1.example.com.

;; ADDITIONAL SECTION:
example.com.		4	IN	A	127.0.0.1
example.com.		4	IN	AAAA	::1

;; Query time: 0 msec
;; SERVER: 192.168.10.200#53(192.168.10.200)
;; WHEN: 화  4월 07 22:59:19 KST 2020
;; MSG SIZE  rcvd: 132

```

```bash
⑨ 부팅시에 named 데몬 띄우는 설정
	 # systemctl enable named	
```

```bash
SERVER2에서 SERVER1의 DNS를 사용하기
[SERVER2]# cat /etc/resolv.conf
# Generated by NetworkManager
search example.com
#nameserver 8.8.8.8
nameserver 192.168.10.200

[SERVER2]# nslookup ns1.example.com
           DNS 질의가 정상적으로 되지 않는다.

외부 및 내부(server pool)에서 DNS 서비스가 정상적으로 동작하도록 구성해준다.

# firewall-cmd --permanent --add-service=dns 
success
# firewall-cmd --reload 
success

DNS 캐시 삭제
# systemctl is-active systemd-resolved.service
# systemd-resolve --flush-caches
```

chroot 구성

```bash
# rpm -qa | grep chroot
bind-chroot-9.11.4-9.P2.el7.x86_64

# rpm -ql bind-chroot
/etc/named-chroot.files
/usr/lib/systemd/system/named-chroot-setup.service
/usr/lib/systemd/system/named-chroot.service
**/usr/libexec/setup-named-chroot.sh**
/var/named/chroot
/var/named/chroot/dev
/var/named/chroot/dev/null
/var/named/chroot/dev/random
/var/named/chroot/dev/zero
/var/named/chroot/etc
/var/named/chroot/etc/named
/var/named/chroot/etc/named.conf
/var/named/chroot/etc/pki
/var/named/chroot/etc/pki/dnssec-keys
/var/named/chroot/run
/var/named/chroot/run/named
/var/named/chroot/usr
/var/named/chroot/usr/lib64
/var/named/chroot/usr/lib64/bind
/var/named/chroot/var
/var/named/chroot/var/log
/var/named/chroot/var/named
/var/named/chroot/var/run
/var/named/chroot/var/tmp

chroot 환경으로 초기화

bind chroot패키지를 설치 한 경우 BIND 서비스는 chroot 환경에서 실행됩니다. 이 경우 초기화 스크립트는 mount --bind명령을 사용하여 모든 BIND 구성 파일을 chroot 위치에 마운트하므로이 환경 외부에서 구성을 관리 할 수 있습니다. 디렉토리가 자동으로 마운트되므로 디렉토리에 아무것도 복사 할 필요 가 없습니다

# /usr/libexec/setup-named-chroot.sh /var/named/chroot on
# mount | grep /var/named/chroot
/dev/sda8 on /var/named/chroot/etc/localtime type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
/dev/sda8 on /var/named/chroot/etc/named.root.key type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
/dev/sda8 on /var/named/chroot/etc/named.conf type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
/dev/sda8 on /var/named/chroot/etc/named.rfc1912.zones type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
/dev/sda8 on /var/named/chroot/etc/rndc.key type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
/dev/sda8 on /var/named/chroot/etc/named.iscdlv.key type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
/dev/sda8 on /var/named/chroot/etc/protocols type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
/dev/sda8 on /var/named/chroot/etc/services type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
/dev/sda8 on /var/named/chroot/etc/named type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
/dev/sda8 on /var/named/chroot/usr/lib64/bind type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
tmpfs on /var/named/chroot/run/named type tmpfs (rw,nosuid,nodev,seclabel,mode=755)
/dev/sda8 on /var/named/chroot/var/named type xfs (rw,relatime,seclabel,attr2,inode64,noquota)

# systemctl stop named
# systemctl disable named
Removed symlink /etc/systemd/system/multi-user.target.wants/named.service.
# systemctl start named-chroot
# systemctl enable named-chroot
Created symlink from /etc/systemd/system/multi-user.target.wants/named-chroot.service to /usr/lib/systemd/system/named-chroot.service.
# systemctl status named-chroot
● named-chroot.service - Berkeley Internet Name Domain (DNS)
   Loaded: loaded (/usr/lib/systemd/system/named-chroot.service; enabled; vendor preset: disabled)
   Active: active (running) since 화 2020-04-07 23:06:56 KST; 11s ago
 Main PID: 54824 (named)
   CGroup: /system.slice/named-chroot.service
           └─54824 /usr/sbin/named -u named -c /etc/named.conf -t /var/named/chroot

 4월 07 23:06:56 server1.example.com named[54824]: zone 1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa/IN: loaded serial 0
 4월 07 23:06:56 server1.example.com named[54824]: zone 10.168.192.in-addr.arpa/IN: loaded serial 0
 4월 07 23:06:56 server1.example.com named[54824]: zone localhost.localdomain/IN: loaded serial 0
 4월 07 23:06:56 server1.example.com named[54824]: zone localhost/IN: loaded serial 0
 4월 07 23:06:56 server1.example.com named[54824]: all zones loaded
 4월 07 23:06:56 server1.example.com named[54824]: running
 4월 07 23:06:56 server1.example.com named[54824]: zone example.com/IN: sending notifies (serial 0)
 4월 07 23:06:56 server1.example.com named[54824]: zone 10.168.192.in-addr.arpa/IN: sending notifies (serial 0)
 4월 07 23:06:56 server1.example.com systemd[1]: Started Berkeley Internet Name Domain (DNS).
 4월 07 23:06:56 server1.example.com named[54824]: managed-keys-zone: Unable to fetch DNSKEY set '.': failure

# systemctl stop named
# systemctl disable named
# systemctl start named-chroot
# systemctl enable named-chroot
# systemctl status named-chroot

# cd /var/
# ll /var/named/chroot/etc
합계 688K
-rw-r--r--. 2 root root   645  9월 26  2019 localtime
drwxr-x---. 2 root named    6  8월  8  2019 named
-rw-r-----. 1 root named 1.8K  4월  7 21:56 named.conf
-rw-r--r--. 1 root named 3.9K  8월  8  2019 named.iscdlv.key
-rw-r-----. 1 root named 1.1K  4월  7 22:04 named.rfc1912.zones
-rw-r--r--. 1 root named 1.9K  4월 13  2017 named.root.key
drwxr-x---. 3 root named   25  4월  7 21:31 pki
-rw-r--r--. 1 root root  6.4K 10월 31  2018 protocols
-rw-r-----. 1 root named  100  4월  7 21:44 rndc.key
-rw-r--r--. 1 root root  655K  6월  7  2013 services

# ls -l /var/named/chroot/var/named/
합계 28K
drwxr-x---. 7 root  named   61  4월  7 21:31 chroot
drwxrwx---. 2 named named   23  4월  7 21:44 data
drwxrwx---. 2 named named   60  4월  7 23:07 dynamic
-rw-r--r--. 1 root  named  128  4월  7 22:09 named.ca
-rw-r-----. 1 root  named 2.3K  4월  5  2018 named.ca.old
-rw-r-----. 1 root  named  152 12월 15  2009 named.empty
-rw-r-----. 1 root  named  152  6월 21  2007 named.localhost
-rw-r-----. 1 root  named  168 12월 15  2009 named.loopback
-rw-r-----. 1 root  named  222  4월  7 22:37 server.rev
-rw-r-----. 1 root  named  204  4월  7 22:20 server.zone
drwxrwx---. 2 named named    6  8월  8  2019 slaves
```

[EX3] 도메인 등록

```bash
■ RR(Record Type, Resource Record) 종류에 따른 등록 방법
------------------------------------------------------------------------------------
(ㄱ) NS Record Type (Name Server)
example.com. IN NS ns1.example.com.
ns1.example.com. IN A 192.168.10.200

(ㄴ) A Record Type (Address)
www.example.com. IN A 192.168.10.200
www IN A 192.168.10.200

ftp.example.com. IN A 192.168.10.200
cafe.example.com. IN A 192.168.10.200

(ㄷ) MX Record Type (Mail Exchange)
example.com. IN MX 10 mail.example.com.
mail.example.com. IN A 192.168.10.200

example.com. IN MX 20 mail2.linux2XX.example.com.
mail2.example.com. IN A 192.168.10.200

(ㄹ) CNAME Record Type (Canonical Name)
www                IN A 192.168.10.200
ftp                IN A 192.168.10.200
or
www IN A 192.168.10.200
ftp IN CNAME www

(ㅁ) PTR Record Type (Pointer Address)
2XX IN PTR ns1.example.com.
2XX IN PTR www.example.com.
------------------------------------------------------------------------------------

A 레코드 (서브 도메인 생성)
A 레코드를 추가하면 서브 도메인을 생성하여 IP로 사이트를 연결하실 수 있습니다.
예) test.gabia.com 생성을 원하시면, 호스트명에 test를 입력하시고 연결하시려는 사이트의 ip주소를 입력해 주세요.

MX 레코드(메일 설정)
MX 레코드는 메일 연결에 사용됩니다. 입력된 정보를 변경/삭제할 경우 해당 서비스 사용이 변경/중단될 수 있으니, 설정한 메일 정보를 반드시 확인하세요.
MX 설정 시 메일 호스트 주소 입력 내용 끝에 ".(마침표)"를 입력하셔야 정상 세팅 됩니다.
예) kr1-aspmx1.worksmobile.com.

CNAME 레코드
CNAME 정보는 메일, 블로그 연결 등에 사용됩니다. 입력된 정보를 변경/삭제할 경우 해당 서비스 사용이 변경/중단될 수 있으니, 설정한 메일 정보를 반드시 확인하세요.
한글 도메인은 사용 업체에 따라 CNAME을 설정하더라도 메일을 지원하지 않을 수 있습니다.

TXT 레코드
• SPF 레코드를 입력하고자 하는 경우 위 TXT 레코드란에 입력해 주세요.
• 사용하는 도메인이 스팸으로 차단되는 것을 방지하기 위하여 SPF 레코드 등록을 권장합니다.
• 올바른 SPF를 적용하기 위해 SPF Record 작성 도우미를 이용하여 SPF 레코드 등록을 권장합니다. [SPF Record 작성 도우미]
• SPF 레코드값의 올바른 입력 예 : 아래 2가지 예제와 같은 형식으로 입력하시기 바랍니다.
v=spf1 include:_spf.hiworks.co.kr ~all / v=spf1 ip4:211.243.118.50 ~all
• ※ TXT레코드에는 @, ^, <, >, ?, `(어퍼스트로피)를 입력할 수 없습니다.

SRV 레코드
※ SRV 레코드 설정 시, 대상 값 입력 내용 끝에 "."을 입력하셔야 정상 세팅됩니다.
예) sipdir.online.lync.com.
```

(시나리오) 도메인 등록 요청이 들어 왔다. 요청이 들어온 내용을 확인해 보면 다음과 같다.

```bash
▪ WEB  서버 등록 요청:  www.example.com  -> 192.168.10.200
▪ FTP  서버 등록 요청:  ftp.example.com  -> 192.168.10.200
▪ MAIL 서버 등록 요청:  mail.example.com -> 192.168.10.200
▪ CAFE 서버 등록 요청:  cafe.example.com -> 192.168.10.200
```

```bash
(도메인 등록 방법)
(ㄱ) Forward Zone 파일에 등록
# vi /var/named/chroot/var/named/server.zone (Domain -> IP)
-> 반드시 등록 해야 함.                          (www     IN    A    192.168.10.200)
(ㄴ) Reverse Zone 파일에 등록
# vi /var/named/chroot/var/named/server.rev  (IP -> Domain)
-> 반드시 등록할 필요 없음.                      (200     IN    PTR  www)
```

```bash
① Forward Zone 파일에 등록
# cd /var/named/chroot/var/named 
# vi server.zone
$TTL 4
@       IN SOA  ns1.example.com. root.example.com. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
        NS      @
        A       127.0.0.1
        AAAA    ::1
        IN      NS      ns1
ns1     IN      A       192.168.10.200

;; (1) WEB Server 
**www     IN      A       192.168.10.200**

;; (2) FTP Server
**ftp     IN      A       192.168.10.200**

;; (3) MAIL Server
**example.com.    IN      MX 10   mail.example.com.
mail    IN      A       192.168.10.200**

;; (4) etc
**cafe    IN      A       192.168.10.200**

-> 실습할 때는 Reverse Zone 파일에 등록하지는 않는다.
-> Reverse Zone 파일에는 반드시 등록할 필요가 없기 때문이다.
-> 이 파일에 Zone Entry를 등록할 때 필드와 필드 구분은 탭/스페이스로 한다.(권장: 탭)
```

```bash
# systemctl restart named-chroot
-> Zone 파일이 수정되면 변경된 사항을 적용시키기 위해서 데몬(named) restsart가 필요하다.
-> 서비스를 restart 할때는 반드시 /var/log/messages 파일을 같이 모니터링 한다.
		# nslookup www.linux2XX.example.com   (# nslookup www)
		# nslookup ftp.linux2XX.example.com   (# nslookup ftp) 
		# nslookup cafe.linux2XX.example.com  (# nslookup cafe) 
		# nslookup -q=MX linux2XX.example.com
```

```bash
② DNS와 웹서버 연동
----- DNS Client ----            ----- DNS Server -----                ---- WEB Server -----

http://www.example.com ------> named(53)
                                <------ # cat exampleXXX.com
                      www..example.com. IN A 192.168.10.210

								        ---------------------------------------------------->httpd(80)  
								        <---------------------------------------------------- httpd.conf
```

```bash

# rpm -qa | grep httpd
/etc/resolv.conf 파일의 내용 수정

# yum -y install httpd
# ls /etc/httpd/conf       --> httpd.conf 파일 존재 확인
httpd.conf  magic

# ls /var/www/html         --> index.html 파일 존재 확인
#
-> index.html 파일 존재하지 않는다.
# cp /etc/passwd /var/www/html/index.html 

# systemctl restart httpd

[SERVER2]# dnf --enablerepo=PowerTools install lynx

```

[참고] 리눅스에서 호스트이름(Hostname) 변경하는 경우

```bash
# system-config-network-tui
or
# vi /etc/sysconfig/network 파일 수정

# vi /etc/hosts     <----- 일부 프로그램들이 호스트이름을 확인(예: oracle, apache, ....)
# service network restart

[참고] "service httpd restart" 에러메세지
# service httpd restart
Stopping httpd:                                            [FAILED]
Starting httpd: httpd: apr_sockaddr_info_get() failed for linux249.example.com
httpd: Could not reliably determine the server's fully qualified domain name, using 127.0.0.1 for 
    ServerName
# vi /etc/hosts 
.......
192.168.10.200 server1.example.com server1
# service httpd restat
```

```bash
# pgrep -lf httpd     (# ps -ef | grep httpd)
55866 httpd
55869 httpd
55870 httpd
55871 httpd
55872 httpd
55873 httpd
```

■ 윈도우 창에서 확인(IP 확인)

(Linux) **# firefox http://172.16.9.2XX**

■ 윈도우 창에서 확인(도메인 이름으로 확인)

(Linux) **# firefox http://www.linux2XX.example.com**

```bash
# cd /var/www/html 
# vi index.html
<HTML>
<BODY>
<CENTER><H1>linux2XX</H1></CENTER>
</BODY>
</HTML>
```

■ 윈도우 창에서 확인 (**http://www.linux2XX.example.com**)

-> **http://www.linux2XX.example.com**

-> 파트너시스템들에 대해서 **http://www.linux249.example.com** 요청을 해 본다.

(Linux) **# firefox http://www.linux2XX.example.com**

(Linux) **# firefox http://www.linux249.example.com**

[추가적인 실습] 도메인 등록 실습

```bash
① 도메인 등록
centos58.linux2XX.example.com172.16.9.2XX 
centos59.linux2XX.example.com172.16.9.2XX 
server1.linux2XX.example.com172.16.9.252 
② 도메인 등록 확인
# nslookup centos58 
# nslookup centos59 
# nslookup server1 
# firefox http://server1.linux2XX.example.com
```

[EX3] DNS 부하 분산

```bash
(L4 부하분산)

               +------ Web1 ------+
               |                  |
----- L4 ------+------ Web2 ------+------ NAS/NFS
               |                  |
               +------ Web3 ------+

(DNS 부하분산)

               +------ Web1 ------+
               |                  |
---- DNS ------+------ Web2 ------+------ NAS/NFS
               |                  |
               +------ Web3 ------+
```

다음은 "Windows Vista"의 "cmd" 창에서 실행한것이다.
**<CTRL + ESC>** => **cmd** => **<ENTER>
c:\> nslookup www.daum.net**

```bash
서버:    qns1.hananet.net
Address:  210.220.163.82

권한 없는 응답:
이름:    top.g.daum.net
Addresses:211.115.77.213
          211.115.77.214
          211.32.117.30
          211.115.77.211
          211.115.77.212
Aliases:  www.daum.net
```

c:\> nslookup [www.daum.net](http://www.daum.net/)

```bash
서버:    qns1.hananet.net
Address:  210.220.163.82

권한 없는 응답:
이름:    top.g.daum.net
Addresses:211.115.115.212
          222.231.51.40
          222.231.51.77
          222.231.51.78
          211.115.115.211
Aliases:  www.daum.net
```

c:\> nslookup [www.daum.net](http://www.daum.net/)

```bash
서버:    qns1.hananet.net
Address:  210.220.163.82

권한 없는 응답:
이름:    top.g.daum.net
Addresses:211.115.77.214
          211.32.117.30
          211.115.77.211
          211.115.77.212
          211.115.77.213
Aliases:  www.daum.net

-> 1~2초 정도에 한번씩 nslookup 명령어를 통해 정보를 요청해 보면, 첫번째 오는 아이피 주소가 변경된다는 것을 
   알수 있다. 출력된 내용의 첫번째 아이피쪽으로 도메인에 대한 IP 요청을 하게 된다.
```

**(시나리오)** 다음과 같이 도메인 등록을 해 달라고 요청이 들어왔다. 하나의 도메인 이름에 대해서 3개의 아이피가 연결 된다고 한다.

▪ 도메인이름(www.linux**2XX**.example.com) -> (172.16.9.2, 172.16.9.3, 172.16.9.4)

```bash
① Forward Zone 파일에 등록
# cd /var/named/chroot/var/named 
# vi example2XX.zone
$TTL    4
@               IN SOA  ns1.linuxXXX.example.com. root.linuxXXX.example.com. (
                                        42              ; serial (d. adams)
                                        3H              ; refresh
                                        15M             ; retry
                                        1W              ; expiry
                                        1D )            ; minimum
                IN NS           ns1
ns1             IN A            172.16.9.XXX

;; (1) WEB Server
;www   IN      A       172.16.9.2XX  <----- 주석(;)처리
www                       IN      A       172.16.9.2    <----- 새로운 라인 등록
www                       IN      A       172.16.9.3    <----- 새로운 라인 등록
www                       IN      A       172.16.9.4    <----- 새로운 라인 등록

;; (2) FTP Server
ftp             IN      A       172.16.9.XXX

;; (3) MAIL Server
                IN      MX 10   mail
mail            IN      A       172.16.9.XXX

;; (4) etc
cafe            IN      A       172.16.9.XXX

# service named restart 
-> Zone 파일 수정 내용 적용
```

```bash
② DNS 부하 분산 테스트
# nslookup www.linux2XX.example.com   (# nslookup www)
Server:         172.16.9.XXX
Address:        172.16.9.XXX#53

Name:   www.linuxXXX.example.com
Address: 172.16.9.3
Name:   www.linuxXXX.example.com
Address: 172.16.9.4
Name:   www.linuxXXX.example.com
Address: 172.16.9.2
```

```bash
# nslookup www.linux2XX.example.com   (# nslookup www)
Server:         172.16.9.XXX
Address:        172.16.9.XXX#53

Name:   www.linuxXXX.example.com
Address: 172.16.9.2
Name:   www.linuxXXX.example.com
Address: 172.16.9.3
Name:   www.linuxXXX.example.com
Address: 172.16.9.4
```

```bash
# nslookup www.linux2XX.example.com   (# nslookup www)
Server:         172.16.9.XXX
Address:        172.16.9.XXX#53

Name:   www.linuxXXX.example.com
Address: 172.16.9.4
Name:   www.linuxXXX.example.com
Address: 172.16.9.2
Name:   www.linuxXXX.example.com
Address: 172.16.9.3
```

[EX4] 도메인 위임(Domain Delegation)

도메인 위임은 일반적으로 웹호스팅 업체(예:가비아)에서 일반적으로 많이 사용하고 있다.

[참고] **domain(yahoo.com) 할당 받는 방법**(예: 가비아)

```bash
+---------------------- example.com ------------------------+
|* DNS(ns1.example.com)                                     |
|                                                           |
|   +----- linuxXXX.example.com --------+                   |
|   | * DNS(ns1.linuxXXX.example.com)   |                   |
|   |                                   |                   |
|   |                                   |                   |
|   +-----------------------------------+                   |
|                                                           |
+-----------------------------------------------------------+
```

```bash
■ DNS(ns.example.com)
# vi /var/named/chroot/var/named/exampleXXX.zone
..... (중략) .....
example.com.                  IN  NS  ns1.example.com.
ns1.example.com.              IN  A   192.168.10.200
..... (중략) .....

or

..... (중략) .....
linuxXXX            IN  NS  ns1.linuxXXX
ns1.                IN  A   192.168.10.200
..... (중략) .....
```

```bash
# vi /var/named/example.rev
..... (중략) .....
2XX                           IN  PTR  ns1.linuxXXX.example.com.
-> 반드시 등록할 필요는 없다.
```

[EX] Hint Domain Administration

```bash
+----------------- . (Nameless Root Domain)-----------------+
|■ DNS(A.ROOT-SERVERS.NET)                                  |
|                                                           |
|   +------------ com ------------------+                   |
|   |■ DNS(ns.com)                      |                   |
|   |                                   |                   |
|   |                                   |                   |
|   +-----------------------------------+                   |
|                                                           |
+-----------------------------------------------------------+
```

■ DNS([A.ROOT-SERVER.NET](http://a.root-server.net/))

```bash
# vi /var/named/example254.zone
....
com.                          IN  NS  ns.com.
ns.com.                       IN  A   172.16.8.200
net.                          IN  NS  ns.net.
ns.net.                       IN  A   172.16.9.200
org.                          IN  NS  ns.org.
ns.org.                       IN  A   172.16.10.200
```

[EX5] Master DNS Server / Slave DNS Server 구축

```bash
----- Master DNS Server ---------- Slave DNS Server -----
      (172.16.9.2XX)               (172.16.9.1XX)

---------------------------------------------------------
						[그림] 실습 구조(Master/Slave DNS Server)
```

(전제조건) Master DNS Server - Slave DNS Server를 구축한다.

```bash
[server2] 
# yum -y install bind bind-chroot bind-utils
설치후 디렉토리 확인

# ls -l /var/named/
합계 16
drwxr-x---. 7 root  named   61  4월  7 23:59 chroot
drwxrwx---. 2 named named    6  8월  8  2019 data
drwxrwx---. 2 named named    6  8월  8  2019 dynamic
-rw-r-----. 1 root  named 2253  4월  5  2018 named.ca
-rw-r-----. 1 root  named  152 12월 15  2009 named.empty
-rw-r-----. 1 root  named  152  6월 21  2007 named.localhost
-rw-r-----. 1 root  named  168 12월 15  2009 named.loopback
drwxrwx---. 2 named named    6  8월  8  2019 slaves

# ls /etc/named*
/etc/named-chroot.files  /etc/named.rfc1912.zones
/etc/named.conf          /etc/named.root.key
/etc/named.iscdlv.key

▪ Master DNS Server : 192.168.10.200 (ns1.example.com) 
▪ Slave  DNS Server : 192.168.10.252 (ns2.example.com) 

▪ 한개의 도메인(example.com)에 두개의 DNS 서버(ns1/ns2.example.com)가 존재한다. 
▪ 두개의 DNS 서버는 각각 다른 IP(192.168.10.200/192.168.10.252)를 가지고 있다.
▪ (윈도우) cmd.exe
<CTRL + ESC> => "cmd"
C:\> nslookup –q=NS seoul.ac.kr 
C:\> nslookup –q=NS kornet.net 
C:\> nslookup –q=NS naver.com 
C:\> nslookup –q=NS daum.net
```

[Master DNS Server] 192.168.10.200

```bash
[server1]
-> Master DNS 서버의 전원 ON
① 주설정 파일 정보 확인 및 설정
Master DNS 서버에서 주 설정 파일은 특별히 설정할 필요가 없다.

# vi /etc/named.conf            
..... (중략) .....
options {
        listen-on port 53 { any; };
        listen-on-v6 port 53 { none; };
        directory       "/var/named";
        dump-file       "/var/named/data/cache_dump.db";
        statistics-file "/var/named/data/named_stats.txt";
        memstatistics-file "/var/named/data/named_mem_stats.txt";
        recursing-file  "/var/named/data/named.recursing";
        secroots-file   "/var/named/data/named.secroots";
        allow-query     { any; };
        allow-transfer  { localhost; **192.168.10.252**};  <----- 라인 변경 -> 삭제

# vi /etc/named.rfc1912.zones

..... (중략) .....
zone "0.in-addr.arpa" IN {
        type master;
        file "named.zero";
        allow-update { none; };
};

zone "example.com" IN {
        type master;
        file "server.zone";
        **also-notify { 192.168.10.252; };**   <----- 라인 추가
};

zone "10.168.192.in-addr.arpa"  IN {
         type master;
         file "server.rev";
         **also-notify { 192.168.10.252; };**  <----- 라인 추가
};

[참고]
"also-notify { 192.168.10.252; };" 자신의 Slave DNS 서버에게 변경 사항을 알려주는 설정
(주의) 이 설정이 없으면, 실시간적으로 Slave DNS 서버에 업데이트가 가능하지 않다.
```

```bash
② Forward-Zone/Reverse-Zone 파일 설정
# cd /var/named/chroot/var/named 
# ls
chroot   named.ca      named.localhost  server.zone
data     named.ca.old  named.loopback   slaves
dynamic  named.empty   server.rev
-> server.zone, server.rev 파일을 변경할 것이다.

# vi server.zone
$TTL    4
@               IN SOA  ns1.linux2XX.example.com. root.linux2XX.example.com. (
                                        42              ; serial (d. adams)
                                        3H              ; refresh
                                        15M             ; retry
                                        1W              ; expiry
                                        1D )            ; minimum
                IN NS           ns1
                **IN NS           ns2**              <----- 새로운 라인 추가
ns1             IN A            192.168.10.200
**ns2             IN A            192.168.10.252**     <----- 새로운 라인 추가

www     IN      A       192.168.10.200
ftp     IN      A       192.168.10.200
example.com.    IN      MX 10   mail.example.com.
mail    IN      A       192.168.10.200
cafe    IN      A       192.168.10.200
nfs     IN      A       192.168.10.200
iscsi   IN      A       192.168.10.200
```

```bash
# vi server.rev
$TTL 4
@       IN SOA  ns1.example.com. root.example.com. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
        NS      @
        A       127.0.0.1
        AAAA    ::1
				IN      NS      ns1.example.com.
        **IN      NS      ns2.example.com.**      <----- 새로운 라인 추가
200     IN      PTR     ns1.example.com.
**252     IN      PTR     ns2.example.com.**      <----- 새로운 라인 추가
```

```bash
③ 존 파일 수정 적용
/var/log/messages 파일을 모니터링 하면서 named를 restart 한다.

[TERM1] # tail -f /var/log/messages 
[TERM2] # service named restart 

# nslookup -q=NS example.com
Server:		192.168.10.200
Address:	192.168.10.200#53

example.com	nameserver = ns1.example.com.
example.com	nameserver = ns2.example.com.
example.com	nameserver = example.com.
```

[Slave DNS Server]

```bash
[server2]
-> Slave DNS 서버의 전원 ON

① 네트워크 설정
# ifconfig
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet **192.168.10.252**  netmask 255.255.255.0  broadcast 192.168.10.255
        inet6 fe80::bb6c:8e6a:2b29:6949  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:5c:83:f4  txqueuelen 1000  (Ethernet)
        RX packets 13864  bytes 16901659 (16.1 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 6971  bytes 537150 (524.5 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

```bash
-> 네트워크 설정을 한다.

■ Static IP    : 192.168.10.252/24
■ DNS Server   : 192.168.10.200 
■ DNS Server   : 168.126.63.1 

■ Hostname       : server2.example.com
■ Primary DNS    : 192.168.10.200
# nmcli con mod ens33 ipv4.dns 192.168.10.200
# nmcli con mod ens33 +ipv4.dns 168.126.63.1
```

```bash
# nmcli con down ens33 ; nmcli con up ens33
-> 설정 내용 적용
# nmcli con show ens33 | grep -i ipv4.dns
ipv4.dns:                               192.168.10.200,168.126.63.1

② 주 설정 파일 확인 및 설정
# vi /etc/named.conf
options {
        listen-on port 53 { **any**; };
        listen-on-v6 port 53 { **none** ; };

        directory       "/var/named";
        dump-file       "/var/named/data/cache_dump.db";
        statistics-file "/var/named/data/named_stats.txt";
        memstatistics-file "/var/named/data/named_mem_stats.txt";
        recursing-file  "/var/named/data/named.recursing";
        secroots-file   "/var/named/data/named.secroots";
        allow-query     { **any**; };
```

```bash
# vi /etc/named.rfc1912.zones
..... (중략) .....
};

zone "0.in-addr.arpa" IN {
        type master;
        file "named.zero";
        allow-update { none; };
};

zone "example.com" IN {
        type slave;                    <----- 정보변경(master -> slave)
        masters { 192.168.10.200; };    <----- 새로운 라인 추가(172.16.9.2XX : Master DNS Server)
        file "slaves/server.zone"; <----- 정보변경
};

zone "10.168.192.in-addr.arpa" IN {
        type slave;                    <----- 정보변경(master -> slave)
        masters { 192.168.10.200; };    <----- 새로운 라인 추가(172.16.9.2XX : Master DNS Server)
        file "slaves/server.rev";  <----- 정보변경
};

# /usr/libexec/setup-named-chroot.sh /var/named/chroot on
# systemctl start named-chroot
# systemctl status named-chroot
● named-chroot.service - Berkeley Internet Name Domain (DNS)
   Loaded: loaded (/usr/lib/systemd/system/named-chroot.service; disabled; vendor preset: disabled)
   Active: active (running) since 수 2020-04-08 00:14:14 KST; 4s ago
  Process: 1991 ExecStart=/usr/sbin/named -u named -c ${NAMEDCONF} -t /var/named/chroot $OPTIONS (code=exited, status=0/SUCCESS)
  Process: 1988 ExecStartPre=/bin/bash -c if [ ! "$DISABLE_ZONE_CHECKING" == "yes" ]; then /usr/sbin/named-checkconf -t /var/named/chroot -z "$NAMEDCONF"; else echo "Checking of zone files is disabled"; fi (code=exited, status=0/SUCCESS)
 Main PID: 1993 (named)
   CGroup: /system.slice/named-chroot.service
           └─1993 /usr/sbin/named -u named -c /etc/named.conf -t /var/named/chroot

 4월 08 00:14:14 server2.example.com named[1993]: network unreachable resolving './DNSKEY/IN': 2001:7fe::53#53
 4월 08 00:14:14 server2.example.com named[1993]: network unreachable resolving './DNSKEY/IN': 2001:500:a8::e#53
 4월 08 00:14:14 server2.example.com named[1993]: managed-keys-zone: Key 20326 for zone . acceptance timer complete: key now trusted
 4월 08 00:14:14 server2.example.com named[1993]: zone example.com/IN: Transfer started.
 4월 08 00:14:14 server2.example.com named[1993]: transfer of 'example.com/IN' from 192.168.10.200#53: connected using 192.168.10.252#46181
 4월 08 00:14:14 server2.example.com named[1993]: zone example.com/IN: transferred serial 0
 4월 08 00:14:14 server2.example.com named[1993]: transfer of 'example.com/IN' from 192.168.10.200#53: Transfer status: success
 4월 08 00:14:14 server2.example.com named[1993]: transfer of 'example.com/IN' from 192.168.10.200#53: Transfer completed: 1 messages, 12 records, 296...ytes/sec)
 4월 08 00:14:14 server2.example.com named[1993]: zone example.com/IN: sending notifies (serial 0)
 4월 08 00:14:15 server2.example.com named[1993]: resolver priming query complete
Hint: Some lines were ellipsized, use -l to show in full.

# service named restart 
-> 변경 내용 적용
```

```bash
③ 존 파일 확인
# cd /var/named/chroot/var/named/slaves 
# ls -l
합계 8
-rw-r--r--. 1 named named 486  4월  8 18:03 server.rev
-rw-r--r--. 1 named named 693  4월  8 18:03 server.zone
-> 2개의 파일이 만들어진것을 확인 할 수 있다.
```

```bash
# cat server.zone
examplecom??s1examplecomrootexamplecomQ?	:?*03
examplecomns1examplecomns2examplecom7
mailexamplecom,cafeexamplecom??
?+ftpexamplecom??
?-iscsiexamplecom??
?,mailexamplecom??
?+nfsexamplecom??
?+ns1examplecom??
?+ns2examplecom??
?+wwwexamplecom??
```

[EX6] 존 업데이트 실습

```bash
(선수지식) /var/named/chroot/var/named/(example2XX.zone or example2XX.rev)
------------------------------------------------------------------------------
@               IN SOA  ns1.linux2XX.example.com. root.linux2XX.example.com. (
                                        42              ; serial (d. adams)
                                        3H              ; refresh
                                        15M             ; retry
                                        1W              ; expiry
                                        1D )            ; minimum
------------------------------------------------------------------------------
S0A(Start Of Authority)
- [Domain]  [TTL]  IN  SOA  <DNS Server> <E-mail> (NNNN  NNNN  NNNN NNNN NNNN)

▪ 42  (Serial Number) (권장: 2010031100)
▪ 3H  (Refresh Time)       (권장: 12H, 1D)
▪ 15M (Retry Time)         (권장: 15M ~ 1H)
▪ 1W  (Expire Date)        (권장: 1W)
▪ 1D  (TTL, Time To Live)  (권장: 1D)
```

[Master DNS Server] 192.168.10.200

```bash
① Forward Zone 파일에 새로운 내용 업데이트 
# vi /var/named/chroot/var/named/server.zone
```

```bash
$TTL 4
@       IN SOA  ns1.example.com. root.example.com. (
                                        10       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
        NS      @
        A       192.168.10.200
        AAAA    ::1
        IN      NS      ns1
        IN      NS      ns2
ns1     IN      A       192.168.10.200
ns2     IN      A       192.168.10.252
www     IN      A       192.168.10.200
ftp     IN      A       192.168.10.200
example.com.    IN      MX 10   mail.example.com.
mail    IN      A       192.168.10.200
cafe    IN      A       192.168.10.200
nfs     IN      A       192.168.10.200
iscsi   IN      A       192.168.10.200
test    IN      A       192.168.10.200   <----- 새로운 라인 추가
```

```bash
② 서비스 적용 및 확인
# service named restart 
-> 서비스 적용

# nslookup test.linux2XX.example.com   (# nslookup test)
Server:         172.16.9.XXX
Address:        172.16.9.XXX#53

Name:   test.linuxXXX.example.com
Address: 172.16.9.XXX
```

[Slave DNS Server] 172.16.9.1XX

```bash
① Forward Zone 파일(Zone 데이터) 확인
# cd /var/named/chroot/var/named/slaves 
# grep test example2XX.zone 
#
-> 출력되는 내용이 없다.

# service named restart 
-> named 데몬을 restart 시켜 본다.

# grep test example2XX.zone 
#
-> 출력되는 내용이 없다.
```

**(주의)** Slave DNS 서버에 Zone 데이터가 업데이트가 되지 않은 이유

- Master DNS 서버 관리자가 Zone 데이터를 변경 할때는 반드시 serial number 값을 기존의 값보다 높여 줘야 한다.
- 그렇지 않으면, Slave DNS 서버쪽으로 Zone 데이터를 업데이트 되지 않는다. 그럼 한개의 도메인에 두대의 DNS 서버가 존재하지만 두대의 서버의 내용은 불일치 하게 된는 것이다.

```bash
② Slave DNS 서버 모니터링
Slave DNS 서버에서는 모니터링을 시작한다. 
[TERM1] # cd /var/named/chroot/var/named/slaves 
        # watch grep test example2XX.zone   (# watch CMD)
[TERM2] # tail -f /var/log/messages
```

[Master DNS Server] 172.16.9.2XX

```bash
① Forward Zone 파일 내용 추가
# vi /var/named/chroot/var/named/example2XX.zone
$TTL    4
@               IN SOA  ns1.linuxXXX.example.com. root.linuxXXX.example.com. (
                                        43              ; serial (d. adams)    <----- 정보 변경 추가
                                        3H              ; refresh                     (42 -> 43)
                                        15M             ; retry
                                        1W              ; expiry
                                        1D )            ; minimum
                IN NS           ns1
ns1             IN A            172.16.9.XXX

;; (1) Web Server
;www            IN      A       172.16.9.XXX
www             IN      A       172.16.9.2
www             IN      A       172.16.9.3
www             IN      A       172.16.9.4

;; (2) FTP Server
ftp             IN      A       172.16.9.XXX

;; (3) MAIL Server
                IN      MX 10   mail
mail            IN      A       172.16.9.XXX

;; (4) etc
cafe            IN      A       172.16.9.XXX
test            IN      A       172.16.9.XXX
test1           IN      A       172.16.9.2XX    <----- 새로운 라인 추가

② 서비스 변경 적용
# service named restart 
-> 서비스 적용

# nslookup test1.linux2XX.example.com   (# nslookup test1)
-> 확인

[Slave DNS Server] 172.16.9.1XX 

# cd /var/named/chroot/var/named/slaves 
# grep test example2XX.zone 
-> 변경된 내용을 확인 할 수 있다.
-> Zone 파일(Forward/Reverse Zone 파일)을 지우고 "# service named restart" 해서 다시 Zone 파일을 받으면 업
   데이트가 되지만, 이런 경우는 실시간적인 동기화가 되지는 않는 상태이므로 좋은 방법은 아니다.
-> DNS Master 서버에서 시리얼 번호(Serial Number) 업데이트 없이 Zone 파일을 업데이트 하고 데몬을 restart 
   했다고 해서 Zone 파일이 업데이트 되지는 않는다.
```

- [EX7] rndc 실습
- [EX8] allow-update 설정
- [EX9] allow-tranfer 설정

```bash
메일서버 - > MX * 

Master - SERVER1
Slave - SERVER2

DNS 설정 및 구성 그리고 확인

클라이언트- /etc/resolv.conf
         nslookup - bind-utils

서버 - 
필요 패키지 bind bind-chroot bind-libs bind-utils

서버의 기본 설정 사항을 확인한다.
/etc/named*
/var/named

/etc/named.conf
-> DNS의 질의를 받는 대상이 자신뿐만이 아니라 나머지 클라이언트에게도 가능하도록 설정해줘야한다.
/etc/named.rfc1912.zones
-> ZONE에 대한 정의
    도메인 정보와 도메인에서 사용할 파일에 대한 정의
zone "example.com" IN {   이 존은 example.com 도메인에 대한 정방향 존파일이다.
	type master;            이 구역이 마스터 파일
	file "server.zone";     example.com 을 정의하는 파일은 /var/named/server.zone 파일이다.
	};
	
설정파일을 수정한뒤 문법 체크를 해본다.
# named-checkconf /etc/named.conf 
# named-checkconf /etc/named.rfc1912.zones 
 -* 완벽한건 아니다.

# cd /var/named
힌트 파일 재구성
기존의 힌트파일은 삭제, 이동
# vi hint.ca
.                       86400   IN      NS      ns1.example.com.   < 이 DNS로 질의되는 내용중에 내가 가지고 있지 않은 도메인에 대해서 확인하는 경우 질의 도에인을 ns1.example.com으로 설정하겠다.
ns1.example.com.        86400   IN      A       192.168.10.200     <

zone 파일 생성

#  named-checkzone example.com server.zone 존 파일에 대하여 문법 확인
# named-checkzone 10.168.192.in-addr.arpa server.rev  역방향 존 파일에 대하여 확인

서비스를 실행하기 전에 확인
파일들의 그룹 소유자가 named로 되어 있는지 확인하고 그렇지 않은 경우에는 chown 명령어를 이용하여 변경한다.

chroot 구성으로 변경
# /usr/libexec/setup-named-chroot.sh /var/named/chroot on

# systemctl restart named-chroot
status
enable

방화벽 구성
firewall-cmd --permanant --add-service=dns
firewall-cmd --reload
```

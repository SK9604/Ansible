## 🙋🏻‍♀️ 일곱번째 비대면 수업

- **배운 내용**

  VI 편집기

  ​	vi 실행

  ​	vi 편집기 특징

  ​	vi의 특징

  ​	기본 작업 테스트

  vi의 세 가지 모드 변경 방법

  ​	입력행 모드

  ​	명령행 모드

  ​	최하위행 모드

  치환 작업

  ​	검색/바꾸기 모드

  vi 편집기 환경파일설정

  파일의 퍼미션 변경

  ​	chmod 명령어

  파일과 디렉토리 퍼미션의 정확한 의미

  ​	umask 명령어

  ​	setUID / setGID

  1주차 시험

# 내용 정리

## VI 편집기

- VI 실행
- VI의 세가지 모드 변경 방법
- 입력모드
- 명령모드
- 최하위행 모드

```bash
windows : 메모장

macos   : 텍스트 편집기

linux   : VI, Gedit

Unix    : VI
```

모든 운영체제에는 기본적으로 텍스트 편집기

추가적으로 설치하여 사용하는 것들도 당연히 있지만 기본 설치되어 제공되는 프로그램을 사용할 줄 알아야 한다.

리눅스, 유닉스에서도 그래픽 모드에서 지원하는 텍스트 에디터가 존재한다. gedit 하지만 모든 서버가 항상 GUI 모드를 활성화 하여 사용하는 것은 아니다.

CLI, TUI 모드에서 활용 가능한 텍스트 편집기를 하나정도는 숙지하고 있어야 문서 편집, 설정 파일 편집 등에서 어려움을 겪지 않을 수 있다.

windows 편집기 대용

```bash
notepad++
vscode
notion
typora
```

- [ ] 현재 많이 사용되는 편집기 종류

  - **vi 편집기(Visual Editor)**
    vi 편집기는 **유닉스 계열에서 가장 많이 사용되는** 텍스트 편집기이다. 1976년 **빌 조이(Bill Joy)가 개발하였다.** vi 편집기는 한 화면을 편집하는 비쥬얼 에디터(Visual Editor)이다.

  - **vim(vi improved)**
    브람 무레나르(Bram Moolenaar)가 vi 편집기와 호환되면서 독자적으로 다양한 기능 추가하여 만든 편집기이다. 편집시에 다양한 색상을 이용하여 가시성을 높였으며, 패턴 검색시에 하이라이트 기능을 제공하여 빠른 검색이 가능하게 해준다. (http://www.vim.org)

      vi와 다른 몇 가지 기능을 추가하여 만든 **vi 호환 배포판**

  - **emacs 편집기(Editor Macros)**
    리처드 스톨만이 개발한 **고성능 문서 편집기이다.** 매크로 기능이 있는 텍스트 교정 및 편집기이다. 초기 리처드 스톨만에 의해 개발 되었고, 이후에 제임스 고슬링(James Gosling)이 LISP(LISt Processor) 언어에 의한 환경 설정 및 에디터 기능을 확장시킬 수 있는 기능을 포함하여 '고슬링 이맥스'라는 이름으로 배포하였다.

  - **pico(Pine Composer)**
    워싱턴 대학의 Aboil Kasar가 개발한 유닉스 기반의 텍스트 에디터로 pine 이메일 클라이언트 프로그램에 통합되어서 배포되었다. pico의 기본 인터페이스는 윈도우의 메모장(Notepad)와 유사하여 **매우 단순한다.**

  - **nano**
    pico의 복제 버전이다. nano는 pico의 기능 이외에도 **마우스 지원,** 자동 들여쓰기, 정규 표현식 검색, 구문 강조 등의 기능을 추가로 제공한다.

### VI 실행

----

```bash
# vi
# vi filename
# vi -r filename
# vi -L
# vi +38 filename
# vi +/"word" filename
```

### vi 편집기 특징

----

```bash
▪ VI(VIsual editor)           -> /bin/vi
▪ VIM(Visual editor IMproved) -> /usr/bin/vim

# ls –l /bin/vi 
-rwxr-xr-x 1 root root 581K Jan  9  2013 /bin/vi*
# ls -l /usr/bin/vim 
-rwxr-xr-x 1 root root 2.7M Jan  9  2013 /usr/bin/vim*

# vi ~/.bashrc    (# gedit ~/.bashrc)
alias vi='/usr/bin/vim'
# . ~/.bashrc     (# source ~/.bashrc)
```

vi('브이아이'로 부른다)는 Emacs와 함께 Unix 환경에서 가장 많이 쓰이는 문서 편집기이다. 1976년 빌 조이가 초기 BSD 릴리즈에 포함될 편집기로 만들었다. vi라는 이름은 한 줄씩 편집하는 줄단위 편집기가 아니라 한 화면을 편집하는 비주얼 에디터(visual editor)라는 뜻에서 유래했다. 간결하면서도, 강력한 기능으로 열광적인 사용자가 많다.

현재는 오리지널 vi를 사용하는 경우는 거의 없고, 일반적으로 기능을 모방하여 만들어진 클론을 사용하고 있다. 이런 클론 중 많이 쓰이는 것은 기능이 다양한 것을 장점으로 내세우며, 리눅스 배포판에 포함되는 Vim, 그리고, BSD 라이선스로 제공되며 원본 vi의 동작과 호환성으로 정평이 나 있는 nvi, 독자적인 팬층을 확보한 elvis등이 있다.

### vi의 특징

----

![vi 특징](https://user-images.githubusercontent.com/56914461/100822732-3c84b180-3496-11eb-9a42-d39446422684.png)

- VI 편집기가 동작하는 원리를 보면 다음과 같이 버퍼에서 작업을 하게 된다.
  그러므로 저장을 시키는 명령어를 입력하지 않는 이상 디스크상에 파일의 내용이 저장되는 것은 아니다. (.swp 파일 제외)

```bash
명령어 형식          설명
$ vi              새 파일을 편집할 수 있는 화면이 나온다. 여기서 작업을 한후에는 반드시 파일이름을 지정하여 저장하여 주어야 한다. 예) : w filename (최하위행 모드)

$ vi filename     filename 이름을 가진 파일이 존재하는 경우 해당 파일을 편집하고 filename 이름을 가진 파일이 존재하지 않는 경우 새 파일을 편집할 수 있는 화면 상태가 된다.

$ vi -R filename  Readonly, 파일을 Readonly 상태로 열어준다. 중요한 파일, 여러 사람이 동시에 수정가능한 파일을 다룰때 편리하게 사용 될수 있다.view 명령어와 동일한 기능을 수행할 수 있다.
$ view filename 

$ vi -r filename  Recovery, 이전 vi 편집 작업 중 비정상적으로 작업이 끝난 경우 편집하던 파일 복구시에 사용된다. 이 경우 사용자의 메일로 복구할 파일에 대한 정보가 오게 된다.

$ vi -L           이전 vi 편집 작업 중 비정상적으로 작업이 끝난 경우 복구할 파일들에 대한 전체적인 목록을 볼수 있다.
$ vi +38 filename 
$ vi -c 38 filename
$ vi +/"school" filename 편집작업에 들어갈 때 특별한 명령어를 수행하면서 시작하는 경우 사용한다. 

									예) vi +38 filename(38번째 라인부터 시작)
									    vi -c 38 filename(위와 같은 의미)
									    vi +/"school" filename (school 단어가 있는 라인부터 시작)
```

```bash
# vi -L/* fedora 사용자가 작업중 파일이 비정상 종료 (작업중 shutdown) */
Swap files found:
   In current directory:
      -- none --
   In directory ~/tmp:
      -- none --
   In directory /var/tmp:
1.    file1.swp
          owned by: fedora   dated: Thu Feb 11 09:47:26 2010
         file name: /test/file1
          modified: YES
         user name: fedora   host name: linux200
        process ID: 24710
   In directory /tmp:
      -- none --
# ls -l /var/tmp/* 비 정상 종료된 파일의 목록이 보임 */
total 12
-rw------- 1 fedora fedora 12288 Feb 11 09:47 file1.swp
# vi -r /var/tmp/file1.swp
linux
# vi +/"fedora" /etc/passwd
# vi +30 /etc/passwd
# cat > /test/file1
Linux
Vi Editor
<Ctrl + D>
# su - fedora/* 사용자 전환 */
$ vi –R /test/file1/*
Linux
Vi Editor
[본인 이름 입력]
:wq!                     /* 저장 안됨 q! 로 빠져나옴 */
```

### 기본 작업 테스트

----

```bash
# cd /test
```

filename이라는 파일로 기본 틀 생성

## VI의 세가지 모드 변경 방법

---


![vi 세가지 모드](https://user-images.githubusercontent.com/56914461/100822740-3f7fa200-3496-11eb-9003-1cf68c429e9e.png)

vi 편집기에서는 3가지 모드가 지원된다. 명령행 모드(Comand Mode). 입력행 모드(Input Mode), 최하위행(라인) 모드(Last Line Mode)가 지원이 된다. 명령행 모드는 편집작업 및 기타 명령어를 입력할 수 있는 모드이고 입력행 모드는 입력만 할 수 있는 모드이다. 최하위행(라인) 모드는 저장 및 기타 검색 작업등을 할 수 있는 모드이다.

vi 실행후 집입 첫 단계 : 명령모드

- [ ] **Command Mode(Edit Mode)**	        키 입력을 명령어로 해석 ( 키보드의 키가 기능키로서 동작을 한다.)
- [ ] **Input Mode(Insert Mode)**	        키 입력을 파일에 입력, 명령모드에서 입력모드로 전환, 텍스트를 입력하여 컨텐츠를 생산
- [ ] **Last Line Mode(Ex Mode)**		ex 명령어를 수행, 파일에 대한 제어

저장, 나가기, 다른 파일로 저장.. 치환, **vi 내에서 쉘 명령어 입력**

vi가 모드를 지원하는 이유 : 키보드 자판

```bash
# vi < vi 실행
--------------------------------------
:q<Enter>    exit
:q!          빠져나가기
--------------------------------------
# vi filename
i       > 파일 붙여넣기
esc
:wq     > 저장하고 빠져나오기
:w      > 저장
:q      > 빠져나오기
:wq!    > 강제 저장 후 빠져나오기
--------------------------------------
:set nu > 라인 넘버 나타내기
:3      > 해당 라인으로 이동
4gg     > 해당 라인으로 이동
gg      > 첫번째 라인으로 이동 (= 1gg)
shift+g > 마지막 라인으로 이동
--------------------------------------
/linux  > linux 글자 검색
	    n > 다음 linux 검색
shift+n > 이전 linux 검색
--------------------------------------
yy      > 커서 라인 복사
2yy     > 두 라인 복사
p       > 커서 라인 아래 라인에 붙여넣기
--------------------------------------
!cmd    > vi 편집기를 빠져나가지 않고 cmd 명령어 입력
	ex) !ls -l, !date
```

### 입력행 모드 ((Input Mode)

----

```bash
vi 편집기 실행시 기본 모드는 명령행 모드이다. 명령행 모드에서 입력을 하기 위해서는 입력행 모드로 전환해야 한다. 이런 경우 다음과 같은 문자를 통해 입력 모드로 전환할 수 있다.
• a, A, i, I, o, O

▶ Insert
- i : 현재 커서 위치로부터 입력한다.
- I : 현재 커서가 있는 행의 처음부터 입력한다. 

▶ Append
- a : 현재 커서 위치 이후부터 입력한다.
- A : 현재 커서가 있는 행의 마지막부터 입력한다.

▶ Open Line 
- o : 현재 커서가 있는 아래행부터 입력한다.
- O : 현재 커서가 있는 위행부터 입력한다.
```

```bash
# vi filename
Input : k, j

Input : i

File Contents 
============================
hello
hello linux
Welcome To My Server!!!
hello linux
soldesk linux CentOS
Have a Good Time !!

============================

2 line : linux -> liNux

move -> delete -> insert -> save & quit

(1). move
h, j, k, l
← ↓ ↑ →

(2). delete
x, dd
4x   입력 시 커서부터 오른쪽 문자 4개 삭제
dd   라인 삭제
2dd  입력 시 두 개 라인 삭제
dw   단어 단위로 삭제

(2-1). undo
u

(2-2). redo
ctrl + r

(3). input
i

(4). save & quit
**shift + :**

: w!
: wq      /* w: write, q: quit */
: q!
: wq!

(5). verification
[TERM1]
# vi filename 

[TERM2]
# cd /test 
# cp /etc/services /test 
# vi services

: set number   (: set nu) 파일의 LINE번호를 붙여 표시해준다
: set nonumber (: set nonu)

: 30     (30G)    nG특정 LINE으로 이동한다
/ftp -> n -> N
```

### 명령행 모드(Command Mode)

----

![명령모드](https://user-images.githubusercontent.com/56914461/100822747-41496580-3496-11eb-8c62-ccd2ea932fbb.png)

**이동(Move)**

```bash
■ 좌우 이동 : (h, l), (w, b), (0(^), $)
■ 상하 이동 : (j, k), (<CTRL + F>, <CTRL + B>), (H, L), (G, nG, 1G)

[참고] :5 (=5G), :10 (=10G), 5, 10

▪ h: 한 문자 왼쪽으로 이동(←)
▪ l: 한 문자 오른쪽으로 이동(→)
▪ w: 한 단어 오른쪽으로 이동
▪ b: 한 단어 왼쪽으로 이동

▪ 0(^): 라인의 처음 문자(라인의 처음)으로 이동
▪ $: 라인의 마지막으로 이동

▪ j: 한 문자 아래로 이동(↓), 다음 라인으로 이동
▪ k: 한 문자 위로 이동(↑), 이전 라인으로 이동

▪ <CTRL + F>: 다음 페이지로 이동
▪ <CTRL + B>: 이전 페이지로 이동

▪ H      : 현재 페이지의 가장 첫번째 줄로 이동
▪ L      : 현재 페이지의 가장 마지막 줄로 이동

▪ 1G: 문서의 첫 번째 라인으로 이동 ( gg )
▪ G: 문서의 마지막 라인으로 이동
```

**삭제(Delete)**

```bash
■ 좌우 삭제: x, dw, (d0, d$), dd 
■ 상하 삭제: dd, 3dd, (:1,3d), (dG, d1G) 

[참고] dd(=D), 3dd(=3D)

▪ x: 현재 커서 한 글자 삭제
▪ dw: 현재 커서 앞의 한 단어 삭제
▪ db     : 현재 커서 뒤로 한 단어 삭제
▪ d0/d^: 현재 커서부터 라인의 처음까지 삭제
▪ d$: 현재 커서부터 라인의 마지막까지 삭제
▪ dd: 현재 라인 삭제

▪ 3dd: 현재 커서 라인을 포함해서 아래로 3개 라인 삭제
▪ :1,3d: 1번째 라인부터 3번째 라인까지 삭제

▪ dG: 현재 커서 라인부터 문서 마지막까지 삭제
▪ d1G: 현재 커서 라인부터 문서 처음까지 삭제
```

**Undo**

```bash
■ u, U
▪ u: 바로 이전에 상태로 되돌림
▪ U: 라인전체에 대해 이전 상태로 되돌림
```

**Join Line**

```bash
■ J
▪ J: 현재라인에 아래 라인 붙이기
```

**Replace**

```bash
■ r, R
▪ r: 현재 글자를 대치
▪ R: <ESC>키를 누르기 전까지 연속으로 현재 글자 대치
```

### 최하위행(라인) 모드(Last Line Mode)

----

**복사/붙이기(Copy/Yank & Paste)**

```bash
■ yy(=Y), 3yy(3Y), p or P
■ :1,3 co 5 
■ :1,3 m 5

▪ yy: 현재 라인 복사(Yank)
▪ 3yy: 현재 커서 라인 포함해서 하위의 3개의 라인 복사
▪ :1,3 co 5: 첫 번째 라인부터 3번째 라인까지 복사하여 5번째 라인 아래에 붙이기
▪ :1,3 m 5: 첫 번째 라인부터 3번째 라인까지 5번째 라인 아래에 이동하기

▪ p : 현재 커서 아래에 붙이기
▪ P: 현재 커서 위에 붙이기
```

**검색(Search)**

```bash
■ /New,n or N 
■ ?Newn or N

▪ /New: 현재 커서 라인부터 찾으려는 문자열(예: New) 검색
▪ ?New: 문서의 마지막 라인부터 찾을려는 문자열(예: New) 검색

▪ n: n(Next), 정방향다음번째 검색
▪ N: N(Next), 역방향으로 다음번째 검색

/ 정방향 검색 
? 역방향 검색
```

**저장 & 종료 (Save & Quit)**

```bash
■ :w/* w(write), 현재 파일에 저장 하기 */
■ :w filename/* 다른 이름으로 저장 하기 */ 
■ :w!(root use)  /* 현재 파일에 강제적으로 저장 하기 */
■ :w! file       /* 현재까지의 변경사항을 file로 저장 */
■ :3,10w file    /* 3번째 라인부터 10번째 라인까지 file로 저장 */
■ :q             /* q(quit), 편집기 종료 */ 
■ :q!            /* 저장 안하고 편집기 종료 */
■ :wq/* 저장하고 편집기 종료 */
■ :wq!(root Use)/* 현재 파일에 강제적으로 저장하고 편집기 종료 */
■ :r file        /* file의 내용을 현재 커서 위치에서 읽어 들임 */
■ :!CMD          /* vi 편집기를 빠져나가지 않은 상태에서 쉘 명령어를 수행 */
```

[참고] 저장하고 빠져나가기(Save & Quit)의 여러가지 방법

```bash
■ :x
■ :wq
■ ZZ
```

[참고] vi 편집기 실행에 대해서

```bash
[TERM1] # vi filename
: wq!
        # cat filename
[TERM2] # vi services
: q!
        # cat services
```

## 치환작업

---


- 검색 바꾸기

  ```bash
  : %s/<검색문자열>/<치환문자열>/g
  
  : %s/hello/HELLO/g
  
  : 1,$s/hello/HELLO/g
  
  : 5,10s/HELLO/hello/g
  
  : 5,10s/&/ /
  
  : 5,10s/^ //
  ```

- 특수문자 사용시 \(역슬래시)기호를 앞에 삽입

### 검색/바꾸기(Search & Replace)

----

```bash
■ :%s/<찾을문자열>/<바꿀문자열>/g 
■ :5,10s/Old/New/g
```

[참고] “<찾을 문자열>”에는 “정규 표현식”을 사용할 수 있다.

```bash
EX) :%s/hello/HELLO/g 
     1,$ => :5,10s/HELLO/hello/g 
     search(substitution)
     globally => %s/hello/HELLO/ , %s/hello/HELLO/g

EX) :5,10s/^/#/                           /* 주석처리 */
    :5,10s/^#//                           /* 주석해제 */

    :5,10s/^/    / (4 blank character)    /* 들여쓰기 */
    :5,10s/^    //                        /* 내어쓰기 */

▪ :%s/hello/HELLO/g: 문서 전체에서 hello를 검색해서 HELLO로 변환
▪ :1,$s/hello/HELLO/g: 문서 전체에서 hello를 검색해서 HELLO로 변환
▪ :5,10s/^/#/: 5번째 라인부터 10번째까지 라인의 처음부분에 ‘#’처리

■ 특수문자를 변경하는 방법
특수문자는 문자 앞에 역슬래쉬 기호를 추가해야 한다
/를 $ 로 변경
:%s/\//\$/g
```

## VI 편집기 환경파일 설정

---


vi 편집기의 동작하는 기능을 변경하기 위해서는 set 명령어를 사용한다. set 명령어 다음에 all을 사용하면 현재 편집기에 사용가능한 모든 기능변수들에 대한 현재 설정값을 표시한다.

vi 편집기의 기능을 현재 실행되는 편집 화면에서만 변경하기 위해서는 최하위행 모드에서 다음과 같은 방법을 사용한다.

```bash
# cd /test 
# vi filename
: set all       (Last Line Mode)
: set number    (: set nu)
: set nonumber  (: set nonu)
--- Options ---
  ambiwidth=single  nohidden            nopreserveindent      termencoding=
noautoindent          history=50          prompt            noterse
noautoread          nohlsearch          noreadonly            textauto
noautowrite         noignorecase          remap             notextmode
noautowriteall        iminsert=0          report=2            textwidth=0
  background=light    imsearch=0          scroll=23         notildeop
nobackup            noincsearch           scrolljump=1        timeout
  backupcopy=auto   noinfercase           scrolloff=0         timeoutlen=1000
  backupext=~       noinsertmode        nosecure            nottimeout
  backupskip=/tmp/*   isprint=@,161-255   shell=/bin/bash     ttimeoutlen=-1
nobinary              joinspaces          shellcmdflag=-c     ttybuiltin
nobomb                keywordprg=man      shellquote=         ttyfast
  buflisted         nolazyredraw          shelltemp           ttyscroll=999
  cmdheight=1         lines=48            shellxquote=        ttytype=xterm
  columns=80        nolist              noshiftround          undolevels=1000
nocompatible          listchars=eol:$     shiftwidth=8        updatecount=200
nocopyindent          loadplugins       noshortname           updatetime=4000
  cpoptions=aABceFs   magic             noshowfulltag         verbose=0
  debug=              matchtime=5       noshowmatch           verbosefile=
nodelcombine          maxcombine=2        showmode          novisualbell
  display=            maxmapdepth=1000    sidescroll=0        warn
noedcompatible        maxmem=257666       sidescrolloff=0   noweirdinvert
  encoding=utf-8      maxmemtot=257666  nosmartcase           whichwrap=b,s
  endofline         nomodeline          nosmarttab            wildchar=<Tab>
  equalalways         modelines=5         softtabstop=0       wildcharm=0
  equalprg=           modifiable          startofline         wildignore=
noerrorbells          modified            swapfile            wildmode=full
  esckeys             more                swapsync=fsync      window=47
noexpandtab           mouse=              switchbuf=          wrap
noexrc                mousemodel=extend   tabstop=8           wrapmargin=0
  fileencoding=       mousetime=500       tagbsearch          wrapscan
  fileformat=unix   nonumber              taglength=0         write
  formatoptions=tcq   operatorfunc=       tagrelative       nowriteany
..... (중략) .....

: set tabstop=10/* 탭간격 조정 */
: set nu/* 라인 번호 달기 */
: set noshowmode/* 상태표시행에 모드를 표시하거나 표시하지 않거나를 설정 */
: set directory=/tmp /* 지정된 기능 변경 */
```

[참고] VIM 편집기의 환경 설정 파일

```bash
■ 사용자 정의 $HOME/.vimrc 파일 생성
# vi ~/.vimrc   (# vi ~/.exrc)
set number
# vi /etc/passwd
			1 root:x:0:0:root:/root:/bin/bash
      2 bin:x:1:1:bin:/bin:/sbin/nologin
      3 daemon:x:2:2:daemon:/sbin:/sbin/nologin
      4 adm:x:3:4:adm:/var/adm:/sbin/nologin
■ $HOME/.vimrc 파일의 샘플 파일 생성
# cp /usr/share/vim/vim70/vimrc_example.vim ~/.vimrc 

■ VIM 편집기 참고 파일(VIM 편집기 사용법 문서)
# vi /usr/share/vim/vim70/tutor/tutor.ko.ufs-8 

■ VIM 편집기의 Plugin 모음들
http://saelly.tistory.com/296 
http://ethanschoonover.com/solarized
```

## 파일의 퍼미션 변경

----

![chmod](https://user-images.githubusercontent.com/56914461/100826886-b751ca80-349e-11eb-919f-f575798a95b8.png)

### chmod 명령어

------

파일이나 디렉토리를 새로운 권한으로 변경하는 명령이다. 파일의 소유자나 관리자만이 chmod를 사용할 수 있으며 파일의 소유자, 파일의 그룹, 다른 사용자로 나누어 각각의 권한을 설정 할 수 있다.

```bash
# ls -l file1 
-rw-r--r-- 1 root root 0 Jan 10 12:43 file1
```

**[명령어 형식]**

```bash
# chmod u+x file1 
# chmod 755 file1
```

- [ ]  퍼미션(Permission)을 변경하는 방법
- 심볼릭 모드(Symbolic Mode) : **# chmod u+x file1**
- 옥탈 모드(Octal Mode) : **# chmod 744 file1**

**[1] 심볼모드(symbolic mode)를 이용한 권한 변경**

[사용자 기호]

```bash
기호                       설명
u      user           파일/디렉토리의 소유자
g      group          파일/디렉토리의 그룹
o      other          다른 사용자 
a      all            소유자, 그룹, 다른 사용자 모두(아무 표시 안할 경우 기본적으로 설정됨)
```

[설정 기호]

```bash
기호                        설명
+       퍼미션 허가       지정한 퍼미션을 허가한다.
-       퍼미션 금지       지정된 퍼미션을 금지시킨다.
=       퍼미션 지정       지정한 퍼미션만 허가하고 나머지는 금지 시킨다.
                       설명 : 이전에 권한을 어떻게 줬던 지금 설정해주는 권한으로 대체시켜서 사용 가능
                       (+,-는 내가 이전에 어떠한 권한을 설정해 줬는지 확인해야 하지만 
                       =는 이전에 어떻게 설정하였던 상관없이 설정이 가능한 것이다.)
```

[권한 기호]

**r        w        x** 

read write excute

```bash
R 읽기 권한
	파일을 읽기 위한 권한이며 나머지 두 개의 권한을 설정 할 경우 (필수적으로) 필요하다.
W 수정 권한
	파일을 수정하기 위한 권한이며 필수적으로 읽기권한이 필요하다.
X 실행 권한
	파일을 실행하기 위한 권한이며 필수적으로 읽기권한이 필요하다.

모든 권한에서 우선권한으로 읽기 권한이 있어야 나머지 두 권한(w,x)을 정상적으로 사용할 수 있다.
```

설명 : 읽기 권한이 없으면 파일 안에 있는 내용을 볼 수 없다. 따라서 파일을 수정하기 위해서는 반드시 read권한을 부여해야지 파일을 열어서 보고 수정 할 수가 있는 것이다. 만약에 write권한만 있다면 파일을 열어 볼 수 없으므로 수정이 불가능 한 것이다. 따라서 파일을 수정하려면 read&write권한이 모두 있어야 한다.

```bash
# ls -l file1 
-rw-r--r-- 1 root   fedora    0 Aug 17 16:06 file1

# chmod  u + r  file1 
         g - w
         o = x
         a
심볼의 정의
u(User)
g(Group)
o(Other)
a(all)

+(Add)
-(Deny)
=(equal)

r(Read)
w(Write)
x(Excute)
```

**심볼 모드를 사용한 퍼미션 변경**

```bash
# cd /test 
# rm -rf /test/* 

# touch file1 
# ls –l file1
-rw-r--r-- 1 root root 0 Feb 14 11:12 file1

# chmod u+x file1
# ls –l file1
-rwxr--r-- 1 root root 0 Feb 14 11:12 file1*
/* 실행파일이 되면 ls 입력시 초록색으로 보임 */

# chmod g-r file1
# ls –l file1
-rwx---r-- 1 root root 0 Feb 14 11:12 file1*

# chmod u-x,g+x file1
# ls –l file1
-rw---xr-- 1 root root 0 Feb 14 11:12 file1*

# chmod a=rwx file1 
# ls –l file1

-rwxrwxrwx 1 root root 0 Feb 14 11:12 file1*
```

**[2] 수치모드(octal mode)를 이용한 권한 변경**

```bash
소유자권한비트  그룹권한비트  기타권한비트
r  w  x     r  w  x    r  w  x
1  1  1     1  1  1    1  1  1
4  2  1     4  2  1    4  2  1
```

파일 소유자 권한 : 400 = 읽기 권한, 200 = 쓰기 권한, 100 = 실행 권한 그룹 사용자 권한 : 40 = 읽기 권한, 20 = 쓰기 권한, 10 = 실행 권한 기타 사용자 권한 : 4 = 읽기 권한, 2 = 쓰기 권한, 1 = 실행 권한

```bash
--- : 권한 없음 0           000
--x : 실행 권한 1           001
-w- : 쓰기 권한 2           010
-wx : 쓰기 실행 3           011
r-- : 읽기 권한 4           100
r-x : 읽기 실행 5           101
rw- : 읽기 쓰기 6           110
rwx : 읽기 쓰기 실행 7       111
# chmod 744 file1   (rwxr--r--)
```

```bash
권한에 대하여 더 자세히
+-----------------------------+
+--------------+              |
+-----+        |              |
|user |  group |     other    |
+-----+        |              |
+--------------+              |
+-----------------------------+

권한은 4자리다.
s r w x
_ _ _ _

배포판별로 사용방식이 약간 다르다.
특정 배포판들은 권한을 부여하는 경우에 무조건 4자리를 설정

5자리 : 8bit -> 16bit -> 32bit -> 64bit 
5번째 자리 : 커널비트, 커널에서 종종 사용하는 비트 : 시스템이 더 커질 경우를 대비하여 미리 임시로 공간을 부여
network packet > 8bit
k s r w x
_ _ _ _ _ 
```

**Octal Mode 실습**

```bash
# cd /test ; rm –rf /test/*
# touch file1 
# ls -l file1
-rw-r--r-- 1 root root 0 Feb 14 11:20 file1
# chmod 744 file1
# ls –l file1
-rwxr--r-- 1 root root 0 Feb 14 11:20 file1*
# chmod 754 file1 
# ls –l file1
-rwxr-xr-- 1 root root 0 Feb 14 11:20 file1*
```

컴퓨터는 3개 동작 밖에 하지 못한다.

[입력] - [연산] - [출력]

디렉토리 : 파일과 디렉토리를 담는 저장소

스토리지 : 데이터, 어딘가에 저장되어 있는 데이터, 블록

유저가 디렉토리에서 할 수 있는 것 :

```bash
디렉토리로 입장 : cd
디렉토리에 있는 컨텐츠 확인 : ls
디렉토리에 있는 컨텐츠 형식 확인 : file
특정 파일 자세히 확인하기 : cat, stat...

복사, 삭제, 이동, 이름 변경 등등

실행
```

디스크 : 유저가 어떠한 명령어를 통하여 디스크로 **접근**

실제 파일이 저장되어 있는 디스크 의 어딘가에 있는 물리적 주소로 접근

## 파일과 디렉토리 퍼미션의 정확한 의미

------

![파일과 정확한 의미](https://user-images.githubusercontent.com/56914461/100832048-69db5a80-34aa-11eb-9285-8ca102b7aeb4.png)

디스크 권한:

```bash
R    디렉토리에 있는 ls 명령어 수행 권한
	   디스크에 존재하는 , 디렉토리에 존재하는 inode 번호를 가지고, inode의 특정한 정보를 출력
W    디렉토리 안의 파일들의 생성과 삭제를 할 수 있는 권한
	   디스크 블럭을 사용자가 사용할 수 있는가?
	   cp, : 블럭 추가
	   rm, : 블럭 제거
X    디렉토리 내부로의 cd 명령어를 수행할 수 있는 권한
	   디스크에 존재하는 디렉토리의 inode를 이용하여 실제로 해당 영역에 접근 할 수 있는가?
```

```bash
(파일과 디렉토리의 퍼미션의 정확한 의미)

----------------------------------
파일 디렉토리
----------------------------------
r (ls CMD)
w (생성 & 삭제)
x (cd CMD)
----------------------------------
```

[TERM1] fedora 사용자 터미널

```bash
# ssh fedora@localhost
fedora 사용자로 로그인

$ ls -ld /home/fedora
drwx------. 3 fedora fedora 115  6월 25 18:19 /home/fedora
$ mkdir dirtest 
$ touch dirtest/test2.txt 
$ ls -lR
.:
합계 0
drwxrwxr-x. 2 fedora fedora 23  6월 26 10:09 dirtest

./dirtest:
합계 0
-rw-rw-r--. 1 fedora fedora 0  6월 26 10:09 test2.txt
```

[TERM2] user01 사용자 터미널

```bash
# ssh user01@localhost
user01 사용자로 로그인

$ cd ~fedora           ($ cd /home/fedora)
-bash: cd: /home/fedora: 허가 거부

drwx------ 7 fedora fedora ..... /home/fedora
                      A       A
                      |       |
                      V       V
                   user01 user01

$ id fedora 
$ id user01
$ cd ~fedora/dirtest   ($ cd /home/fedora/dirtest)
-bash: cd: /home/fedora/dirtest: 허가 거부
-> 하위디렉토리에 접근 권한이 있더라도 상위 디렉토리에 접근 불가하므로 하위디렉토리인 dirtest 디렉토리도 접근 불가
$ rm -f ~fedora/dirtest/test2.txt   ($ rm -f /home/feodra/dirtest/test2.txt)
rm: cannot remove '/home/fedora/dirtest/test2.txt': 허가 거부
```

[TERM1] fedora 사용자 터미널

```bash
$ id
uid=1001(fedora) gid=1001(fedora) groups=1001(fedora) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
$ chmod 757 /home/fedora 
$ ls -ld /home/fedora
drwxr-xrwx. 4 fedora fedora 130  6월 26 10:08 /home/fedora
$ chmod 755 dirtest 
$ touch dirtest/test3 
$ chmod 646 dirtest/test3 
$ ls -lR
.:
합계 0
drwxr-xr-x. 2 fedora fedora 36  6월 26 10:15 dirtest

./dirtest:
합계 0
-rw-rw-r--. 1 fedora fedora 0  6월 26 10:09 test2.txt
-rw-r--rw-. 1 fedora fedora 0  6월 26 10:16 test3
/home/fedora (rwxr-xrwx fedora fedora)
      |
      +----- dirtest (rwxr-xr-x fedora fedora)
      |
      +----- test3 (rw-r--rw- fedora fedora)
```

[TERM2] user01 사용자 터미널

```bash
$ id
uid=1002(user01) gid=1002(user01) groups=1002(user01) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
$ cd ~fedora       ($ cd /home/fedora)
$ cd dirtest 
$ rm -f test3
rm: cannot remove 'test3': 허가 거
$ mkdir dirtest1
mkdir: `dirtest1' 디렉토리를 만들 수 없습니다: 허가 거부
```

[TERM1] fedora 사용자 터미널

```bash
$ id
uid=1001(fedora) gid=1001(fedora) groups=1001(fedora) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
$ chmod 757 dirtest 
$ ls -lR
.:
합계 0
drwxr-xrwx. 2 fedora fedora 36  6월 26 10:15 dirtest

./dirtest:
합계 0
-rw-rw-r--. 1 fedora fedora 0  6월 26 10:09 test2.txt
-rw-r--rw-. 1 fedora fedora 0  6월 26 10:16 test3

/home/fedora (rwxr-xrwx fedora fedora)
      |
      +----- dirtest (rwxr-xrwx fedora fedora)
      |
      +----- test3 (rw-r--rw- fedora fedora)
```

[TERM2] user01 사용자 터미널

```bash
$ id
uid=1002(user01) gid=1002(user01) groups=1002(user01) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
$ rm –f test3 
$ touch test4.txt
$ ls -l
합계 0
-rw-rw-r--. 1 fedora fedora 0  6월 26 10:09 test2.txt
-rw-rw-r--. 1 user01 user01 0  6월 26 10:17 test4.txt
```

### umask 명령어

--------

![umask](https://user-images.githubusercontent.com/56914461/100832058-6ea00e80-34aa-11eb-9e95-2486601cd52f.png)

파일이나 디렉토리 생성시에 파일과 디렉토리에는 기본적으로 적용되는 퍼미션이 있다. 기본적으로 설정되는 퍼미션의 경우 umask에 의해 결정이 된다. umask는 디렉토리와 파일의 기본 퍼미션을 결정해주는 명령어이다.

[기본 퍼미션(Default Permission) 변경]

```bash
                     파일 디렉토리
Default Permission   666 777
umask                022 022
생성 기본퍼미션          644 755
```

```bash
			     file / dir
default    666    777
umask    - 000    000
         = 666    777
rw-rw-rw-
umask set 111
  1         1        1    < 해당 자리의 권한을 삭제한다
|4|2|1|  |4|2|1|  |4|2|1|

ex) file1, dir1 <= umask 111
-rw-rw-rw-
drw-rw-rw-
ex) file2, dir2 <= umask 222
-r--r--r--
dr-xr-xr-x
ex) file3, dir3 <= umask 333
-r--r--r--
dr--r--r--
ex) file4, dir4 <= umask 444
--w--w--w-
d-wx-wx-wx
ex) file0, dir0 <= umask 027
-rw-r-----
drwxr-x---
```

umask를 이용하여 기본 권한을 편집하여 파일 및 디렉토리를 생성할 때 권한을 전체 다 부여하는 것이 아니라 몇몇 권한을 제거하고 파일, 디렉토리를 생성할 수 있다.

디렉토리 생성시 기본적으로 등록되는 권한 부여에 대하여 변경 해주는 기능

[명령어 형식]

```bash
# umask 
# umask 027
# umask 022
```

**umask 간단한 실습**

```bash
# cd /test 
# rm –rf /test/* 

# umask
0022
# touch file1 
# mkdir dir1 
# ls –l
-rw-r--r-- 1 root root    0 Feb 11 10:45 file1
drwxr-xr-x 2 root root 4096 Feb 11 10:47 dir1

(666 - 022 = 644)
(777 - 022 = 755)

■ Default Permission
File  Directory
-------------------------------------------
666 777 666 777
022 022 027 027
-------------------------------------------
644 755 640 750

# umask 002 
# umask
0002
# touch file2 
# mkdir dir2 
# ls –ld *2
drwxrwxr-x 2 root root 4.0K Feb 14 12:04 dir2/
-rw-rw-r-- 1 root root    0 Feb 14 12:04 file2

■ Default Permission
File  Directory
------------------
666 777
002 002
------------------
664 775

# umask 027 
# umask
0027

# touch file3 (666 - 027 = 640)
# mkdir dir3  (777 - 027 = 750)
# ls –ld *3
drwxr-x--- 2 root root 4.0K Feb 14 12:05 dir3/
-rw-r----- 1 root root    0 Feb 14 12:05 file3

■ Default Permission
File Directory
------------------
666 777
027 027
------------------
640 750
```

**/etc/bashrc 파일에 등록된 umask 확인**

```bash
(관리자) /etc/bashrc
(사용자) $HOME/.bashrc

# cat /etc/bashrc
..... (중략) .....
    # By default, we want umask to get set. This sets it for non-login shell.
    # You could check uidgid reservation validity in
    # /usr/share/doc/setup-*/uidgid file
    if [ $UID -gt 99 ] && [ "`id -gn`" = "`id -un`" ]; then
       umask 002
    else
       umask 022
    fi
..... (중략) .....
-> umask 확인
```

## SetUID / SetGID

------

파일에 대한 소유권을 잠시 다른 사용자에게 빌려 줌으로 인해 소유권이 없는 사용자가 잠시 동안 파일에 대한 소유권으로 권한을 행사 할 수 있는 것을 말한다.

공유한 디렉토리나 파일에 대한 특별한 퍼미션을 부여하는 것으로서 파일 소유자(owner)나 superuser만이 파일에 대해서는 setuid와 setgid를 설정하고,디랙토리에 대해서는 sticky-bit 퍼미션을 설정 할 수 있다.

absolute mode (octal mode)나 symbolic mode를 사용하여 지정하거나 해지할 수 있다.

제 3의 계정 other

​	소유자나, 그룹소유자의 권한을 임시로 빌려 파일, 디렉토리를 사용하기 위한 용도.

![setuid](https://user-images.githubusercontent.com/56914461/100846198-8fc02980-34c1-11eb-9440-9ef873fdce0c.png)

![IMG_3340](https://user-images.githubusercontent.com/56914461/100848886-1aeeee80-34c5-11eb-8b0e-558188cc84d5.PNG)

📝 1주차 테스트 !

1. 리눅스에서는 CLI를 좀 더 많이 사용합니다. 이 이유는 무엇인지 작성합니다.

```bash
네트워크 자원 등을 적게 소모한다.
```

2. 사용자 계정 및 그룹 파일에 관련한 파일들을 작성합니다.

```bash
man 파일을 얼마나 열어 봤느냐?
/etc/passwd
/etc/group
/etc/shadow
```

3. bash shell에서 사용하는 제어 문자중에 CTRL+C CTRL+D CTRL+U에 대하여 각각 서술합니다.

```bash
^c : 강제 종료. 현재 실행중인 프로그램을 강제종료하여 쉘을 다시 사용가능한 상태로 만들기 위한 기능키
^d : EOF, shell 종료 (mail, cat)
		 GUI 그래픽 툴 종료
		 CLI 로그아웃
^u : 현재 라인을 클리어
```

4. 암호를 변경하는 경우 passwd 명령어를 사용합니다. root 계정과 일반 사용자 계정이 비밀번호 변경시 다른점을 서술합니다.

```bash
root        : 모든 비밀번호를 교체 가능, 이전 비밀번호를 묻지 않는다.
일반 사용자  : 자신의 비밀번호를 교체, 다른 계정의 비밀번호를 변경 하기 위해서는 su 로그인 필요. 이전 비밀번호를 알아야 변경이 가능하다
```

5. 절대 경로 / 상대 경로에 대하여 설명합니다.

```bash
절대 경로 : 시작점이 최상위 디렉토리에서 출발하여 원하는 경로까지 가는 경로
상대 경로 : 시작점이 현재 디렉토리에서 출발하여 원하는 경로까지 가는 경로
```

6. 디렉토리에 존재하는 .과 .. 에 대하여 설명합니다.

```bash
.  : 현재 디렉토리를 표시, 쉘 내에서 현재 디렉토리에서 실행파일을 실행할 때 ./ 형태로 사용, 현재 디렉토리의 권한 변경, 디렉토리의 출력
.. : 현재 디렉토리의 상위 디렉토리 표시, 이동하는 경우 cd .. 
```

7. vi 편집기를 사용하는 이유를 설명합니다.

```bash
제일 많이 분포되어 있는 편집기
모든 유닉스, 리눅스 시스템에 기본적으로 설치 되어 있기 때문에 이것 하나만 잘 알고 있으면 어떤 시스템이든 편집기를 쓰지 못하는 불편함은 없다.
```

8. 링크파일 과 심볼릭 링크 파일의 차이점을 설명합니다.

```bash
하드링크   : 동일한 데이터 블럭을 공유하는 파일, 한쪽에서 삭제하더라도 다른쪽에서 계속 접근할 수 있다.
						 링크 카운트의 변화
심볼릭링크 : 바로가기 파일. 파일 형식이 1로 표시. 권한이 rwxrwxrwx로 표현된다. 하지만 실제 파일의 권한을 따른다.
```

9. 일반 파일과 디렉토리의 권한 차이를 설명합니다.

```bash
일반 파일     : 읽기, 쓰기, 실행의 권한이 있으며 이 파일을 제어하는데 사용
디렉토리 파일 : 읽기, 쓰기, 실행의 권한이 있으며 이 디렉토리에 접근하여 파일을 확인하거나 삭제, 복사 등 디스크에 접근하여 작업을 할 수 있는지 없는지 등의 권한 유무
```

# Systemd와 Init

init > systemd 로 넘어왔다.

### Init

과거에는 프로세스였고 현재는 서비스 형태이다. 

스크립트이다 → 무조건 순서대로 실행하는 단점 (부팅 시 실행해야 하는 프로그램이 50개라면 부팅이 오래 걸린다)

DHCP와 관계가 불편했다. 

### systemd

데몬. 결국엔 프로세스이다.

병렬화 되어 부팅한다.

당장 필요없는 서비스는 우선순위를 뒤로 미뤄서 실행한다.

네트워크를 사용할 수 없을 때 네트워크 서비스(DHCP 등)의 순위를 미뤄버린다.

# DNS(Domain Name System)

모든 인터넷 서비스의 근간으로 네트워크에서 가장 중요한 서비스중 하나이다.

인터넷 도메인 이름들의 위치를 알아내기 위한 IP 주소로 바꾸어주는 시스템이다.

컴퓨터는 숫자로 대화하기 때문에 문자를 숫자로. 즉 IP 주소로 변환 시켜주는 무언가가 필요하다 → DNS

DNS = 네임서버

호스트에 대한 판별을 하기 위해선 IP가 있어야 한다. 특정 인터페이스로 들어가기 위해. 이 때 필요한 것이 DNS이다.

모든 사용자들은 인터넷 서비스 공급자(ISP : KT, SKT, LG)가 제공하는 자신을 위한 DNS 서버가 존재함을 확인할 수 있다.

의미있는 이름을 IP로 변환해주는 서비스

### 도메인을 사용하는 이유

숫자보다 기억하기가 용이하다! (203.12.145.78 < www.studylab.xyz) 

의미 부여가 가능하다.

보통의 DNS

고정 IP - 도메인 연결

DDNS

유동 IP - 도메인 연결

바뀔 때 마다 새로 업데이트 해줘야하는 단점이 있다.  따라서 IP 주소가 바뀌었을 때 변경된 IP를 가지고 자동으로 다시 업데이트 해주는 기능을 가진 것이 DDNS이다.

### URL

### IP

```bash
http     ://  www.  soldesk.com
protocol      host  domain
host   = 컴퓨터 이름. hostname
domain = 컴퓨터가 활동 가능한 영역. domainname
fqdn   = host + domain. 즉, www.soldesk.com
```

```bash
[].[].[].[] / 24
IP           subnet
[]안에는 0~255 숫자
```

네트워크, 호스트 구분하기 위해 서브넷이 필요하다.

### 도메인 이름 원칙

영문자, 숫자 조합

영문자로 시작해야하며 하이픈으로 끝날 수 없다.

각 길이는 단계별로 최소 2자~63자 (단계: 1단계 kr, 2단계 co, 3단계 soldesk)

컴마(,), 언더바(_) 기호 사용 불가능

전세계적으로 중복되지 않도록 고유해야 한다.

### ARPANet

DNS와 반대 동작을 한다. IP주소를 도메인 주소로 바꾸는 역할을 하는 역방향

### DNS 동작 방식

Domain에서 IP를 반환 받아오고 받아온 IP로 접속 요청을 한다.

DNS 서버들은 분산되어 있기 때문에 한번에 찾아오는게 아니라 각각 잘라서 모듈별로 찾아오고 도메인 자체도 워낙 많으니 도메인 주소도 하나로 이뤄져있지 않고 인덱스 별로 나열하여 찾아 들어가는 단계로 되어있다.

UDP로 동작한다. TCP에서 있는 확인 절차가 없기 때문. 

Port 53번을 사용한다.

도메인의 마지막에는 .이 있다. 사실상 www.example.com이 아니라 www.example.com. 이다. 생략되어 있다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4ca7628f-6310-427b-b294-724926a7ef10/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4ca7628f-6310-427b-b294-724926a7ef10/Untitled.png)

① 인터넷 웹 페이지에서 접속시도 (www.google.com) enter!

② DNS를 확인

③ 해당 DNS 서버로 이동

④ www|google|com 도메인의 IP주소를 얻기 위해 값을 이동

⑤ 최상위 DNS 서버(Root DNS)로 전달

⑥ 1차 도메인 목록인 .com에 대한 주소를 반환

⑦ google|com 에 대한 IP주소를 물음

⑧ [google.com](http://google.com) 주소를 반환

⑨ google.com주소에 www.google.com주소를 물음

⑩ www.google.com주소의 IP 주소값을 반환

⑾ FQDN(www.google.com)의 IP 주소값을 반환

⑿ IP주소로 접속

⒀ 응답

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c02b815c-b139-4d74-975d-9764480421ef/_2020-03-07__3.35.48.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c02b815c-b139-4d74-975d-9764480421ef/_2020-03-07__3.35.48.png)

인터넷 웹 페이지에서 접속 시도 → DNS Client의 DNS Cache Table을 확인하고 없는 경우 → host 파일 확인 → /etc/hosts 파일 확인 → /etc/resolv 파일 확인 (nameserver에 대한 IP가 있다)

DNS Client의 ~/etc/host.conf : 무엇을 먼저 확인할지

Cache Table : windows는 기본적으로 존재. 리눅스는 특정 서비스를 사용하여 캐시를 생성해야 한다.

① 확인한 nameserver의 IP로 찾아가 요청한다.

DNS Server도 자신의 Cache Table을 확인한다. DNS Client와 똑같은 작업을 한다. 자신에게 걸려있는 DNS Server를 본다. linux에는 hint파일이 있어 확인한다. hint파일에는 전세계 있는 .root 서버의 목록이 있다. 전세계에 13개 존재한다.

② .root 서버로 간다.

③ 1차 도메인 주소를 반환(.com)

 DNS Server의 Cache Table에 .com의 주소를 등록한다.

④ .com 주소로 찾아가 [www.example.com](http://www.example.com)의 IP주소 요청

⑤ 탐색하여 example을 찾고 example.com의 ip주소를 반환

DNS Server의 Cache Table에 example.com의 주소를 등록한다.

⑥ [example.com](http://example.com) 주소로 찾아가 www.example.com의 IP주소 요청

⑦ 네임서버 내부에는 zone파일이 있다. 매핑이 되어있다. 호스트가 www인 주소가 저장되어있다.

DNS Server의 Cache Table에 www.example.com의 주소를 등록한다.

⑧ [www.example.com](http://www.example.com)의 IP 주소를 반환한다.

DNS Client의 Cache Table에 [www.example.com](http://www.example.com)의 주소를 등록한다.

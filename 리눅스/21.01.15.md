POSIX ACL

# 액세스 제어 목록 개념

표준 Linux 파일 권한은 대부분의 상황에 적합하지만 제한이 있습니다. 파일에 대한 액세스를 제한하는 권한은 파일 소유자, 단일 그룹의 회원 또는 나머지 사람들에게 제한되어 있습니다. 프로세스(실행되는 프로그램)가 파일을 소유하는 그룹의 회원이 되는 것은 적절하지 않으며 모든 사람들에게 권한을 부여하는 것은 더욱 부적절합니다.

ACL에서는 파일에 세밀한 권한을 할당할 수 있습니다. 표준 파일 소유자, 그룹 소유자 및 기타 파일 권한 외에도 명명된 사용자와 명명된 그룹, UID나 GUID로 식별된 사용자와 그룹에 권한을 부여할 수 있습니다. 파일과 동일한 권한 플래그(**r** - read, **w** - write, **x** - execute) (디렉터리 검색)가 적용됩니다.

파일 소유자는 개별 파일 또는 디렉터리에 ACL을 설정할 수 있습니다. 새 파일과 하위 디렉터리는 상위 디렉터리에 default ACL(설정된 경우)에서 ACL 설정을 자동으로 상속할 수 있습니다. 일반 파일 액세스 규칙과 마찬가지로, 명명된 사용자와 명명된 그룹에서 액세스 권한을 가지려면 상위 디렉터리 계층에서 최소한 other 실행 권한이 필요합니다.

파일 시스템 마운트 옵션

파일 시스템은 ACL 지원을 활성화하여 마운트 해야 합니다. XFS 파일 시스템에는 기본적으로 ACL 지원이 포함되어 있습니다. Red Hat Enterprise Linux 7에서 생성된 ext4 파일 시스템은 **acl** 옵션이 기본적으로 활성화되지만 이전 버전의 Red Hat Enterprise Linux에서 설치 후에 생성된 ext4 파일 시스템은 마운트 요청으로 **acl** 옵션을 포함하거나 superblock에 설정해야 할 수 있습니다.

ACL 을 사용하려면 디스크에서 ACL 기능을 활성화 해줘야 한다. 마운트 필요

# ACL 권한 보기 및 해석

ls -l 명령은 최소한의 ACL 설정 정보만 출력합니다.

```bash
$ ls -l roster.txt
-rwxrw----+ 1 student controller 130 Mar 19 23:56 roster.txt

. ACL로 설정된 정보가 없다.
+ ACL로 설정된 정보가 있다.
```

10자 권한 문자열 끝에 있는 "**+**"는 이 파일과 관련된 ACL 설정이 있음을 나타냅니다. user, group,other "**rwx**" 플래그를 다음과 같이 해석합니다.

•user: 표준 user 파일 설정과 동일한 user ACL 설정, 즉, **rwx**를 표시합니다.
•group: group-owner 설정이 아닌 현재 ACL mask 설정, 즉, **rw**를 표시합니다.
•other: 표준 other 파일 설정과 동일한 other ACL 설정, 즉, 액세스 권한 없음을 표시합니다.

[참고]

chmod를 사용하여 ACL의 파일에서 그룹 권한을 변경할 경우 그룹 소유자 권한이 변경되는 것이 아니라 ACL 마스크가 변경되는 것입니다. 파일의 그룹 소유자 권한을 업데이트하려면 setfacl -m g::perms file을 사용하십시오.

### 파일 ACL 보기

파일의 ACL 설정을 표시하려면 **getfacl file**을 사용합니다.

```bash
[student@serverX steamies]$ getfacl roster.txt 
# file: roster.txt
# owner: student
# group: controller
user::rwx 
user:james:--- 
user:1005:rwx      #effective:rw-
group::rwx         #effective:rw-
group:sodor:r-- 
group:2210:rwx     #effective:rw-
mask::rw- 
other::---
=================================================
# getfacl file2
# file: file2   < 파일명
# owner: root   < 파일 소유자
# group: root   < 파일 그룹 소유자
user::rw-       < 소유자 자리가 비어 있다면 이는 기본 소유자를 뜻한다
user:team02:r-x < 소유자 자리가 채워져 있다면 인느 특정 소유자를 뜻한다
group::r--      < 
mask::r-x       <
other::r--      <
```

[설명 블로그](https://www.bangseongbeom.com/linux-acl-guide.html)

시작 주석 항목

```bash
# file: roster.txt 
# owner: student
# group: controller
```

처음 세 행은 파일 이름, 소유자(student), 그룹 소유자(controller)를 식별하는 주석입니다. 추가 파일 플래그가 있는 경우(예: setuid 또는 setgid) 설정된 플래그를 표시하는 네 번째 주석 행이 표시됩니다.

사용자 항목

```bash
user::rwx
user:james:---
user:1005:rwx #effective:rw-   < 소유자를 UID로 표기
```

파일 소유자 권한. **student**에 **rwx**가 있습니다.

명명된 사용자 권한. 이 파일과 연결된 명명된 사용자마다 하나의 항목이 있습니다. **james**에 권한이 없습니다.

명명된 사용자 권한. UID **1005**에 **rwx**가 있지만, 마스크는 유효 권한을 **rw**로만 제한합니다.

그룹 항목:

```bash
group::rwx #effective:rw- 
group:sodor:r--
group:2210:rwx #effective:rw-
```

그룹 소유자 권한. controller에 rwx가 있지만, 마스크는 유효 권한을 rw로만 제한합니다.

명명된 그룹 권한. 이 파일과 연결된 명명된 그룹마다 하나의 항목이 있습니다. sodor에는 r만 있습 니다.

명명된 그룹 권한. GID 2210에 rwx가 있지만, 마스크는 유효 권한을 rw로만 제한합니다.

⭐마스크 항목:

```bash
mask::rw-  < 소유자를 제외한 나머지 사용자들이 실제 사용 가능한 권한
```

마스크 설정은 모든 명명된 사용자, 그룹 소유자, 명명된 그룹에 가능한 최대 권한을 표시합니다. 각 항목 에 실행 권한이 설정되어 있는 경우에도 UID 1005, controller, GID 2210은 이 파일을 실행할 수 없습 니다.

특정한 파일에 마스크를 설정하게되면 그 이상 권한을 가진 소유자를 제외한 전체의 권한에 제한을 걸 수 있다.

기타 항목:

```bash
other::---
```

기타 또는 "범용" 권한. 나머지 UID 및 GID에는 권한이 없습니다.

### 디렉터리 ACL 보기

디렉터리의 ACL 설정을 표시하려면 getfacl /directory를 사용합니다.

```bash
[student@serverX steamies]$ getfacl . 
# file: .           < 디렉토리 명
# owner: student    < 소유자
# group: controller < 그룹 소유자
# flags: -s-        < setgid가 걸려있다.
user::rwx           < student 전체권한 
user:james:---      < 특정 유저(james) 권한
user:1005:rwx       < 1005번 UID를 가진 유저는 모든 권한을 가지고 있다.
group::rwx          < controller 그룹의 권한
group:sodor:r-x     < sodor 그룹의 권한
group:2210:rwx      < 2210번 GID를 가진 그룹은 모든 권한을 가지고 있다.
mask::rwx           < mask가 rwx라 effective가 안 걸려있다.
other::---          < 다른 유저는 아무 권한이 없다.
default:user::rwx       < 기본 사용자는 전체 권한
default:user:james:---  < james 사용자는 아무 권한이 없다.
default:group::rwx      < 기본 그룹은 전체 권한
default:group:sodor:r-x < sodor 그룹은 r-x 권한
default:mask::rwx       < 기본 mask는 rwx
default:other::---      < 기본 다른 유저는 아무 권한이 없다.
```

이전 예에서 각 섹션을 살펴보십시오. 

시작 주석 항목

```bash
# file: .
# owner: student
# group: controller 
# flags: -s-
```

처음 세 행은 디렉터리 이름, 소유자(student), 그룹 소유자(controller)를 식별하는 주석입니다. 추가 디렉터리 플래그(setuid, setgid, sticky)가 있는 경우 설정된 플래그(이 경우 setgid)를 표시하는 네 번째 주석 행이 나타납니다.

표준 ACL 항목:

```bash
user::rwx 
user:james:--- 
user:1005:rwx 
group::rwx 
group:sodor:r-x 
group:2210:rwx 
mask::rwx 
other::---
```

이 디렉터리의 ACL 권한은 이전 파일 예제와 동일하지만 디렉터리에 적용됩니다. 주요 차이점은 이러한 항목에 실행 권한을 포함하여(적절한 경우) 디렉터리 검색 권한을 허용하는 것입니다.

기본 사용자 항목:

💡새로운 파일을 생성할 때 언제나 같은 관리자가 설정한 권한으로 파일이 생성되었으면 좋겠다.

```bash
default:user::rwx
default:user:james:---
```

기본 파일 소유자 ACL 권한. 파일 소유자는 새 파일에 대한 읽기/쓰기 권한인 rwx와 새 하위 디렉터리에 대한 실행 권한을 얻습니다.

기본 명명된 사용자 ACL 권한. 새 파일 또는 하위 디렉터리에 자동으로 적용될 기본 ACL을 가지는 명명된 사용자마다 하나의 항목이 있습니다. james는 항상 권한 없음으로 기본 설정됩니다.

기본 그룹 항목:

```bash
default:group::rwx
default:group:sodor:r-x
```

기본 그룹 소유자 ACL 권한. 파일 그룹 소유자는 새 파일에 대한 읽기/쓰기 권한인 rwx와 새 하위 디렉터리에 대한 실행 권한을 얻습니다.

기본 명명된 그룹 ACL 권한. 자동으로 기본 ACL을 가지는 명명된 그룹마다 하나의 항목이 있습니다. sodor에 새 파일에 대한 읽기 전용인 rx가 생기며 새 하위 디렉터리에 실행합니다.

기본 ACL 마스크 항목:

```bash
default:mask::rwx
```

기본 마스크 설정은 명명된 사용자 ACL, 그룹 소유자 ACL 또는 명명된 그룹 ACL을 포함하여 새로 생성된 모든 파일 또는 디렉터리에 가능한 초기의 최대 권한, 즉, 새 파일에 대한 읽기 및 쓰기, 새 하위 디렉터리에 대한 실행 권한을 표시합니다. 새 파일에는 절대 실행 권한이 없습니다.

기본 기타 항목:

```bash
default:other::---
```

기본 other 또는 "범용" 권한. 기타 UID와 GID는 새 파일 또는 새 하위 디렉터리에 대해 어떤 권한도 없습니다.

이전 예의 default 항목에는 명명된 사용자(UID 1005)와 명명된 그룹 (GID 2210)이 포함되지 않습니다.

따라서 새 파일 또는 새 하위 디렉터리에 대한 초기 ACL 항목이 자동으로 추가되지 않습니다. 이 경우 이미 ACL이 적용된 파일과 하위 디렉터리로만 제한되거나 관련 파일 소유자가 나중에 setfacl을 사용하여 ACL을 추가해야 합니다. 고유한 파일과 하위 디렉터리를 만들 수도 있습니다

[참고]

```bash
getfacl의 출력을 setfacl에 대한 입력으로 사용할 수 있습니다. getfacl -R /directory를 사용하여 디렉터리 및 해당 콘텐츠의 출력을 생성합니다. 이 출력을 저장한 다음 setfacl --set-file=file로 전달하여 대규모 업데이트를 수행하여 복구에 사용할 수 있습니다.
```

마스크 적용 순서

ACL의 최대 크기 단위는 → 파티션

데이터용 디렉토리 mount/dev/sdb1/storage

### ACL 마스크

ACL 마스크는 named users, group-owner, named groups에 부여할 수 있는 최대 권한을 정의합니다. file owner 또는 other 사용자의 권한을 제한하지 않습니다. ACL을 구현하는 모든 파일과 디렉터리에는 ACL 마스크가 있습니다.

마스크는 getfacl로 보거나 setfacl로 명시적으로 설정할 수 있습니다. 명시적으로 설정되지 않은 경우 자동으로 계산되어 추가되지만 상위 디렉터리 기본 마스크 설정에서도 상속됩니다. 기본적으로 마스크는 영향을 받는 ACL이 추가, 수정, 삭제될 때마다 다시 계산됩니다.

### ACL 권한 적용 순서

```jsx
1. 파일 소유자의 권한으로 실행
2. ACL에 지정된 사용자로 등록이 되어 있는 경우 등록된 사용자로 실행
3. ACL에 지정된 최대 권한 만큼만 실행이 가능
4. 그룹 사용자로 실행
```

프로세스(실행 중인 프로그램)가 파일에 액세스할 수 있는지를 확인할 때 파일 권한 및 ACL이 다음과 같이 적용됩니다.

•프로세스가 파일을 소유하고 있는 사용자로 실행되는 경우 파일의 사용자 권한이 적용됩니다.

•프로세스가 사용자 ACL 항목에 나열된 사용자로 실행 중인 경우에는 명명된 사용자 ACL 권한이 적용 됩니다(마스크에서 허용된 경우).

•프로세스가 파일의 그룹 소유자와 일치하는 그룹 또는 명시적 명명된 그룹 ACL 항목이 있는 그룹으로 실행되는 경우 일치하는 ACL 권한이 적용됩니다(마스크에서 허용된 경우).

•그렇지 않은 경우에는 파일의 other ACL 사용 권한이 적용됩니다.

```bash
1 default:m::rx /directory 기본 마스크로 설정된 읽기, 실행 권한

2 default:user:mary:rx /directory 새 파일에 대한 초기 읽기 권한 및 새 하위 디렉터리에 대한 읽기, 실행 권한이 부여된 명명된 사용자

3 g::rw /directory 디렉터리 그룹 소유자에 부여된 디렉터리에 대한 읽기, 쓰기 권한

4 g::rw file 파일 그룹 소유자에 부여된 파일에 대한 읽기,쓰기 권한

5 getfacl /directory 디렉터리에 ACL을 표시합니다.

6 group:hug:rwx /directory 명명된 그룹에 부여된 디렉터리에 대한 읽기, 쓰기, 실행 권한

7 user::rx file 파일에 대한 읽기, 실행 권한이 있는 파일 소유자

8 user:mary:rx file 파일에 대한 읽기, 실행 권한이 있는 명명된 사용자
```

ACL의 사용 이유:

기본적으로 적용되는 유저, 그룹, 그 외 라는 세 가지 항목 외에 추가적인 사용자, 그룹에 대한 파일, 디렉토리의 적용.

마스크를 설정하여 최대 권한을 따로 설정 가능하다.

디렉토리의 경우에는 디폴트 마스크를 통하여 디렉토리 및 파일을 생성할 때 상속 된 권한을 가져갈 수 있다.

# ACL로 파일 보호

## ACL 파일 권한 변경

setfacl을 사용하여 파일 및 디렉터리에서 표준 ACL을 추가, 수정, 제거합니다.

ACL은 권한에 대해 일반 파일 시스템 표기법을 사용합니다. 즉, "r"은 읽기 권한, "w"는 쓰기 권한, "x"는 실행 권한입니다. "-"(대시)는 관련 권한이 없음을 나타냅니다. ACL을 (반복적으로) 설정할 경우 대문자 "X"를 사용하여 파일에 이미 관련 실행 권한이 있지 않은 이상 디렉터리에만 실행 권한을 설정하고 일반 파일에는 설정하지 않아야 함을 나타낼 수 있습니다. 이 옵션은 chmod와 동일한 기능을 합니다.

ACL 설정 시 사용되는 X는 두 가지이다.

```jsx
기본적인 실행 권한
x : 디렉토리에는 실행권한을 추가하고, 파일에도 실행권한을 추가
X : 디렉토리에는 실행권한을 추가하고, 파일에는 실행권한이 있다면 실행권한을 유지, 실행권한이 없다면 실행권한을 주지 않는다.

대문자 X 추천!
```

### ACL 추가 또는 수정

ACL은 -m을 사용하거나 설정하거나 -M을 사용하여 파일을 통해 전달할 수 있습니다(stdin에 파일 이름 을 사용하는 대신 "-"(대시) 사용). 이러한 두 옵션은 "수정" 옵션으로, 새 ACL 항목을 추가하거나 파일 또는 디렉터리에 기존의 특정 ACL 항목을 바꿉니다. 파일 또는 디렉터리에서 기타의 기존 ACL 항목은 그대로 유지됩니다.

[참고]

```bash
파일에서 ACL 설정을 완전히 바꾸려면 --set 또는 --set-file 옵션을 사용합니다.
```

파일에서 처음으로 ACL을 정의할 때 추가 작업에 file owner, group-owner 또는 other 권한에 대한 설정이 포함되지 않은 경우 현재 표준 파일 권한을 기준으로 설정되고(base ACL이라고도 하며 삭제할 수 없음) 새 mask 값이 계산되고 새로 추가됩니다.

user 또는 named user ACL 추가 또는 수정하기

```bash
[student@serverX ~]$ setfacl -m u:name:rX file
```

name이 비어 있는 경우 file owner에 적용되며, 그렇지 않을 경우 name은 사용자 이름 또는 UID 값이 될 수 있습니다. 이 예에서 부여된 권한은 읽기 전용이 되며, 이미 설정된 경우는 실행입니다(file이 directory인 경우는 디렉터리 검색을 허용하도록 실행 권한을 얻음).

ACL file owner 및 표준 file owner 권한은 동일합니다. 따라서 file owner 권한에서 chmod를 사용하는것은 file owner 권한에서 setfacl을 사용하는 것과 동일합니다. chmod에는 명명된 사용자에 대한 영향이 없습니다.

group 또는 named group ACL 추가 또는 수정하기

```bash
[student@serverX ~]$ setfacl -m g:name:rw file
```

이 절차는 사용자 ACL을 추가 또는 수정하는 절차와 동일한 패턴을 따릅니다. name이 비어 있는 경우 group-owner에 적용됩니다. 그렇지 않을 경우 named group에 그룹 이름 또는 GID를 지정합니다. 이 예에서 권한은 읽기 및 쓰기가 됩니다.

chmod는 ACL 설정이 포함된 파일의 그룹 권한에 아무 영향을 미치지 않지만 ACL 마스크를 업데이트합니다.

other ACL 추가 또는 수정하기

```bash
[student@serverX ~]$ setfacl -m o::- file
```

other에는 권한 설정만 가능합니다. other 사용자에게 권한이 없음을 의미하는 "-"로 권한을 설정하는 것이 일반적입니다. 하지만 기타 표준 권한을 설정할 수 있습니다.

ACL other 및 표준 other 권한은 동일합니다. 따라서 other 권한에서 chmod를 사용하는 것은 other 권한에서 setfacl을 사용하는 것과 동일합니다.

동일한 명령을 통해 여러 항목을 추가하고 각 항목을 쉼표로 구분합니다.

```bash
[student@serverX ~]$ setfacl -m u::rwx,g:sodor:rX,o::- file
```

이 예제는 file owner에 읽기, 쓰기, 실행을 설정하고, 명명된 그룹인 sodor는 읽기 전용 및 조건부 실행을 설정하며, 모든 other 사용자는 권한 없음으로 제한합니다. group-ower는 기존 파일 또는 ACL 권한및 기타 "명명된" 항목을 변경되지 않은 상태로 유지합니다.

### getfacl을 입력으로 사용

getfacl의 출력을 setfacl에 대한 입력으로 사용할 수 있습니다.

```bash
[student@serverX ~]$ getfacl file-A | setfacl --set-file=- file-B
```

--set-file은 파일 또는 stdin의 입력을 수용하며 "-"(대시)는 stdin을 사용하도록 지정합니다. 이 경우 file-B는 file-A와 ACL 설정이 동일합니다.

### 명시적 ACL 마스크 설정

파일 또는 디렉터리에 ACL 마스크를 명시적으로 설정하여 명명된 사용자, 그룹 소유자, 명명된 그룹의 최대 유효 권한을 제한할 수 있습니다. 그러면 마스크를 초과하는 기존 권한은 제한되지만 마스크보다 낮은 권한에 대해서는 아무 제한을 하지 않습니다.

```bash
[student@serverX ~]$ setfacl -m m::r file
```

이 예제에서는 기존 설정과 상관없이 named users, group-owner 및 모든 named groups를 읽기 전용 권한으로 제한하는 마스크 값을 추가합니다. file owner 및 other 사용자는 마스크 설정의 영향을 받지 않습니다.

getfacl은 마스크 설정으로 제한되는 항목 옆에 "effective"라는 주석이 표시됩니다

```bash
중요
기본적으로 ACL 마스크는 영향을 받은 ACL 설정(명명된 사용자, 그룹 소유자 또는 명명된 그룹) 중 하나가 수정 또는 삭제될 때마다 재계산되어 이전 명시적 마스크 설정이 재설정될 수 있습니다.
마스크가 재계산되지 않도록 하려면 -n을 사용하거나 마스크 설정(-m m::perms)과 마스크로 영향을 받는 ACL 설정을 수정하는 setfacl 작업을 포함합니다.
```

### 재귀적 ACL 수정

디렉터리에서 ACL을 설정할 경우 디렉터리 구조 및 파일에 ACL을 반복적으로 적용하는 것이 일반적입니다. 이와 같이 하려면 -R 옵션을 사용합니다. 반복에는 보통 "X"(대문자 X)를 사용하여 실행 권한이 설정된 파일은 설정을 유지하고 실행 권한이 설정된 디렉터리는 디렉터리 검색을 허용하도록 합니다. ACL을 비재귀적으로 설정하는 경우에는 관리자가 일반 파일에 실수로 실행 권한을 추가하지 않도록 대문자X를 사용하는 것이 좋습니다.

```bash
[student@serverX ~]$ setfacl -R -m u:name:rX directory
```

이 예제는 directory와 모든 기존 파일 및 하위 디렉터리에 사용자 name을 추가하여 읽기 전용 및 조건부 실행 권한을 추가합니다.

### ACL 삭제

특정 ACL 항목을 삭제할 경우 수정 작업과 같은 기본 형식을 따릅니다. 단, ":perms"는 지정하지 않습니다.

이 예제에서는 파일 목록 또는 디렉터리 ACL에서 명명된 사용자와 명명된 그룹만 제거됩니다. 나머지 기존 ACL은 활성화된 상태로 유지됩니다.

동일한 setfacl 작업에 삭제(-x)와 수정(-m) 작업을 사용할 수 있습니다.

마스크는 다른 ACL이 설정되지 않은 경우에만 삭제할 수 있으므로(삭제할 수 없는 기본 ACL 제외) 마지막에 삭제해야 합니다. 파일에 더 이상 ACL이 없으며 ls -l은 권한 문자열 옆에 "+" 기호가 표시되지 않습니다. 또는 파일 또는 디렉터리의 모든 ACL을 삭제하려면(디렉터리의 default ACL 포함) 다음을 사용합니다.

```bash
[student@serverX ~]$ setfacl -b file
```

# 기본 ACL 파일 권한 제어

디렉터리는 모든 새 파일과 새 하위 디렉터리가 자동으로 상속하도록 설정된 default ACL을 가질 수 있습니다. 기본 마스크를 포함하여 각각의 표준 ACL 설정에 대해 default ACL 권한을 설정할 수 있습니다.

default ACL은 디렉터리에 대해 액세스 제어를 구현하지 않으므로 디렉터리는 액세스 제어에 대한 표준 ACL이 필요합니다. 기본 ACL은 ACL 권한 상속 지원만 제공합니다.

예

```bash
[student@serverX ~]$ setfacl -m d:u:name:rx directory
```

이 예제는 읽기 전용 권한과 하위 디렉터리에 대한 실행 권한을 가진 기본 명명된 사용자(d:u:name)를 추

가합니다.

각 ACL 유형에 대해 기본 ACL을 추가하는 setfacl 명령은 표준 ACL과 정확히 동일하지만 앞부분에 d:가 추가됩니다. 또는 명령줄에 -d 옵션을 사용합니다

```bash
중요
디렉터리에 default ACL을 사용할 경우 default ACL에 실행 권한을 포함하여 사용자가 생성된 새 하위 디렉터리의 콘텐츠에 액세스할 수 있도록 합니다.
새 디렉터리와 달리 새 일반 파일의 ACL 마스크는 rw-이므로 사용자는 새로 만들어진 일반 파일에 대해 자동으로 실행 가능 권한이 설정되지 않습니다.
```

```bash
참고
상위 디렉터리 setgid 플래그가 활성화된 경우(기본 그룹 GID가 상위 디렉터리 GID와 동일) 를 제외하고, 새 파일과 새 하위 디렉터리의 소유자 UID와 기본 그룹 GID 값 집합은 계속해서 만드는 사용자로부터 얻습니다
```

### 기본 ACL 삭제

default를 삭제하는 것은 표준 ACL을 삭제하는 것과 동일합니다. 이 경우에도 앞에 d:를 표시하거나 -d 옵션을 사용합니다.

```bash
[student@serverX ~]$ setfacl -x d:u:name directory
```

이 예제는 앞 예제에서 추가한 default ACL을 제거합니다.

디렉터리에서 default ACL을 모두 삭제하려면 setfacl -k /directory를 사용합니다. 디렉터리에서 모든 ACL을 삭제하려면 setfacl -b /directory를 사용합니다.

## ACL 실습

### ACL 확인 및 추가

```bash
# touch file1
# mkdir dir1

기본 정보 확인
[SERVER1]# ls -l
합계 0
drwxr-xr-x. 2 root root 6  4월 17 12:55 dir1
-rw-r--r--. 1 root root 0  4월 17 12:55 file1
[SERVER1]# getfacl dir1
# file: dir1
# owner: root
# group: root
user::rwx
group::r-x
other::r-x

[SERVER1]# getfacl file1
# file: file1
# owner: root
# group: root
user::rw-
group::r--
other::r--

user01 권한 추가
[SERVER1]# setfacl -m u:user01:rwx file1
[SERVER1]# getfacl file1
# file: file1
# owner: root
# group: root
user::rw-
user:user01:rwx
group::r--
mask::rwx
other::r--

group01 권한 추가
[SERVER1]# setfacl -m g:group01:r-x file1
[SERVER1]# getfacl file1
# file: file1
# owner: root
# group: root
user::rw-
user:user01:rwx
group::r--
group:group01:r-x
mask::rwx
other::r--

setuid 플래그 설정
[SERVER1]# chmod 4655 file1
[SERVER1]# getfacl file1
# file: file1
# owner: root
# group: root
# flags: s--
user::rw-
user:user01:rwx			#effective:r-x
group::r--
group:group01:r-x
mask::r-x
other::r-x

ACL 파일의 기본 권한 설정
[SERVER1]# setfacl -m u::rwx file1
[SERVER1]# getfacl file1
# file: file1
# owner: root
# group: root
user::rwx
user:user01:rwx
group::r--
group:group01:r-x
mask::rwx
other::r-x

마스크 설정
[SERVER1]# setfacl -m m::r-x file1
[SERVER1]# getfacl file1
# file: file1
# owner: root
# group: root
user::rwx
user:user01:rwx			#effective:r-x
group::r--
group:group01:r-x
mask::r-x
other::r-x

디렉토리 기본 ACL 설정
[SERVER1]# gerfacl dir1
bash: gerfacl: 명령을 찾을 수 없습니다...
[SERVER1]# getfacl dir1
# file: dir1
# owner: root
# group: root
user::rwx
group::r-x
other::r-x
default:user::rwx
default:group::r-x
default:other::r-x

디렉토리 특정 유저 기본 권한 설정
[SERVER1]# setfacl -m d:user01:rX dir1
[SERVER1]# getfacl dir1
# file: dir1
# owner: root
# group: root
user::rwx
group::r-x
other::r-x
default:user::rwx
default:user:user01:r-x
default:group::r-x
default:mask::r-x
default:other::r-x
```

### 연습문제

사전생성

- /shares/steamies 디렉토리 [display.sh](http://display.sh/) 파일
    - engines 하위 디렉토리
- controller 그룹: student
- sodor 그룹: thomas, james

현재는 controller 그룹의 멤버만 이 디렉터리에 액세스 권한을 가지고 있다. **sodor** 그룹의 멤버가 이 디렉터리에 전체 액세스 권한을 가지면 유용할 것이라는 결정을 하게 되었습니다

sodor 그룹의 멤버인 James는 여러 번 혼란을 일으켰던 문제가 있기 때문에 적어도 컴맹이 아님을 증명 하기 전까지는 이 디렉터리에 대한 액세스를 거부해야 합니다.

sodor 그룹의 멤버에게 전체 액세스 권한을 할당하고 james의 모든 액세스 권한을 거부하도록 디렉터리와 콘텐츠에 적절한 ACL을 추가하는 것입니다. 앞으로 /shares/steamies에 저장하는 파일과 디렉터리에 적절한 ACL이 적용되도록 하십시오.

```bash
참고
student를 controller 그룹으로 전환하려면 newgrp controller를 사용합니다.
```

사전작업

```bash
[SERVER1]# useradd student
[SERVER1]# useradd thomas
[SERVER1]# useradd james
[SERVER1]# groupadd controller
[SERVER1]# groupadd sodor

[SERVER1]# usermod -aG controller student
[SERVER1]# usermod -aG sodor thomas
[SERVER1]# usermod -aG sodor james

[SERVER1]# id student
uid=1003(student) gid=1005(student) groups=1005(student),1008(controller)
[SERVER1]# id thomas
uid=1004(thomas) gid=1006(thomas) groups=1006(thomas),1009(sodor)
[SERVER1]# id james
uid=1005(james) gid=1007(james) groups=1007(james),1009(sodor)

[SERVER1]# mkdir -p /shares/steamies/engine
[SERVER1]# chown .controller /shares/steamies
[SERVER1]# ls -ld /shares/steamies
drwxr-xr-x. 3 root controller 20  4월 17 14:44 /shares/steamies
[SERVER1]# chmod 755 /shares/steamies
[SERVER1]# ls -ld /shares/steamies
drwxr-xr-x. 3 root controller 20  4월 17 14:44 /shares/steamies

[SERVER1]# cd /shares/steamies/
[SERVER1]# ls
engine
[SERVER1]# vi display.sh
#!/bin/bash
echo "Test Display"
[SERVER1]# chmod 777 display.sh 
[SERVER1]# ls -l
합계 4
-rwxrwxrwx. 1 root root 32  4월 17 14:48 display.sh
drwxr-xr-x. 2 root root  6  4월 17 14:44 engine
```

ACL을 steamies 디렉터리 및 해당 디렉터리의 모든 콘텐츠에 추가합니다.

**setfacl**로 **steamies** 디렉터리를 재귀적으로 업데이트하여 **sodor** 그룹에 읽기, 쓰기, 조건부 실행 권한을 부여합니다.

```bash
[SERVER1]# setfacl -Rm g:sodor:rwX /shares/steamies
[SERVER1]# getfacl /shares/steamies
getfacl: Removing leading '/' from absolute path names
# file: shares/steamies
# owner: root
# group: root
user::rwx
group::r-x
group:sodor:rwx
mask::rwx
other::r-x

-R 재귀, -m 수정/추가, :- 권한 없음
```

앞으로 추가하는 파일 및 디렉터리를 지원할 수 있도록 명명된 ACL을 default ACL로 추가합니다.

setfacl을 사용하여 sodor 그룹에 기본 액세스 규칙을 추가합니다. steamies 디렉터리에 읽기, 쓰기, 실행 권한을 부여합니다.

```bash
[SERVER1]# setfacl -m d:g:sodor:rwx /shares/steamies
[SERVER1]# getfacl /shares/steamies
getfacl: Removing leading '/' from absolute path names
# file: shares/steamies
# owner: root
# group: root
user::rwx
group::r-x
group:sodor:rwx
mask::rwx
other::r-x
default:user::rwx
default:group::r-x
default:group:sodor:rwx
default:mask::rwx
default:other::r-x

-m 수정/추가, d:g 기본 그룹, :rwx 읽기/쓰기/실행(올바른 하위 디렉터리 생성 및 액세스에 필 요)
```

setfacl로 steamies 디렉터리를 재귀적으로 업데이트하여 sodor 그룹에서 사용자 james의 모든 액세스를 거부합니다.

```bash
[SERVER1]# setfacl -Rm u:james:- /shares/steamies
[SERVER1]# getfacl /shares/steamies
getfacl: Removing leading '/' from absolute path names
# file: shares/steamies
# owner: root
# group: controller
user::rwx
user:james:---
group::rwx
group:sodor:rwx
mask::rwx
other::r-x
default:user::rwx
default:group::rwx
default:group:sodor:rwx
default:mask::rwx
default:other::r-x
```

setfacl을 사용하여 사용자 james에 기본 액세스 규칙을 추가합니다. steamies 디렉터리에 대 한 모든 액세스를 거부합니다.

```bash
[SERVER1]# setfacl -m d:u:james:- /shares/steamies
[SERVER1]# getfacl /shares/steamies
getfacl: Removing leading '/' from absolute path names
# file: shares/steamies
# owner: root
# group: root
user::rwx
group::r-x
group:sodor:rwx
mask::rwx
other::r-x
default:user::rwx
default:user:james:---
default:group::r-x
default:group:sodor:rwx
default:mask::rwx
default:other::r-x
```

ACL 변경 사항을 확인합니다.
Thomas는 파일을 읽고 새 파일이 들어 있는 새 디렉터리를 만들고 **display_engines.sh** 스크립트 를 실행할 수 있어야 합니다.

James는 파일을 읽거나 쓰거나 실행할 수 없어야 합니다. 또한 디렉터리 콘텐츠를 나열할 수도 없어야 합니다.

# Firewalld 관리

## 사전 작업

```bash
[SERVER1]
# systemctl stop named-chroot

# vi /etc/named.conf
options {
        listen-on port 53 { any; };
        listen-on-v6 port 53 { none; };
        directory       "/var/named";
        dump-file       "/var/named/data/cache_dump.db";
        statistics-file "/var/named/data/named_stats.txt";
        memstatistics-file "/var/named/data/named_mem_stats.txt";
        secroots-file   "/var/named/data/named.secroots";
        recursing-file  "/var/named/data/named.recursing";
        allow-query     { any; };
        ~~allow-transfer  { 192.168.10.210; };~~       << 라인 삭제

# vi /etc/named.rfc1912.zones
zone "example.com" IN {
        type master;
        file "server.zone";
        ~~also-notify { 192.168.10.210; };~~           << 라인 삭제
};

zone "10.168.192.in-addr.arpa" IN {
        type master;
        file "server.rev";
        ~~also-notify { 192.168.10.210; };~~           << 라인 삭제
};

# cd /var/named
# vi server.zone
$TTL 4
@	IN SOA	ns1.example.com. root.example.com. (
					43	; serial
					1D	; refresh
					1H	; retry
					1W	; expire
					3H )	; minimum
	NS	@
	A	192.168.10.200
	AAAA	::1
	IN	NS	ns1
ns1	IN	A	192.168.10.200
www	IN	A	192.168.10.200

# vi server.rev
$TTL 4
@	IN SOA	ns1.example.com. root.example.com. (
					0	; serial
					1D	; refresh
					1H	; retry
					1W	; expire
					3H )	; minimum
	NS	@
	A	127.0.0.1
	AAAA	::1
	IN	NS	ns1.example.com.
200	IN	PTR	ns1.example.com.

# rm -rf named.ca
# mv named.ca.old named.ca

# systemctl restart named-chroot
# systemctl status named-chroot

# systemctl stop httpd
# systemctl disable httpd

# dnf -y remove httpd
# rm -rf /var/www
# rm -rf /etc/httpd/

# init 0

snapshot 저장
(혹시 nameserver가 재부팅 하면 192.168.10.200으로 안된다면
	# nmcli con mod ens33 ipv4.dns 192.168.10.200
 위 명령어 실행)

# firewall-cmd --permanent --remove-service=http
success
# firewall-cmd --reload 
success

[SERVER2]
# systemctl stop named-chroot

# cat /etc/named.conf | grep -i exam
// See /usr/share/doc/bind*/sample/ for example named configuration files

# cp -f /usr/share/doc/bind/sample/etc/named.conf /etc/named.conf
overwrite : y

# vi /etc/named.rfc1912.zones
추가했던 zone파일 삭제

# cd /var/named/slaves/
# ls -l
합계 8
-rw-r--r--. 1 named named 486  1월 14 11:43 server.rev
-rw-r--r--. 1 named named 796  1월 14 15:52 server.zone
# rm -rf *

# vi /etc/resolv.conf
nameserver 8.8.8.8 확인

# dnf -y remove bind bind-chroot
# rm -rf /var/named/
# rm -rf /etc/named.conf.rpmsave
```

## Firewalld 개요

firewalld는 호스트 수준 방화벽을 관리하기 위한 Red Hat Enterprise Linux 7의 기본 방법입니다. firewalld.service systemd 서비스부터 firewalld는 하위 수준 iptables, ip6tables 및 ebtables 명령을 사용하여 Linux 커널 netfilter 하위 시스템을 관리합니다.

```bash
참고
firewalld.service와 ip6tables.serviceiptables.service, 와 ebtables.service 서비스는 서로 충돌합니다. *tables.service 서비스 중 하나가 실수로 시작되어 프로세스에서 실행중인 방화벽 구성이 지워지지 않게 하려면 systemctl을 사용하여 서비스를 마스킹하는 것이 좋습니다.

[root@serverX ~]# for SERVICE in iptables ip6tables ebtables; do
> systemctl mask ${SERVICE}.service
> done
```

firewalld는 들어오는 모든 트래픽 각각을 자체 규칙 집합을 갖는 영역으로 분리합니다. 들어오는 연결에 사용할 영역을 확인하기 위해 firewalld는 첫 번째로 일치하는 규칙이 적용되는 다음과 같은 논리를사용합니다.

1. 들어오는 패킷의 소스 주소가 영역의 소스 규칙 설정과 일치하면 패킷의 경로가 해당 영역으로 지정됩니다.

2. 패킷에 대해 들어오는 인터페이스가 영역에 대한 필터 설정과 일치하면 해당 영역이 사용됩니다.

3. 그렇지 않은 경우 기본 영역이 사용됩니다. 기본 영역은 별도의 영역이 아니며 시스템에 정의된 다른 영역 중 하나를 가리킵니다.

관리자나 NetworkManager 구성에 따라 재정의되지 않는 한, 새 네트워크 인터페이스의 기본 영역이 public 영역으로 설정됩니다.

firewalld에는 사전 정의된 여러 영역이 포함되어 있으며 각각은 고유한 용도로 사용됩니다.

firewalld 영역의 기본 구성

```bash
영역 이름 기본 구성
trusted
			들어오는 모든 트래픽을 허용합니다.
home 
			나가는 트래픽과 관련이 없거나 사전 정의 서비스인 ssh, mdns, ipp-client, samba-client 또는 dhcpv6-client와 일치하지 않을 경우 들어오는 트래픽을 거부합니다.
internal 
			나가는 트래픽과 관련이 없거나 사전 정의 서비스( home(집) 영역으로 시작하는 것은 동일)인 ssh, mdns, ipp-client, samba-client 또는 dhcpv6-client 와 일치하지 않을 경우 들어오는 트래픽을 거부합니다
work 
			나가는 트래픽과 관련이 없거나 사전 정의 서비스인 ssh, ipp-client 또는 dhcpv6-client와 일치하지 않을 경우 들어오는 트래픽을 거부합니다.
public 
			나가는 트래픽과 관련이 없거나 사전 정의 서비스인 ssh 또는 dhcpv6-client와 일치하지 않을 경우 들어오는 트래픽을 거부합니다. 새로 추가된 네트워크 인터페이스의 기본 영역입니다.
external 
			나가는 트래픽과 일치하지 않거나 사전 정의 서비스인 ssh와 일치하지 않을 경우 들어오는 트래픽을 거부합니다. 이 영역을 통해 전달되어 나가는 IPv4 트래픽은 나가는 네트워크 인터페이스의 IPv4 주소에서 시작된 것처럼 마스커레이드됩니다.
dmz 
			나가는 트래픽과 일치하지 않거나 사전 정의 서비스인 ssh와 일치하지 않을 경우 들어오는 트래픽을 거부합니다.
block 
			나가는 트래픽과 관련되지 않은 경우 들어오는 모든 트래픽을 거부합니다.
drop 
			나가는 트래픽과 관련되지 않은 경우(ICMP 오류에도 대응하지 않음) 들어오 는 모든 트래픽을 거부합니다.

```

## Firewalld 관리

firewalld는 다음 세 가지 방법으로 관리할 수 있습니다.

1. 명령줄 도구 firewall-cmd 사용

2. 그래픽 도구 firewall-config 사용

3. /etc/firewalld/의 구성 파일 사용

대부분의 경우 구성 파일을 직접 편집하는 것은 권장되지 않지만 구성 관리 도구를 사용할 경우 이러한 방식으로 구성을 복사하는 것이 유용할 수 있습니다.

### firewall-cmd를 사용하는 방화벽 설정 구성

이 섹션에서는 명령줄 도구 firewall-cmd를 사용하여 firewalld를 관리하는 방법을 중점적으로 설명합니다.

firewall-cmd는 주 firewalld 패키지에 포함되어 설치됩니다. firewall-cmd는 firewall-config와 동일한 작업을 수행할 수 있습니다.

다음 표에 자주 사용되는 다양한 firewall-cmd 명령과 설명이 나열되어 있습니다. 별 달리 명시되지 않은 경우에는 --permanent 옵션을 지정하지 않는 한 거의 모든 명령이 런타임 구성에서 실행됩니다. 나열된 명령 대부분은 --zone=<ZONE> 옵션을 사용하여 영향을 미칠 영역을 결정합니다. 이러한 명령에서 --zone을 생략하면 기본 영역이 사용됩니다.

방화벽을 구성하는 동안 관리자는 일반적으로 모든 변경 내용을 --permanent 구성에 적용한 다음 firewall-cmd --reload를 사용하여 활성화합니다. 위험할 수 있는 새로운 규칙을 테스트할 때 관리자는 --permanent 옵션을 생략하여 런타임 구성에 대해 작업하도록 선택할 수 있습니다. 이러한 경우 특정시간 후에 규칙을 자동으로 제거하도록 하는 추가 옵션 --timeout=<TIMEINSECONDS>를 사용하여 관리자가 시스템을 실수로 잠그지 않도록 할 수 있습니다.

```bash
firewall-cmd 방화벽을 사용하기 위한 명령어
--permanent 영구 설정
이 옵션이 없다면 방화벽 reload 하거나 또는 재부팅시 설정 내용이 사라진다.
--zone=<ZONE>
옵션을 지정할 때 zone을 설정하는 경우가 많다.
--zone을 생략
default zone으로 구성
--timeout=<TIMEINSECONDS>
임시적으로 잠시 timeout을 걸어서 테스트 목적
60초 구성 = 60초 동안만 적용
```

```bash
firewall-cmd 명령                 설명

--get-default-zone
			현재 기본 영역을 쿼리합니다.
--set-default-zone=<ZONE> 
			기본 영역을 설정합니다. 이 설정은 런타임 및 영구 구성을 둘 다 변경합니다.
--get-zones 
			사용 가능한 모든 영역을 나열합니다.
--get-services 
			사전 정의된 모든 서비스를 나열합니다.
--get-active-zones 
			현재 사용 중인 모든 영역(인터페이스가 있거나 연결된 소스가 있음)과 해당 인터페이스 및 소스 정보를 나열합니다.
--add-source=<CIDR> [--zone=<ZONE>] 
			IP 주소 또는 네트워크/넷마스크 <CIDR>의 모든 트래픽을 지정된 영역으로 라우팅합니다. --zone= 옵션을 입력하지 않은 경우 기본 영역이 사용됩니다.
--remove-source=<CIDR> [--zone=<ZONE>] 
			IP 주소 또는 네트워크/넷마스크 <CIDR>의 모든 트래픽을 라우팅하는 규칙을 지정된 영역에서 제거합니다. 
      --zone= 옵션을 입력하지 않은 경우 기본 영역이 사용됩니다.
--add-interface=<INTERFACE> [--zone=<ZONE>] 
			<INTERFACE>의 모든 트래픽을 지정된 영역으로 라우팅합니다. --zone= 옵션을 입력하지 않은 경우 기본 영역이 사용됩니다.
--change-interface=<INTERFACE> [--zone=<ZONE>] 
			현재 영역 대신 인터페이스를 <ZONE>과 연결합니다. --zone= 옵션을 입력하지 않은 경우 기본 영역이 사용됩니다.
--list-all [--zone=<ZONE>] 
			 <ZONE>에 대해 구성된 모든 인터페이스, 소스, 서비스, 포트를 나열합니다. --zone= 옵션을 입력하지 않은 경우 기본 영역이 사용됩니다.
--list-all-zones 
			모든 영역(인터페이스, 소스, 포트, 서비스 등)에 대한 모든 정보를 검색합니다.
--add-service=<SERVICE> 
			<SERVICE>포트로 트래픽을 허용합니다. --zone= 옵션을 입력하지 않은 경우 기본 영역이 사용됩니다.
--add-port=<PORT/PROTOCOL> 
			<PORT/PROTOCOL> 포트로 트래픽을 허용합니다. --zone= 옵션을 입력하지 않은 경우 기본 영역이 사용됩니다.
--remove-service=<SERVICE> 
			영역에 허용된 목록에서 <SERVICE>를제거합니다. --zone= 옵션을 입력하지 않은 경우 기본 영역이 사용됩니다.
--remove-port=<PORT/PROTOCOL> 
			영역에 허용된 목록에서 <PORT/PROTOCOL> 포트를 제거합니다. --zone= 옵션을 입력하지 않은 경우 기본
영역이 사용됩니다.
--reload 런타임 구성을 삭제하고 영구 구성을 적용합니다.
```

### firewall-cmd 방화벽 설정 구성

 

```bash
firewall-cmd 명령                              설명
firewall-cmd --get-default-zone              현재 기본 영역 쿼리
firewall-cmd --set-default-zone=[zone]       기본 영역 설정
firewall-cmd --get-zones                     지정된 모든 영역 출력
firewall-cmd --get-active-zones              현재 활동중인 영역 쿼리
firewall-cmd --add-source=[IP/CIDR] --zone=[zone]       해당되는 [IP/CIDR]의 트래픽을 지정된 영역으로 라우팅한다. 만약 zone을 지정하지 않은 경우에는 기본 영역을 사용한다.
firewall-cmd --add-remove=[IP/CIDR] --zone=[zone]       해당되는 [IP/CIDR]를 삭제, 만약 zone을 지정하지 않은 경우에는 기본 영역에서 삭제
firewall-cmd --add-interface=[interface name] --zone=[zone]    해당되는 [interface name]의 트래픽을 지정된 영역으로 라우팅한다. 만약 zone을 지정하지 않은 경우에는 기본 영역을 사용한다.
firewall-cmd --change-interface=[interface name] --zone=[zone] 해당되는 [interface name]의 라우팅을 다른 영역으로 변경
firewall-cmd --list-all                     영역에 구성된 모든 설정 출력, zone을 지정하지 않으면 기본 영역 
**firewall-cmd --list-all --zone=home**         **영역에 구성된 모든 설정 출력**
firewall-cmd --list-all-zones               모든 영역에 구성된 모든 설정 출력
firewall-cmd --add-service=[service name] --zone=[zone]   해당되는 [service name]의 트래픽을 허용한다. 만약 zone을 지정하지 않은 경우에는 기본 영역을 사용한다.
firewall-cmd --add-port=[port number] --zone=[zone]       해당되는 [port number]의 트래픽을 허용한다. 만약 zone을 지정하지 않은 경우에는 기본 영역을 사용한다.
firewall-cmd --remove-service=[service name] --zone=[zone] 해당되는 [service name]의 방화벽 설정을 삭제한다. 만약 zone을 지정하지 않은 경우에는 기본 영역을 사용한다.
firewall-cmd --remove-port=[port number] --zone=[zone] 해당되는 [port number]의 방화벽 설정을 삭제한다. 만약 zone을 지정하지 않은 경우에는 기본 영역을 사용한다.
firewall-cmd --permanent 재부팅시에도 설정 가능하도록 저장한다.
firewall-cmd --reload    서비스를 재시작하지 않고 파일을 읽는다.
```

### firewall-cmd 예제

다음 예제는 기본 영역이 dmz로 설정되고, 192.168.0.0/24 네트워크의 모든 트래픽이 internal 영역에 할당되며, mysql의 네트워크 포트가 internal 영역에 열리는 경우를 보여줍니다.

```bash
[root@serverX ~]# firewall-cmd --set-default-zone=dmz
[root@serverX ~]# firewall-cmd --permanent --zone=internal --add-source=192.168.0.0/24
[root@serverX ~]# firewall-cmd --permanent --zone=internal --add-service=mysql
[root@serverX ~]# firewall-cmd --reload
```

### Firewalld 구성 파일

firewalld 구성 파일은 /etc/firewalld 및 /usr/lib/firewalld에 저장됩니다. 같은 이름의 구성 파일이 두 곳에 저장되면 /etc/firewalld/의 버전이 사용됩니다. 따라서 관리자는 패키지 업데이트로 인해 변경 내용이 지워질까 걱정하지 않고 기본 영역 및 설정을 재정의할 수 있습니다.

### 연습문제

1. 관리자가 실수로 **iptables** 및 **ip6tables** 서비스를 시작하지 않도록 시스템을 구성합니다.
2. **firewalld** 서비스가 실행되는지 확인합니다. 그렇지 않을 경우 서비스를 시작합니다.
3. 기본 방화벽 영역이 **public(공개)**으로 설정되었는지 확인합니다.
4. **public(공개)** 영역의 영구 구성에 원하지 않는 포트가 열려있지 않은지 확인합니다.
5. **public(공개)** 영역의 영구 구성에 **8080/TCP** 포트를 추가합니다. 구성을 확인합니다.
6. **serverX** 시스템을 재부팅합니다. (빠른 테스트를 위해 **sudo firewall-cmd --reload**를 사용할 수 도 있습니다.)

```bash
[SERVER1]# dnf -y install httpd
httpd 서비스 활성화, web page 
[SERVER1]# echo "server1 web" > /var/www/html/index.html
[SERVER1]# systemctl restart httpd
[SERVER1]# curl www.example.com
server1 web

[SERVER1]# systemctl mask iptables.service 
[SERVER1]# systemctl mask ip6tables.service 

[SERVER1]# systemctl status firewalld

[SERVER1]# firewall-cmd --set-default-zone=dmz
[SERVER1]# firewall-cmd --get-default-zone
[SERVER1]# firewall-cmd --set-default-zone=public

[SERVER1]# firewall-cmd --permanent --zone=public  --list-all

server 2에서 접근
TIMEOUT 옵션을 사용하여 먼저 테스트를 해보고
그 다음 실 적용
# firewall-cmd --add-service=http --timeout=30 --zone=public

[SERVER1]# firewall-cmd --permanent --zone=public  --add-port=8080/tcp
[SERVER1]# firewall-cmd --permanent --zone=public  --add-port=80/tcp
[SERVER1]# firewall-cmd --reload
[SERVER1]# firewall-cmd --permanent --zone=public --list-all 
public
  target: default
  icmp-block-inversion: no
  interfaces: 
  sources: 
  services: dhcpv6-client ssh
  ports: 8080/tcp, 80/tcp
  protocols: 
  masquerade: no
  forward-ports: 
  source-ports: 
  icmp-blocks: 
  rich rules:
```

```bash
사전 설정 상황
현재 서버에 웹 서비스가 기동되어 있다는 상황
```

```bash
firewalld
단 하나의 정책으로 사용하는 것이 아니라 설계에 따라 중첩 차단이 가능하다.
여러 조건들을 모아서 최종적으로 혀용 되는 트래픽만 지나간다.
```

httpd 및 mod_ssl 패키지를 **server1**에 설치해야 합니다.

**httpd.service**에서 **server1**를 활성화하고 시작해야 합니다.

사내 웹 개발자가 실제 애플리케이션을 완료할 때까지 웹 서버는 텍스트 **COFFEE!**!라는 내용의 페이지 를 제공해야 합니다.

firewalld에서 **server1**를 활성화하고 시작해야 합니다.

**server1**의 firewalld 구성은 지정되지 않은 모든 연결에 대해 **dmz** 영역을 사용해야 합니다.

**192.168.10.0/24** 서브넷의 트래픽 경로는 **work** 영역으로 지정되어야 합니다.

**work** 영역에서 **http**에 필요한  포트가 열려 있어야 하지만 ssh는 필터링 되어야 합니다.

```bash
[SERVER2]# yum -y install httpd mod_ssl

[SERVER2]# systemctl start httpd
[SERVER2]# systemctl enable httpd.service

[SERVER2]# echo 'COFFEE!!' > /var/www/html/index.html

[SERVER2]# firewall-cmd --set-default-zone=dmz
[SERVER2]# firewall-cmd --get-default-zone 
dmz

[SERVER2]# firewall-cmd --permanent --zone=work --add-source=192.168.10.0/24
[SERVER2]# firewall-cmd --permanent --zone=work --list-all
work (active)
  target: default
  icmp-block-inversion: no
  interfaces: 
  sources: 192.168.10.0/24
  services: dhcpv6-client ssh
  ports: 
  protocols: 
  masquerade: no
  forward-ports: 
  source-ports: 
  icmp-blocks: 
  rich rules:

[SERVER2]# firewall-cmd --permanent --zone=work --add-service=http
success
[SERVER2]# firewall-cmd --permanent --zone=work --remove-service=ssh
success
[SERVER2]# nmcli con mod ens33 connection.zone work

[SERVER2]# firewall-cmd --reload
```

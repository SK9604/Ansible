

- **배운 내용**

    파일 관리 명령어

    touch 명령어

    cp 명령어

    mv 명령어

    rm 명령어

---

# 내용 정리

## 파일 관리 명령어

---

- touch 명령어

    ```bash
    # touch -t 08301300 file1
    ```

- cp 명령어

    ```bash
    # cp file1 file2
    # cp file1 dir1
    # cp -r dir1 dir2
    ```

- mv 명령어

    ```bash
    # mv file1 file2
    # mv file1 dir2
    # mv dir1 dir2
    ```

- rm 명령어

    ```bash
     # rm -rf dir1
    ```

### touch 명령어

---

파일의 이름을 지정하였다면 기존에 존재하지 않는 빈 파일을 만들어주고 기존에 존재하는 파일이라면  지정된 파일이나 디렉토리의 수정시간(mtime, Modify Time)이나 접근시간(atime, Access Time)등을 현재 시간으로 업데이트 시켜준다.

만약 touch 명령어에 -t 옵션을 사용 하여 파일이나 디렉토리의 수정시간을 특정한 시간으로 변경 가능하다.

(해커가 침입하여 파일을 수정하고 아래의 옵션을 통해 수정과 접근 시간을 바꿔놓을 수도 있다.)

[명령어 형식]

```bash
# touch file2             /* file2 파일 1개 생성 */
# touch file1 file2       /* file1, file2 파일 2개 생성 */
# touch -t 08081230 file1 /* file1 수정 시간 변경(월,일,시,분) */
```

```bash
# touch -t 08301300 file2
# ls -l file2
-rw-r--r--. 1 root root 2707  8월 30 13:00 file2
# stat file2
  File: file2
  Size: 2707      	Blocks: 8          IO Block: 4096   일반 파일
Device: fd00h/64768d	Inode: 3093471     Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Context: unconfined_u:object_r:default_t:s0
Access: 2020-08-30 13:00:00.000000000 +0900
Modify: 2020-08-30 13:00:00.000000000 +0900
Change: 2020-11-27 09:54:46.716119650 +0900
 Birth: -
/* 누군가 touch를 통해서 변경했다는 것을 Access와 Modify의 000000000을 통해 알 수 있다 */
```

**한번에 여러 파일 생성하는 방법**

```bash
# touch file{1..100}  /* file1 ~ file100까지 생성함 */
```

**[명령어 옵션]**

옵션 : 설명

-a :                                                  최근 파일 사용기간만 변경

-c :                                                  파일을 생성하지 않는 명령어

-d [시간] :                                       현재 시간 대신 지정한 시간(시분)으로 변경

-m :                                                 최근 파일 변경 시간만 변경 (파일 수정시간)

-r [파일] :                                        현재 시간 대신 지정한 파일의 시간으로 변경

-t MMDDhhmm [[CC]YY][.SS] :       현재 시간 대신 지정한 시간(월일시분)으로 변경

### cp 명령어

---

파일이나 디렉토리의 내용을 다른 파일 또는 다른 디렉토리에 복사 할 때 사용. 파일을 복사하는 것은 물리적으로 새로운 파일을 하나 생성하며 새로운 파일의 이름과 새로운 inode, 복사된 데이터 블록을 가지게 된다.

[명령어 형식]

```bash
# cp file1 file2   /* file1 파일내용을 file2로 생성 */
# cp file1 dir1   /* file1 파일내용을 dir1디렉토리에 file1 생성 */
# cp -r dir1 dir2 /* dir1 디렉토리를 dir2디렉토리로 생성 */
# cp 원본 타겟
```

**옵션 : 내용**

**-a : 원본 파일의 속성, 링크 정보를 유지 하면서 복사**
-b : 복사할 대상을 덮어쓰거나 지울 때를 대비해서 백업 파일 만듦 백업파일의 파일명 뒤에는 ~가 표시된다.
-d : 심볼릭 파일 자체를 심볼릭 정보와 함께 복사할 때 사용
`-f : 복사할 파일이 존재할 때 삭제하고 복사(덮어쓰기)`
**-i :** 복사할 파일이 존재하는 경우 복사할 것인지 물어봄
-l :디렉토리가 아닌 경우 복사 대신 하드 링크로 만듦
**`-p :** 원본 파일의 소유, 그룹, 권한, 허용 시간을 보존한 채로 복사`
**`-r :** 서브 디렉토리 내에 있는 모든 파일까지 통째로 복사`
-s : 디렉토리가 아닌 경우 복사 대신 심볼릭 링크로 만듦
-u : 대상 파일보다 원본 파일이 새로운 것일 때 복사
`-v : 복사 상태를 보여줌`

**파일에 대한 inode를 확인**

```bash
■ 파일의 일반적인 구조(EX: 일반 파일)

                 +-------------+
      file1 ---->| Inode       |   정보 블럭
                 +-------------+
                 |             |
                 | Data Block  |   데이터 블럭
                 |             |
                 +-------------+

■ Inode Number ?
```

```bash
# cd /test 
# rm -rf /test/* 

# touch file1 
# ls -li file1
4039445 -rw-r--r-- 1 root root 0 Jan 26 11:34 file1

# cp file1 file2 
# ls -li file2      /* 복사하면서 inode가 바뀐 걸 볼 수 있음. */
4039452 -rw-r--r-- 1 root root 0 Jan 26 11:35 file2
```

cp -r 옵션

```bash
# cd /test 
# rm -r /test/* 

# mkdir dir1 
# touch dir1/file1 dir1/file2 

# cp -r dir1 dir2 
# ls -lR
drwxr-xr-x 2 root root 4096 Jan 26 11:36 dir1
drwxr-xr-x 2 root root 4096 Jan 26 11:37 dir2

./dir1:
total 0
-rw-r--r-- 1 root root 0 Jan 26 11:36 file1
-rw-r--r-- 1 root root 0 Jan 26 11:36 file2

./dir2:
total 0
-rw-r--r-- 1 root root 0 Jan 26 11:37 file1
-rw-r--r-- 1 root root 0 Jan 26 11:37 file2

# cp -r dir1 dir2 
# ls -lR 
	# cp -r /home/fedora/test1 /tmp/fedorahomefile
	# cp -r /test /tmp
```

파일 덮어쓰기(overwrite)

```bash
# cd /test 
# rm -rf /test/*

# mkdir dir1 
# echo "linux200" > file1 
# cat file1
linux200

# touch dir1/file1 /* 동일한 파일명으로 파일 생성 */
# cat dir1/file1   /* 이름만 동일 할 뿐 내용 다름 */
#

# cp file1 dir1    /* 동일한 파일명에 덮어쓰기 */
cp: overwrite `dir1/file1'? y

# ls -lR
.:
total 8
drwxr-xr-x 2 root root 4096 Jan 26 23:39 dir1
-rw-r--r-- 1 root root    9 Jan 26 23:39 file1

./dir1:
total 4
-rw-r--r-- 1 root root 9 Jan 26 23:40 file1

# cat dir1/file1    /* copy 내용 확인 가능 */
linux200

-f 옵션 실습하기
# cp file1 file2
# echo "Linux252" >> file1
# unalias cp 
# cp -f file1 file2 /* 따로 응답없이 덮어쓰기 가능 */

unalias 하지 않고 복사
# which cp
	/usr/bin/cp
# /usr/bin/cp -f cpfile file1
# command cp -f file1 file2   /* command는 alias에 있는 명령어를 무시한다 */
```

**cp -p (원본 파일의 소유, 그룹, 권한, 허용 시간을 보존한 채로 복사**

```bash
# touch file1 
# ls -l
합계 0
-rw-r--r--. 1 root root 0  3월 12 13:02 file1
# chmod 777 file1 /* 파일에 대한 퍼미션 변경 */
# ls -l
합계 0
-rwxrwxrwx. 1 root root 0  3월 12 13:02 file1  파일권한에 대한 변경
# chown .team01 file1
# ls -l
합계 0
-rwxrwxrwx. 1 root team01 0  3월 12 13:02 file1  파일그룹소유자에 대한 변경 확인

# cp file1 file2 
# ls -l
합계 0
-rwxrwxrwx. 1 root team01 0  3월 12 13:02 file1
-rwxr-xr-x. 1 root root   0  3월 12 13:05 file2

# cp -p file1 file3 
# ls -l             /* 퍼미션 값과 생성 시간등을 그대로 이어 받아오고 있다 */
합계 0
-rwxrwxrwx. 1 root team01 0  3월 12 13:02 file1
-rwxr-xr-x. 1 root root   0  3월 12 13:05 file2
-rwxrwxrwx. 1 root team01 0  3월 12 13:02 file3

    
# chmod 777 /test        /* 다른 사용자들이 접근하여 파일을 생성 할 수 있도록 퍼미션 변경 */
# su - fedora 
$ id
uid=1001(fedora) gid=1001(fedora) groups=1001(fedora) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

$ pwd
/home/fedora

$ cd /test 
$ cp file1 file4
$ ls -l
-rwxrwxrwx 1 root   root   0  5월 11 20:30 file1
-rwxr-xr-x 1 root   root   0  5월 11 20:31 file2
-rwxrwxrwx 1 root   root   0  5월 11 20:30 file3
-rwxrwxr-x 1 fedora fedora 0  5월 11 20:32 file4

$ cp -p file1 file5 
$ ls -l
합계 0
-rwxrwxrwx 1 root   root   0  5월 11 20:30 file1
-rwxr-xr-x 1 root   root   0  5월 11 20:31 file2
-rwxrwxrwx 1 root   root   0  5월 11 20:30 file3
-rwxrwxr-x 1 fedora fedora 0  5월 11 20:32 file4
-rwxrwxrwx 1 fedora fedora 0  5월 11 20:30 file5

$ exit 
#
```

```bash
로그 파일(EX: file.log) 비우기
# cp /dev/null file.log 
# cat /dev/null > file.log 
# > file.log 

# cd /test 
# cp /var/log/messages file.log 
# cp /dev/null file.log 
-> y 
# ls –l file.log 
-> 파일의 크기 '0' 확인
```

### mv 명령어

---

파일과 디렉토리의 내용을 다른 파일 또는 다른 디렉토리로 옮길 때 사용하며 파일의 이름이나 디렉토리의 이름을 바꿀 수 있음. 같은 파티션 안에서 파일을 옮긴다는 것은 물리적으로 파일 이름만 변경하며, Inode 정보나 데이터 블록은 그대로 유지가 되고 다른 파티션으로 파일을 옮기는 경우는 새로운 파일 이름과 Inode, 데이터 블록을 할당 받게 됨.

[명령어 형식]

```bash
# mv file1 file2       /* file1 파일이 이름이 file2로 변함 */
# mv file1 dir1        /* file1 파일이 dir1 디렉토리에 하위경로로 이동 */
# mv dir1 dir2         /* dir1 디렉토리가 dir2 디렉토리에 하위경로로 이동 */
```

[명령어 옵션]

**옵션 : 내용**

-b : 복사할 대상을 덮어쓰거나 지울 때를 대비해서 백업 파일 만듦
`-f : 복사할 파일이 존재할 때 삭제하고 복사`
**-i :** 복사할 파일이 존재하는 경우 복사할 것인지 물어봄
-u : 대상 파일보다 원본 파일이 새로운 것일 때 복사
`-v : 파일 옮기기 전의 과정을 보여 줌`

```bash
# cd /test ; rm -rf /test/* 

# touch file1 
# mkdir dir1 
# touch dir1/file2
/test ---+--- file1
				 |
				 +--- dir1-----file2

# mv file1 file3         /* mv를 동일한 디렉토리에서 사용하는 경우에는 이름변경으로 동작한다. */
/test ---+--- file3
				 |
				 +--- dir1-----file2

# mv file3 dir1
/test --- dir1---+-----file2
                 |
				         +-----file3

# mv dir1 dir2
/test --- dir2---+-----file2
				         |
				         +-----file3

# cp -r dir2 dir1
/test -+- dir2---+-----file2
       |         |
       |         +-----file3
       +- dir1---+-----file2
				         |
				         +-----file3

# mv dir1 dir2
/test --- dir2 ---+---- file2
									|
									+---- file3
									|
									+--- dir1 --+-- file2
							                |
							                +-- file3
```

inode 확인

```bash
# cd /test ; rm -rf /test/* 

# touch file1 
# ls -li file1                /* Inode 확인 */
97774 -rw-r--r-- 1 root root 0 Jan 26 23:57 file1

# mv file1 file3 
# ls -li file3                /* Inode 가 변하지 않은 걸 알 수 있음 */
97774 -rw-r--r-- 1 root root 0 Jan 26 23:57 file3
단지 파일의 이름정보만 변경되었다.
```

**여러 개의 파일을 동시에 이동**

```bash
# cd /test 
# touch file1 file2 file3 file4 
# ls
file1 file2 file3 file4

# mkdir dir1 
# mv file* dir1                /* file이라는 파일들을 dir1 디렉토리로 이동 */
# ls dir1
file1 file2 file3 file4
```

### rm 명령어

---

파일과 디렉토리를 지우고자 할 때 사용하며 한꺼번에 여러 개를 지울 수도 있으며 지운 파일들은 되살릴 수 없으므로 주위 해서 사용해야 하는데 -i 옵션을 사용하면 한번 더 묻게 되므로 부주의로 인한 파일 삭제를 막을 수 있으며, 옵션 -r를 사용 시 시스템의 모든 파일이 삭제되는 경우도 있으니 신중하게 사용해야 한다.

[명령어 형식]

```bash
# rm file1        /* file1 파일 1개 삭제 */
# rm file1 file2  /* file1, file2 파일 2개 삭제 */ 
# rm -r dir1      /* dir1 디렉토리 하위경로까지 삭제 */
```

[명령어 옵션]

**옵션 : 설명**

**-f :** 강제로 파일을 지우고 삭제할 파일이 없을 경우에도 아무런 메시지를 보여주지 않는다.
**-i :** 파일을 삭제할 것인지 사용자에게 물어봄
**-r**, -R : 일반파일이면 그냥 지우고 디렉토리일 경우 그 하위경로와 파일을 모두 지움
-v : 삭제되는 파일의 정보를 보여줌

[참고] 비어 있지 않은 디렉토리 삭제

```bash
# rm -rf dir1
```

`rm 명령어를 조심해야 하는 이유`

rm : 삭제

GUI 에서의 삭제 :  휴지통으로 파일이 이동하기 때문에 복구가 가능하다.

CLI 에서의 삭제  :  바로 사라진다.

텍스트 모드에서 파일을 작업하는 경우 rm명령어를 조심해야 한다.

따라서 실제로는 file > mv > rm 단계로 삭제한다.

**rm -r 옵션**

```bash
# cd /test 
# rm -r /test/* 

# mkdir dir1 
# touch dir1/file1 dir1/file2
```

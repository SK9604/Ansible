# 저장

리눅스 환경 저장하는 방법

1. 스냅샷(snapshot)

    빠르게 예전 시점으로 돌아갈 수 있다.

    백업 대용으로 사용시 머신이 망가지는 경우가 존재. 여러개의 시점을 생성하는 경우 디스크 I/O이 많아져 성능이 떨어질 수 있다.

2. OVF Open Virtualization Format

    이기종 플랫폼(windows, mac..)간의 가상머신 이동. 서버로의 이동 등이 자유롭다.

    import, export하는데 시간이 상당히 오래 걸린다.

3. ZIP

    빠르다

    이기종간의 배포 불가능. 파일 자체가 문제가 생길 경우도 존재한다.

# 가상 머신 작업

1. 복사
    - link clone : 원본을 참조하여 생성되는 클론. 용량이 작지만 원본에 문제가 생기는 경우에 사용이 불가능하다.
    - full clone : 원본과 별도의 파일로 생성되는 클론. 원본과 별개이기 때문에 원본에 문제가 생겨도 가상머신 사용에 문제가 없지만 용량 측면에서는 좋지 않다.
2. 호스트이름 설정

    ```bash
    # hostname                                          /* 확인 */
    # hostnamectl set-hostname server2.example.com      /* 변경 */
    ```

3. 네트워크 설정

    [유선 연결됨] → [유선 네트워크 설정] → [유선 켬 옆 설정 버튼] → [IPv4 탭] → [주소에 주소] → 192.168.10.252 입력 → [유선 켬 스위치 껐다 키기]

    ```bash
    # ifconfig
    ip 주소 확인
    # ping www.google.com 
    네트워크 설정 확인
    ```

# 터미널 사용 팁

1. 터미널 글씨 크기 조절

    ```bash
    ctrl + shift + [+]
    ctrl + [-]
    ```

2. Runlevel

    init 0 : 종료

    init 6 : 재부팅

    init 2,3 : 텍스트 모드 (2는 nfs 미지원 (Network File System))

    init 5 : 그래픽 모드

3. 제어 문자

    ctrl + c : 현재 사용중인 프로그램을 인터럽트를 걸어서 종료시킨다

    ctrl + d : 파일의 끝 (EOF(End Of File)), 현재 쉘 종료(Exit)

4. 현재 위치 확인

    ```bash
    # pwd
    ```

5. 명령어 위치 확인

    ```bash
    # which man
    # whereis man   -> 명령어 위치, 도움말 위치
    ```

6. 복사

    드래그 후 휠클릭시 드래그된 문자 복사 후 붙여넣기 된다.

7. 일정시간마다 자동 갱신해서 명령어 결과 보여주기

    ```bash
    # watch -n 1 [명령어]
    1초마다 갱신하여 명령어 정보를 띄워준다
    ```

8. 괄호 사용법

    ```bash
    $(..) : 괄호 안 명령어를 명령어로 인식(텍스트로 인식하지 않고)
    ${..} : 괄호 안 변수를 인식
    ```

9. 하위 디렉토리 트리구조 보기

    ```bash
    # tree
    ```

10. 한번에 여러 CMD 사용

    ```bash
    ; =  하나의 명령줄에 다수의 명령을 순차적으로 실행할 때
    ```

11. 현재 설치되어 있는 모든 패키지 출력

    ```bash
    # rpm -qa
    ```

12. 디스크 사용량 모니터링

    ```bash
    # df -k
    ```

13. 쉘 종료

    ```bash
    # exit [number]  /* 값을 지정해준다면 0은 정상 종료, 1~255는 비정상 종료 */
    ```

# 암호 설정

1. 암호 변경 

    ```bash
    # passwd
    ```

    - 관리자

        모든 사용자의 암호를 변경할 수 있다. 이전 비밀번호를 알 필요 없다. 비밀번호 규칙 무시 가능하다.

    - 일반 사용자

        자신의 암호만을 변경할 수 있다. 이전 비밀번호를 알아야 하며 규칙을 따라야 한다.

    저장 위치

    /etc/passwd 에 저장된다.

    비밀번호를 눈으로 확인하면서 비밀번호 변경하기

    ```bash
    # echo '[설정할 비밀번호]' | passwd --stdin [사용자이름] 
    ※ 비밀번호가 history에 노출되기 때문에 반드시 history를 지울 필요가 있음
    ```

# 명령어

1. 형식

    ```bash
    # [명령어] [옵션] [인자]
    쉘 프롬프트, ls touch tee.. , -l -i -a.. , /var /test...
    ```

    옵션에서 대시바의 개수에 따른 의미

    ```bash
    - : 뒤의 문자를 한 자씩 인식         ex) -all  ->  -a -l -l 과 같음
    -- : 뒤의 문자를 하나의 단어로 인식  ex) --all  ->  all로 인식하여 -a와 같음
    ```

2. 리눅스에서 명령어를 사용하는 이유
    - GUI 사용시 GUI에 사용되는 리소스 점유율이 높다.
    - 서비스 측면에서 더 많은 사용자를 수용할 수 있다.
    - 네트워크 트래픽의 감소
3. 내/외장 명령어

    ```bash
    # whatis [명령어]
    bash_built-in command < 이 내용이 나온다면 이 명령어는 bash 내장 명령어이다.
    # man bash
    내장 명령어들 확인
    ```

    - 쉘 내장 명령어 : bash shell에 같이 존재하는 명령어
    - 쉘 외장 명령어 : /usr/bin /usr/sbin,, 특정 디렉토리에 설치되어 있는 명령어

# 도움말

1. man 명령어

    명령어에 대한 메뉴얼 제공

    ```bash
    # man [명령어]   ex) # man ls
    ```

    man창에서 단축어

    - / : 검색
    - Shift+n , n: 다음/이전 검색어 위치로 이동
    - q : 빠져나오기
    - enter : 한 라인씩 넘어가기
    - space bar : 한 페이지씩 넘어가기

    옵션

    ```bash
    -k : 명령어가 정확히 기억이 안나는 경우 키워드 검색
    		 ex) # man -k calendar
    ```

2. help

    ```bash
    # [명령어] --help
    ```

3. whatis

    ```bash
    # dnf -y install man-db-cron
    # cd /etc/cron.daily
    # ./man-db.cron

    # whatis [명령어]
    	[명령어] (섹션번호)      - 설명
    ```

    섹션번호 의미

    1 - 누구나 실행할 수 있는 명령어

    5 - 파일 포맷

    8 - 시스템 관리자만 실행할 수 있는 관리 명령어

# 운영체제 정보

1. uname 명령어

    ```bash
    # uname [옵션]
    ```

    옵션

    ```bash
    -a : 모든 정보
    -nsr : 호스트이름, 운영체제 종류, 운영체제 릴리즈
    ```

2. 릴리즈 버전

    ```bash
    # cat /etc/redhat-release
    ```

3. uname대신 시스템 정보 확인 명령어

    ```bash
    # hostnamectl
    ```

# 시간

1. date 명령어

    ```bash
    # date
    ```

    일반사용자는 확인만 가능. 관리자는 변경 가능

    - 포맷

    ```bash
    # date +%m%d_%H%M   /* %m : month, %d : day, %H : hour, %M : Minute, %S : second */
    월 일 시 분 연도 순서
    # date 081613002009
    ```

    - 파일에 시간정보 같이 저장하기

    ```bash
    # touch file_`date +%m%d`.log
    # touch file_$(date +%m%d).log
    역따옴표 안에 date 포맷 입력
    ※ 그냥 date만 줄 시(touch `date`) 월, 일, 연도 등이 전부 따로 각 파일의 이름으로 저장된다
    ```

2. rdate 명령어

    8버전 이상에서는 없어진 명령어

    UDP 라 위험하다. 네트워크에서 보낸 시간을 포함시키지 않는 문제가 있다.

     (라우터를 거치면서 네트워크 트래픽이 존재할 경우 딜레이가 생겨 서버에 요청하여 받은 시간과 서버의 시간이 차이가 존재할 수 있다)

    ```bash
    # rdate -s time.bora.net
    타임서버의 시간을 운영체제 시간에 적용
    ```

3. 하드웨어/소프트웨어 시간

    ```bash
    하드웨어 시간   : hwclock --show
    소프트웨어 시간 : date
    ```

    동기화

    ```bash
    # hwclock --systohc   /* system -> hard */
    # hwclock --hctosys   /* hard -> system */
    ```

    하드웨어 시간을 쓰는 경우 : 수은건전지가 다 되어서 시간이 완전 뒤틀려버린 경우 (거의 사용 안함)

4. touch 명령어 (파일의 수정시간 변경)

    ```bash
    # touch -t 08081230 [파일명]  /* 월, 일, 시, 분 */
    ```

# 디렉토리 위치 관련 명령어

1. 현재 위치

    ```bash
    # pwd
    ```

2. 이동 명령어

    ```bash
    # cd [위치]
    .  : 현재 위치
    .. : 상위 위치
    # cd -         /* 바로 이전에 있던 디렉토리로 이동 */
    	$OLDPWD 에 저장되어있다
    ```

    - 절대 경로 : 루트 디렉토리부터 모든 경로를 적어야 한다. `항상 /로 시작`
    - 상대 경로 : 현재 디렉토리부터 경로를 적어야 한다. `. 과 .. 을 사용한다`
3. 홈 디렉토리

    ```bash
    # cd $HOME
    # cd ~
    # cd ~fedora   /* fedora의 홈 디렉토리 */
    # cd ~/fedora  /* 홈 디렉토리 아래 fedora 폴더로 이동 */
    ```

# 디렉토리 내용 관련 명령어

1. ls 명령어

    ```bash
    # ls [옵션] [파일/디렉토리명]   /* 파일 디렉토리 명은 생략가능. 생략시 현 위치의 내용 확인 */

    ```

    옵션

    ```bash
    -l : long. 디렉토리가 지정되는 경우 디렉토리의 내용을 자세히 보여준다. 파일인 경우는 파일의 속성 정보를 자세히 보여준다.
    	-lR: 해당하는 디렉토리명을 출력한 뒤 디렉토리 내부의 파일과 디렉토리를 출력한다.
    	-ld: 현 디렉토리 정보를 자세히 출력
    d|rwxr-xr-x|.|2|root|root|19|11월 26 16:05|dir1
    d             : 파일의 형식을 보여준다.
    		            ls에서 많이 나타나는 파일의 형식
                     - : 일반파일
    			               실행파일, 데이터 파일, 로그, 웬만한 것들은 모두 일반 파일로 분류
                     d : 디렉토리
    				             디렉토리(폴더)
    								 c : 캐릭터 파일
    								 b : 블록 파일
    						    장치파일 : /dev : c 캐릭터 파일 b 블록파일
    rwxr-xr-x     : 파일의 권한
    .             : 보안적인 요소 (ACL 권한이 포함되어 있는지의 유무)
    						    . -> ACL이 설정 되어 있지 않다.
    						    + -> ACL이 설정 되어 있다.
    2             : 링크카운트
    						    디스크에 존재하는 파일에서 몇 개의 접근 지점이 존재하는가?
    root          : 개인 소유자 uid
    root          : 그룹 소유자 gid
    19            : 용량
    11월 26 16:05 : 수정 시간
    dir1          : 파일 이름, 디렉토리 이름
    								접근을 위해서 사용해야 하는 오브젝트
    -------------------------------------------------------------------------------------------------------------------------
    -a : all. 숨김파일(.)도 포함하여 전부 출력
    -i : inode 표시
    -F : 이름 뒤에 / -디렉토리, @ - 링크파일, * - 실행파일
    -h : 사람이 봤을 때 편한 단위로 용량을 보여준다.
    ```

# 디렉토리 생성/삭제 명령어

1. mkdir 명령어

    ```bash
    # mkdir [디렉토리명]
    # mkdir dir1              /* 현 디렉토리에 dir1 디렉토리 1개 생성 */
    # mkdir dir1 dir2         /* 현 디렉토리에 dir1, dir2 디렉토리 2개 생성 */
    # mkdir dir{1..10}        /* 1~10까지 디렉토리 한번에 생성 */
    ```

    옵션

    ```bash
    -p : 디렉토리 경로로 생성
    	ex) # mkdir -p dir2/dir3/dir4/dir5/dir6
    ```

2. rmdir 명령어

    ```bash
    # rmdir [디렉토리명]
    ```

    ❗ 디렉토리가 비어있지 않으면 삭제 불가능

3. rm -rf 명령어

    삭제 명령어

    디렉토리가 비어있지 않아도 사용 가능

# 파일 생성

1. touch 명령어

    ```bash
    # touch [파일 이름]
    # touch .[파일 이름]        /* 숨김파일로 생성 */
    # touch [파일이름{1..10}]   /* 1~10번 파일 한번에 생성 */
    ```

2. cp 명령어

    복사하는 명령어

    ```bash
    # cp file1 file2    /* file1 파일 내용으로 file2 생성 */
    # cp file1 dir1     /* file1 파일 내용으로 dir1폴더 아래 file1이름으로 생성 */
    ```

    옵션

    ```bash
    -f : 복사할 파일이 존재할 때 삭제하고 복사(덮어쓰기)
    -p : 원본 파일의 소유, 그룹, 권한, 허용 시간을 보존한 채로 복사
    -r : 서브 디렉토리 내에 있는 모든 파일까지 통째로 복사
    -v : 복사 상태를 보여준다.
    ```

3. mv 명령어

    파일의 디렉토리를 이동할 때 사용하는 명령어

    ```bash
    # mv file1 file2  /* file1 파일이 이름이 file2로 변함 */
    # mv file1 dir1   /* file1 파일이 dir1 디렉토리 하위경로로 이동 */
    # mv dir1 dir2    /* dir1 디렉토리가 dir2 디렉토리 하위경로로 이동 */
    # mv file* dir1   /* file로 시작하는 모든 파일을 dir1 디렉토리 하위경로로 이동 */
    ```

    옵션

    ```bash
    -f : 복사할 파일이 존재할 때 삭제하고 복사(덮어쓰기)
    -v : 파일 옮기기 전의 과정을 보여준다.
    ```

4. cat 명령어

    ```bash
    # cat file1 file2 > file3  /* file1과 file2 내용을 합쳐 file3으로 저장 
    ```

# 파일 정보

1. file

    ```bash
    # file *
    현 디렉토리의 모든 파일의 형식을 확인한다.
    ```

2. stat

    ```bash
    # stat [파일명]
    파일의 세부 정보를 볼 수 있다. 접근시간. 수정시간, inode 변경 시간(ls -l 정보가 변경될 때)
    accesstime, modifytime 이 000000으로 되어있다면 누군가 touch로 임의로 시간을 변경했음을 알 수 있다.
    ```

# 파일 내용 확인

1. cat 명령어

    텍스트 파일을 읽고, 결합하고 표준 출력으로 내보내는 명령어이다.

    ```bash
    # cat file1          /* file1 파일 내용을 출력 */
    # cat file1 file2    /* file1, file2 파일 내용을 출력 */
    ```

    옵션

    ```bash
    -n : 줄 번호 함께 출력
    ```

2. strings 명령어

    바이너리 파일을 읽을 때 사용하는 명령어이다.

    ```bash
    없는경우 설치 필요
    # dnf -y install binutils
    # strings -f /bin/ls
    ```

    옵션

    ```bash
    -f : 파일 이름 출력
    ```

3. more 명령어

    큰 파일을 출력할 때 화면 크기 페이지 단위로 출력한다. cat와 달리 모든 출력결과가 한번에 표시되지 않고 한 페이지씩 걸려 확인 가능하다.

    ```bash
    # more file1  /* file1 파일을 출력 */
    mannual 페이지의 단축키와 동일하게 적용됨
    # CMD | more
    ```

4. head 명령어

    파일의 시작부분의 몇 줄을 출력하고자 할 때 사용한다.

    ```bash
    # CMD | head -10  /* 10줄 출력 */
    # head -n 10 /etc/passwd
    # head -10 /etc/passwd
    ```

    옵션

    ```bash
    -n : 왼쪽 행에서부터 출력할 행 수를 지정
    ```

    헤더 출력

    ```bash
    # ps -ef | head -1 ; ps -ef | grep sshd
    ```

5. tail 명령어

    파일의 마지막 부분의 몇 줄을 출력하고자 할 때 사용한다.

    ```bash
    # tail -10 /etc/passwd
    # CMD | tail -10
    ```

    옵션

    ```bash
    -f : 파일의 크기가 변할때마다 추가된 정보를 출력한다.
    ```

6. wc 명령어

    CMD 결과 값의 문자, 단어, 라인 수를 출력한다.

    ```bash
    # CMD | wc -l   /* 라인수 출력 */
    # CMD | wc -w   /* 단어수 출력 */
    # CMD | wc -c   /* 문자수 출력 */
    ```

7. awk 명령어

    CMD 결과 값의 몇번째 필드만 뽑을 것인지 확인한다.

    ```bash
    # CMD | awk '{print $1}'  /* 첫번째 필드만 뽑아라 */
    ```

# 삭제

1. rm 명령어

    삭제시 정말 바로 삭제된다

    때문에 보통 mv로 한 디렉토리로 이동 시키고 일정 시간이 지나면 삭제되도록 한다.

# 유저, 그룹 관리

1. su 명령어 (switching user)

    다른 사용자의 권한으로 쉘을 실행한다. 서버에 접속한 상태에서 로그아웃 없이 다른 사용자로 전환할 수 있다.

    관리자 : 비밀번호 없이 접속 가능

    일반 사용자 : 비밀번호 알아야 접속 가능

    ```bash
    # su [유저이름]
    # su - [유저이름]
    ```

    su 명령어에 '-' 기호 없이 다른 사용자로 전환하는 경우 지정된 사용자로 전환이 되지만 이전 사용자가 쓰고 있던 export 변수들의 설정이 그대로 따라온다.

2. id 명령어

    사용자의 uid, gid, groups을 보여준다.

    ```bash
    # id
    ```

    옵션

    ```bash
    -g : gid 출력
    -u : uid 출력
    -n : -u나 -g와 함께 사용하여 숫자대신 이름 출력
    ```

3. groups 명령어

    현재 사용중인 사용자의 그룹을 보여준다.

    ```bash
    # groups
    # gorups [유저이름], ..
    ```

    그룹에 사용자 추가

    ```bash
    # adduser -G [group] [user]
    ```

# 로그인 정보 관련 명령어

1. last 명령어 : 서버를 이용하는 각 계정 사용자들의 로그인 정보를 보여주는 명령어이다.

    ```bash
    # last
    # last root
    # last -5   /* 5행 결과만 */
    # last -R   /* 호스트(IP 주소) 접속기록을 제외한 결과 출력 */
    # last -a   /* 호스트 정보(IP 주소)를 맨 마지막에 출력 */
    ```

    옵션

    ```bash
    -f : 지정한 파일에서 정보를 불러온다.
    		 log 파일은 시간이 지나게 되면 스케쥴러, 로그 용량 관리에 의하여 백업되고 새로운 파일로 다시 시작하게 된다.
    -R : 호스트(ip주소) 접속기록을 제외한 결과 출력
    -a : 호스트 정보(ip주소)를 맨 마지막에 출력
    ```

    -f 옵션을 사용하는 이유

    ```bash
    wtmp < 시작파일
    시간이 지나서 백업
    wtmp.0 < 기존 파일 백업
    wtmp < 새로운 파일 시작

    이후에 기존의 로그 파일은 wtmp.0를 읽으려해도 새로운 파일인 wtmp파일만 접근을 시도한다

    기존에 존재하던 wtmp.0 (백업파일)을 읽고 확인하기 위해서 필요한 옵션이 -f 옵션이다.
    ```

2. lastlog 명령어 : 계정 단위로 마지막 접속 기록을 확인하는 명령어

    ```bash
    # lastlog
    # lastlog -u feodra /* 지정한 로그인명의 lastlog 정보만을 보여준다. */
    # lastlog -t 3 /* 지정한 날짜기간 안에 로그인한 정보만을 보여준다 */
    ```

3. lastb 명령어 : 사용자가 접속에 실패한 로그를 확인하는 명령어로 관리자만 확인 가능하다.

    ```bash
    # lastb
    ```

4. who 명령어 : 누가 로그인해 있는지, 어떤 장치를 이용하고 있는지 등 정보

    /var/run/utmp 의 내용을 보여준다.

    ```bash
    # who      /* 현재 시스템에 접속 중인 모든 사용자 */
    # who -r   /* 현재 사용자의 Runlevel 확인 */
    # who am i /* 로그인한 사용자 정보 확인 */
    # who -H   /* 헤드라인과 같이 출력 */
    # whoami   /* 현재 사용자명 확인 , 유효사용자를 확인한다*/
    ```

5. w 명령어 : 시스템에 로그인한 사용자가 어떤 명령어를 실행하고 있는지 알아보는 명령어이다.

    ```bash
    # w
    # w user01
    ```

# 반복문

1. while

    ```bash
    while true : 반복문을 시작
    do         : 여기서부터 본문
    action     : 반복문에서 실제로 동작하는 부분
    done       : 여기까지가 본문
    ```

# 로그

1. tlog 명령어

    모니터에 입 출력되는 내용을 시간 단위로 저장하고 json format으로 저장한다. 이후에 해당 파일을 재생하여 이전에 작업한 것을 실시간으로 확인 가능하다. tlog 자체로는 명령어가 존재하지 않는다.

2. script 명령어

    모니터에 출력된 내용을 저장하여 이후에 확인 용도로 사용한다.

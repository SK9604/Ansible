# PKI 암호화 통신

```jsx
A-------------------------------------------------------------B
서로 통신
평문이 아닌 암호화 통신
PKI -> 
A-Public >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> A-Public B
                                               A의 공개키를 보유
                                 A의 공개키로 B의 공개키를 암호화
A <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< A-Public[B-Public]
B는 A의 공개키로 암호화한 
자신의 공개키 B-Public 키를 전송
A-Public[B-Public] A는 해당 키를 자신의 private 키로 해독 가능
해독 > B-Public
둘 다(A, B) 서로의 공개키를 보유
->
비밀키 생성
B로 전송
B-Public[비밀키]>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> B
                                               B-Public[비밀키]
대칭키----------------------------------------------------대칭키
통신 ----------------------------------------------------- 통신
통신이 종료되고 나면 사용하던 대칭키 폐기
대칭 키의 전송을 위해 비대칭 방식
비대칭 + 대칭 같이 사용한다.
```

### 인증서란? ( 사이트와 인증기관의 구분을 명확히 생각하도록 하자. )

- 모든 개인키는 오직 자기 자신만 소유한다. 즉, 통신을 위한 공개키를 대중에게 공개해야 한다.
- 공인 인증 기관 출현
- 공인 인증 기관은 인증서를 발행해 주지만, 주 목적은 요청한 사이트에게 해당하는 인증기관 **개인키와** 인증기관 **공개키** 쌍을 만든다. **사이트에는** 인증기관 **개인키로 암호화한 인증서(사이트 공개키 + 사이트정보)를 발행 / 웹 브라우저에는** 인증기관 **공개키를 발행하여 암복호화 할 수 있도록 구성**
- 사이트 개인키(Private Key) 를 보증(SSL 통신)하기 위해서 그 쌍이 되는 사이트 공개키(Public Key)가 바로 인증서에 들어있음.
- 또한 '공인 인증 기관의 전자 서명'이 바로 인증서에 들어 있음.
- 즉, **인증서**는 사이트 **공개키 + 공인 인증 기관의 전자 서명**
- **인증서는 공개된 위치에 저장해서 요청하는 사람에게 내려보내 줄 수 있는 시스템이 갖춰져 있다. (보통 공인 인증 기관의 LDAP 에 저장)**
- **이를 PKI(Public key infrastructure) 라고 한다.**

### 인증서의 Root CA

- SSL의 기본 구조는 당신이 인증서를 서명한 사람을 신뢰한다면, 서명된 인증서도 신뢰할 수 있다는 것
- 이것은 마치 트리(Tree)와 같은 구조를 이루면서 인증서끼리 서명하게 된다.
- 인증서를 발행한 기관을 **Root Certification Authority**(Root CA)라고 부르며, 널리 알려진 인증 기관(Verisign, Thawte, Entrust 등)의 Root CA 인증서는 **웹브라우저에 기본적으로 설치**되어 있다.
- Root CA의 인증서는 누가 서명을 했을까? 모든 **Root CA 인증서는 자체 서명**(Self Signed)되어 있다.
- 여기서 서명이란 **신뢰할 수 있다고 서명하는 것**을 뜻함.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/728be214-f172-4666-a5aa-b429b126556c/_2020-04-12__2.17.53.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/728be214-f172-4666-a5aa-b429b126556c/_2020-04-12__2.17.53.png)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/694ce177-a408-4661-b63e-16fabf545b8a/_2020-04-12__2.18.10.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/694ce177-a408-4661-b63e-16fabf545b8a/_2020-04-12__2.18.10.png)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/815a4927-51f7-47f9-8e87-a1167babc996/_2020-04-12__2.18.22.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/815a4927-51f7-47f9-8e87-a1167babc996/_2020-04-12__2.18.22.png)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f55965bd-37a7-48fb-8a07-cddb567a882f/_2020-04-12__2.18.33.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f55965bd-37a7-48fb-8a07-cddb567a882f/_2020-04-12__2.18.33.png)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d3b22bd6-87eb-4c99-844e-2188188d4252/_2020-04-12__2.18.46.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d3b22bd6-87eb-4c99-844e-2188188d4252/_2020-04-12__2.18.46.png)

언제 대칭 암호화를 사용하고, 언제 비대칭 암호화를 사용할까? 비대칭 암호화는 클라이언트와 서버 간 시크릿을 교환할 때 사용한다. 실생활에서는 양방향 비대칭 통신이 필요하지 않다. 당사자 중 한쪽이(서버라고 하자) 일련의 키를 가지고 있으므로 암호화된 메시지를 받을 수 있다는 것만으로 충분하다. 이는 공개 키로 암호화한 정보는 개인키를 사용해야만 복호화되기 때문에 클라이언트에서 서버로 향하는 단방향으로만 정보를 보호한다. 그러므로 서버에서만 그 정보를 복호화할 수 있다. 반대 방향은 보호되지 않는다. 서버의 개인 키로 암호화된 정보는 공개 키를 가진 누구든지 복호화할 수 있다. 상대편(클라이언트라고 하자)은 서버의 공개 키를 사용해 무작위로 생성된 세션 시크릿을 암호화해 통신을 시작한다. 그 다음 암호문을 다시 서버로 보내고, 서버는 다시 자신의 개인 키로 복호화하면 그 시크릿을 갖게 된다.

대칭 암호화는 비대칭 암호화보다 훨씬 빠르기 때문에 전송 중인 실제 데이터를 보호하는 데 사용된다. 앞서 교환한 시크릿으로 정보를 가진 두 당사자(클라이언트와 서버)만 해당 정보를 암호화하고 복호화할 수 있다.

이 때문에 핸드셰이크handshake의 첫 비대칭 부분이 키 교환이라고 불리며, 실제 암호화된 통신은 사이퍼 메서드cipher methods라는 알고리즘을 사용한다.

## SSL Connection (인증과정) 너무 간단히 잘되어있는 설명

**SSL이 수행되는 단계는 총 3가지로 분류**된다.

**○ SSL Server Authentication**

사용자의 **웹브라우저가 상대방의 웹서버를 인증하는 단계**이다.

SSL을 지원하는 웹브라우저는 표준 공용키 암호화 기법을 사용하여 서버의 인증서와 공용 ID를 실제로 브라우져가 신뢰하는 인증기관(Trusted CA)으로부터 발급받았는지 여부를 인증하는 기능을 내장하고 있다.

**○ SSL Client Authentication**

**웹서버가 자신에게 요청한 클라이언트를 인증하는 단계**이다.

서버 인증 시에 사용했던 동일한 기법으로 인증하는데 서버에 내장된 SSL 지원 소프트웨어나 서버 앞에 배치된 SSL 하드웨어는 클라이언트의 인증서와 공용 ID 를 실제로 서버가 신뢰하는 인증기관(Trusted CA)으로부터 발급 받았는지 여부를 인증하는 기능을 내장하고 있다.

**○ Encrypt Connection**

서로에 대한 인증단계 이후 정상적으로 종결되면 **클라이언트와 서버사이에 교환**되는 모든 데이터는 사적인 내용을 보호하기 위한 암호화를 요구받는다. 또한 SSL커넥션을 통해 암호화된 데이터 역시 전송 중 변경을 방지(Message Integrity)하기 위해 Hash 알고리즘이라고 불리는 기술에 의해 보호된다.

위의 3가지 단계를 기반으로 실제로 구현되는 순서는 다음과 같으며, 다음 순서를 진행하기에 앞서 **SSL 또한 TCP 프로토콜에 기반을 두고 있으므로 반드시 TCP 3 Handshake는 이루어져 있어만 한다.**

### 무결성

HTTPS로 해결하는 또 다른 문제는 데이터 무결성integrity이다. 즉, (1)전체 정보가 잘 도착했으며, (2)전송 중에 누가 변조하지 않았음을 보장한다. 정보가 잘 전송되었음을 보장하기 위해 메시지 다이제스트message digest 알고리즘을 사용한다. 교환된 각 메시지의 메시지 인증 코드message authentication codes, MAC 계산은 암호화 해싱 프로세스다. 예를 들어 MAC(태그라고도 한다) 획득은 실질적으로 다음의 작업이 불가능(보통 사용하는 용어는 ‘실행 불가능infeasible’)하게 하는 방식이다.

- 태그에 영향을 끼치지 않고 메시지 변경하기
- 두 개의 다른 메시지에 동일한 태그 생성하기
- 프로세스를 거꾸로 돌려 태그에서 원래 메시지 획득하기

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/26db3005-4d64-45a6-b4fa-623a46ca9060/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/26db3005-4d64-45a6-b4fa-623a46ca9060/Untitled.png)

**빨간 네모 = (2번~11번)**

1. TCP 3 Way Handshake

2. 클라이언트는 서버에게 지원 가능한(암호, 키교환, 서명, 압축)방식을 서버에게 알려준다.(Client Hello)

3. 서버는 클라이언트에게 지원 가능한(암호, 키교환, 서명, 압축)방식을 응답해 준다. (Server Hello)

4. 서버는 공개키(RSA 암호용)가 포함된 서버 인증서를 클라이언트에게 발송한다.

서버는 클라이언트가 자신이 적합한 서버인지를 인증할 수 있도록 공신력 있는 기관으로부터 발급받은 자신의 공인 인증서를 발송한다. 이때 일반적으로 서버 인증서와 함께 서버의 공용키가 클라이언트측에 전달된다. 만약 클라이언트에 대한 인증을 필요로 하는 트랜잭션이라면 이에 대한 요청도 함께 발송한다.

5. 만약 서버가 클라이언트 인증서를 요구할 때 이에 대한 요청도 함께 발송한다.

6. Server Hello 완료

7. 서버가 클라이언트 인증서를 요구할 경우 인증서를 서버로 전송한다.

```jsx
    서버                클라이언트
hello packet -> 상대방에게 알려주는 정보
raw data > 타겟쪽에서 분석 > 자신에게 맞는 정보로 변경
```

8. 클라이언트는 전송받은 서버 인증서에 대해 브라우저에 내장된 신뢰 기관으로부터 발급 여부를 확인한 후 암호화키로 사용될 세션 키(대칭키)를 랜덤으로 생성하여 공개키로 암호화해 서버로 전송한다.

서버의 인증서에 대해 클라이언트는 브라우저내에 저장되어 있는 신뢰기관으로부터의 발급여부를 확인하고 암호화에 사용될 Session Key를 생성해 서버 공용키(공개키)로 Session Key를 암호화 하여 서버에게 전달한다. 또한 암호화된 Session Key와 함께 브라우저가 지원할 수 있는 Chiper Suite, 즉 암호화 기법 리스트와 함께 서버측에서 클라이언트의 인증서를 요청한 경우 클라이언트의 인증서를 발송한다.

9. 서버는 자신의 개인 키로 클라이언트에게 전송받은 세션키(대칭키)를 복호화한다.

10. 서버는 협상 과정에서 전송된 모든 메시지에 대하여(암호, 키교환, 서명, 압축)방식을 다음부터 적용할 것을 알리는 종결 메시지를 발송한 후 데이터 전송단계로 이동한다.

서버는 Chiper Suite를 받아들이고(또는 거부하고) Finished message를 클라이언트로 전송한 후 데이터 전송단계로 이동

서버는 클라이언트로부터 클라이언트 브라우저가 지원하는 **암호화 기법 리스트**를 받고 클라이언트에게 종결 메시지를 보내고 데이터 전송단계로 돌입한다. 여기까지 정상적으로 완료가 되면 **클라이언트가 생성한 Session Key를 클라이언트와 서버가 모두 공유**하게 된다.

- 여기까지 모두 정상적으로 완료된다면, 클라이언트와 **서버 모두 동일한 세션키(대칭키)를 공유**하게 되는 것이다.

11. 클라이언트는 협상 과정에서 전송된 모든 메시지에 대하여(암호, 키교환, 서명, 압축) 방식을 다음부터 적용할 것을 알리는 종결 메시지를 발송한 후 데이터 전송단계로 이동한다.

12. 앞 단계에서 서로 공유된 세션키로 암호화된 전송 과정이 시작된다.

### 인증

인증authentication은 어떨까? 공개 키 인프라의 실제 애플리케이션이 갖는 문제는 양쪽 당사자가 (물리적으로 떨어져 있는) 상대편이 실제로 누구인지 알 방법이 없다는 것이다. 그래서 상대편의 신원을 보증하기 위해 상호 신뢰할 수 있는 제3자, 즉 인증 기관certificate authority, CA이 필수다. 인증 기관은 `example.com`이라는 도메인 이름(고유한 식별자)이 공개 키 `XXX`와 연결되어 있음을 기술한 인증서를 발행한다. 경우에 따라서는(조금 뒤 설명하는 EV와 OV 인증서) 인증 기관은 그 도메인을 특정 회사가 통제하는지도 확인한다. 이 정보는 인증 기관 X(인증서 발행)에서 보증하고, 이 보증은 날짜 Y(시작일)와 날짜 Z(만료일)사이에서 유효하다. 이 모든 정보는 HTTPS 인증서라는 문서 하나에 들어간다. 이해를 돕기 위해 나라에서 국민에게 발행하는 ID나 여권을 예로 들면, 해당 정부를 신뢰하는 모든 신뢰 당사자는 ID를 가진 사람의 신원 또한 수용한다(가짜 ID인 경우는 이 예의 범위 밖이다).

인증 기관은 인증서를 서명하기 위해 신뢰된 조직이다. 윈도우와 맥OS, iOS, 안드로이드 등의 운영체제뿐만 아니라 파이어폭스 브라우저는 신뢰된 인증서 목록을 갖고 있다. 사용하는 브라우저에서 신뢰하는 인증 기관을 확인할 수 있다.

- **파이어폭스** 설정 → 개인 정보 및 보안 → 인증서 → 인증서 보기 → 인증 기관
- **윈도우** 제어판 → 인터넷 옵션 → 내용 → 인증서 → 신뢰할 수 있는 인증 기관/중간 인증 기관
- **맥** 응용 프로그램 → 유틸리티 → 키체인 접근 → 카테고리 내 인증서

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a9b5914e-a580-4ac9-a912-7be278ec7a02/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a9b5914e-a580-4ac9-a912-7be278ec7a02/Untitled.png)

목록에 없는 다른 인증 기관도 추가할 수 있는데, 이는 자체 서명된 인증서와 같은 사설 인증서를 사용할 때 유용하다(뒤에서 다룬다).

대개 일반적인 상황에서 서버 쪽에서만 클라이언트에 신원을 증명한다. 예를 들어, 전자상거래 웹사이트와 고객의 관계에서 해당 웹사이트만 인증서가 필요하다. 전자 정부와 같은 경우는 서비스를 요청하는 서버와 클라이언트 모두 자신의 신원을 증명해야 한다. 이는 양쪽 당사자 모두 다른 당사자를 인증하는 데 인증서를 사용해야 한다는 뜻이다(이 설정 또한 이 글의 범위 밖이다).

## HTTPS 인증서 유형

HTTPS 인증서에는 여러 유형이 있으며 다음과 같이 나눌 수 있다.

### 1. 신원 검증

**DVDomain validated** 가장 일반적인 유형의 인증서인 DV 인증서는 도메인이 특정 공개 키와 일치하는지 확인한다. 브라우저는 서버와 보안 연결을 수립하고 닫힌 자물쇠를 표시한다. 이 표시를 클릭하면 ‘현재 웹사이트는 소유자 정보를 제공하지 않고 있습니다’를 보여준다. 도메인 외의 다른 특별한 요구 사항은 없다. DV 인증서는 해당 도메인에 대한 알맞은 공개 키인지를 간단히 확인하며, 브라우저에서는 법적 신원을 보여주지는 않는다. DV 인증서는 무료이거나 저렴(10달러/년)하다(아래 Let’s Encrypt와 Cloudflare 부분 참고).

**EVExtended validation** EV 인증서는 웹사이트의 법적 신분을 검증한다. EV 인증서는 가장 신뢰할 수 있는 유형의 인증서다. 인증 기관에서 도메인을 관리하는 이의 법적 신원을 확인한 후 얻을 수 있다. 법적 신원은 다음의 조합으로 확인한다.

- 도메인 관리(예: DV 인증서)
- 회사가 등록되었고 현재 유지 상태인지 확인할 수 있는 공인된 사업 기록
- D&B(Dunn and Bradstreet), 세일즈포스 connect.data.com, 전화번호부 등에 등재된 자영업 정보
- 확인 전화
- 인증서의 모든 도메인 이름 검사(와일드카드는 EV 인증서에서 명시적으로 금지). 닫힌 자물쇠 표시뿐만 아니라 EV HTTPS 인증서는 URL 앞에 검증된 법적 신원의 이름(등록된 회사)을 표시한다. iOS 사파리와 같은 일부 기기는 검증된 법적 신원만 표시하고 전체 URL은 무시한다. 해당 표시를 클릭하면 이름과 주소 같은 조직에 대한 자세한 정보를 보여준다. 비용은 연간 150달러에서 300달러 정도다.

**OVOrganization validated** EV처럼 OV 인증서는 웹사이트의 법적 신분을 검증한다. 하지만 EV 인증서와 달리 OV HTTPS 인증서는 UI에서 확인된 법적 이름을 표시하지는 않는다. 결과적으로 OV 인증서는 높은 검증 요구 사항 대비 사용자에게 보여주는 이점이 없기 때문에 인기가 덜하다. 가격은 연 40달러에서 100달러 정도다.

### 2. 다루는 도메인 수

이전 HTTPS 인증서는 일반적으로 CN 필드에서 하나의 도메인을 다뤘다. 나중에 ‘주체 대체 이름Subject Alternative Name, SAN’ 필드가 추가되어 하나의 인증서에서 추가적인 도메인을 다루도록 허용했다. 요즘 만드는 모든 HTTPS 인증서는 동일하다. 단일 도메인 인증서에도 해당 단일 도메인에 대한 SAN(그리고 그 도메인의 www 버전에 대한 두 번째 SAN)이 있다. 하지만 많은 인증서 공급 업체는 여전히 과거의 관행을 이유로 단일 도메인과 다중 도메인 HTTPS 인증서를 팔고 있다.

1. **단일 도메인** 가장 흔한 인증서 유형으로 `example.com`과 `www.example.com와 같은` 도메인 이름에 유효하다.
2. **다중 도메인(UCC/SAN)** UCC 또는 SAN 인증서로 알려진 인증서 유형으로 도메인의 목록을 다룰 수 있다(지정된 제한까지). 단일 도메인에 대한 제한은 없으며 다른 도메인과 하위 도메인을 혼합할 수 있다. 가격은 보통 정해진 도메인의 수(3~5개)에 추가 비용을 지불하면 더 많이(최대 한도까지) 포함할 수 있는 옵션을 제공한다. 웹사이트의 인증서를 검사하는 클라이언트는 주 도메인뿐만 아니라 모든 추가 도메인을 확인하기 때문에 웹사이트와 관련된 도메인 사용을 권장한다.

    Unified Communications Certificate

3. **와일드카드** 이 유형의 인증서는 주 도메인뿐만 아니라 하위 도메인(`*.example.com`)의 수를 제한 없이 다룬다(예: `example.com`, `www.example.com`, `mail.example.com`, `ftp.example.com` 등). 제한 사항은 주 도메인의 하위 도메인만 다룬다는 점이다.

다음 표에서 사용 가능한 다양한 HTTPS 인증서를 정리했다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ddcf1a15-ef9b-4fae-86e7-7a3fd4bbba3b/_2020-04-12__1.46.42.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ddcf1a15-ef9b-4fae-86e7-7a3fd4bbba3b/_2020-04-12__1.46.42.png)

## 구성

요약하면 HTTPS의 네 가지 구성 요소는 다음의 암호화를 필요로 한다.

1. **초기 키 교환** 비대칭(개인 키와 공개 키) 알고리즘을 사용한다.
2. **신원 인증서(인증 기관에서 발행한 HTTPS 인증서)** 이 인증서는 비대칭(개인 키와 공개 키) 알고리즘을 사용한다.
3. **실제 메시지 암호화** 대칭(미리 공유한 시크릿) 알고리즘을 사용한다.
4. **메시지 다이제스트** 암호 해싱 알고리즘을 사용한다.

이들 각 구성 요소는 서로 다른 키 크기를 사용하는 일련의 알고리즘(이들 알고리즘 중 일부는 사용하지 않음)이 있다. 일부 핸드셰이크의 경우 클라이언트와 서버가 사용할 방식의 조합(수십 개의 공개 키(키 교환) 알고리즘 중 하나, 수십 개의 대칭 키(암호) 알고리즘 가운데 하나와 3개의 메시지 다이제스트(해싱) 알고리즘(2개는 사용 안 함) 가운데 하나를 선택해 수백 가지 조합)에 대한 동의를 요구한다.

예를 들어 `ECDHE-RSA-AES256-GCM-SHA384` 설정은 해당 키를 ECDHEElliptic Curve Diffie-Hellman Ephemeral 키 교환 알고리즘을 사용해 교환한다는 뜻이다. 인증 기관은 RSARivest-Shamir-Adleman 알고리즘을 사용해 인증서를 서명한다. 대칭 메시지 암호화는 256비트 키와 GCM 운영 모드를 갖는 AESAdvanced Encryption Standard 암호를 사용한다. 메시지 무결성은 384비트 다이제스트를 사용하는 SHA 보안 해싱 알고리즘을 사용해 검증한다([포괄적인 알고리즘 조합 목록](https://wiki.mozilla.org/Security/Server_Side_TLS#Cipher_names_correspondence_table)을 사용할 수 있다.) 따라서 몇 가지 구성을 선택할 수 있다.

## 암호화 스위트

사용할 암호화 스위트cipher suite를 결정하는 일은 호환성과 보안 사이의 균형이다.

- 이전 브라우저와 호환성은 이전 암호화 스위트를 지원하는 서버가 필요하다.
- 하지만 대다수의 이전 암호화 스위트는 더 이상 안전하지 않다.

OpenSSL은 암호 강도가 가장 안전한 것에서 가장 약한 것 순서로 위에서 아래로 지원 조합을 나열한다. 클라이언트와 서버 간의 초기 핸드셰이크 동안 양쪽 당사자가 지원하는 조합과 일치하는 것을 발견할 때까지 협상하기 때문에 이런 방식으로 설계했다. 가장 보안이 좋은 조합을 먼저 시도하고 다른 방법이 없다면 점차 더 약한 조합을 쓴다.

서버에서 사용할 암호화 방법을 조언할 때 매우 유용하고 권장하는 자료는 뒤에서 실제 서버 구성에 다룰 [모질라 SSL 구성 생성기](https://mozilla.github.io/server-side-tls/ssl-config-generator/)다.

## 키 유형

ECCElliptic Curve Cryptography 인증서는 RSA 인증서보다 더 빠르고 CPU를 덜 쓰는데, 특히 모바일 클라이언트에는 이런 점이 중요하다. 하지만 아마존의 클라우드프론트CloudFront나 헤로쿠Heroku와 같은 일부 서비스는 이 글을 쓰는 시점에 아직 ECC 인증서를 지원하지 않는다. 256 비트 ECC 키면 충분하다.

RSARivest Shamir Adleman 인증서는 더 느리지만 오래된 다양한 서버와 호환된다. RSA 키는 더 크므로 2048비트 RSA 키가 최소한이다. 4096비트 이상의 RSA 키는 성능에 좋지 않다. 이 인증서는 2048비트 중간 인증 기관에서 서명할 수도 있어 추가적인 보안에 상당한 손상을 준다.

앞서 기술한 내용이 가변적이라는 점과 키 크기의 제약 사항을 주목했을 것이다. 한 서버에서 과부하를 주는 요인이 다른 서버에서는 그렇지 않을 수 있기 때문이다. 성능에 미치는 영향을 확인하는 최선의 방법은 실제 웹사이트와 실제 방문자로 서버의 부하를 모니터링하는 것이다. 시간의 흐름에 따라 성능이 바뀔 것이다.

## 절차

HTTPS 인증서를 얻으려면 다음 단계를 거쳐야 한다.

1. 개인 키와 공개 키 쌍을 만들고 조직과 공개 키에 관한 정보를 포함하는 CSR을 준비한다.

    Certificate Signing Request

2. 인증 기관에 연결해 CSR 기반 HTTPS 인증서를 요청한다.
3. 서명된 HTTPS 인증서를 획득하고 웹 서버에 인증서를 설치한다.

개인 키와 공개 키, CSR과 서명된 HTTPS 인증서 등 공개 키 인프라(PKI)의 다른 구성 요소를 포함하는 일련의 파일이 존재한다. 복잡성을 더 높이는 방편으로 동일성 여부를 확인하는 데 다른 당사자는 다른 이름(그리고 파일 확장자)을 사용한다.

정보를 저장하기 위한 두 가지 인기 있는 형식에는 DER과 PEM이 있다. DER은 바이너리이며, PEM은 base64 인코딩된(텍스트) DER 파일이다. 기본적으로 윈도우는 DER 형식을 직접 사용하며, 오픈소스 진영(리눅스, 유닉스)은 PEM 형식을 사용한다. 두 가지 형식 서로 간에는 변환할 수 있는 도구(OpenSSL)가 있다.

설명 과정에서 예제로 사용할 파일은 다음과 같다.

- `example.com.key` 이 PEM 형식 파일은 개인 키를 포함한다. 확장자 `.key`는 표준이 아니므로 일부에서는 사용한다. 시스템 슈퍼 유저만이 보호하고 접근할 수 있다.
- `example.com.pub` 이 PEM 형식 파일은 공개 키를 포함한다. 이 파일은 개인 키에서 생성될 수 있기 때문에 실제로는 필요하지 않다. 여기서는 설명 목적으로 포함시켰다.
- ✨`example.com.csr` 이 파일은 인증서 서명 요청이다. 조직 정보와 서버의 공개 키를 포함하는 PEM 형식 파일을 HTTPS 인증서를 발행하는 인증 기관에 보내야 한다.
- ✨`example.com.crt` 이 HTTPS 인증서는 인증 기관이 서명한 것이다. 이 파일은 PEM 형식 파일이며 서버의 공개 키와 조직 정보, 인증 기관 서명, 유효기간, 만료 날짜 등이 들어 있다. 확장자 `.crt`는 표준이 아니다. 다른 일반적인 확장자는 `.cert`와 `.cer`을 포함한다.

파일 이름(그리고 확장자)는 표준이 아니다(원하는 어떤 것도 가능하다). 어떤 구성 요소가 무슨 기능을 하는지 분명하게 보여야 한다고 생각하기 때문에 이 명명 규칙을 선택했다. 명령과 서버 구성 파일에서 적합한 키 인증서를 참조한다면 프로세스 전체에서 어떤 명명 규칙이든 사용할 수 있다.

개인 키는 특정 길이(여기서는 2048비트 사용)의 문자열을 무작위로 생성한 것으로 다음과 같다.

```bash
—–BEGIN RSA PRIVATE KEY—–
MIIEowIBAAKCAQEAm+036O2PlUQbKbSSs2ik6O6TYy6+Zsas5oAk3GioGLl1RW9N
i8kagqdnD69Et29m1vl5OIPsBoW3OWb1aBW5e3J0x9prXI1W/fpvuP9NmrHBUN4E
S17VliRpfVH3aHfPC8rKpv3GvHYOcfOmMN+HfBZlUeKJKs6c5WmSVdnZB0R4UAWu
Q30aHEBVqtrhgHqYDBokVe0/H4wmwZEIQTINWniCOFR5UphJf5nP8ljGbmPxNTnf
b/iHS/chjcjF7TGMG36e7EBoQijZEUQs5IBCeVefOnFLK5jLx+BC//X+FNzByDil
Tt+l28I/3ZN1ujhak73YFbWjjLR2tjtp+LQgNQIDAQABAoIBAEAO2KVM02wTKsWb
dZlXKEi5mrtofLhkbqvTgVE7fbOKnW8FJuqCl+2NMH31F1n03l765p4dNF4JmRhv
/+ne4vCgOPHR/cFsH4z/0d5CpHMlC7JZQ5JjR4QDOYNOpUG51smVamPoZjkOlyih
XGk/q72CxeU6F/gKIdLt6Dx03wBosIq9IAE8LwdMnioeuj18qaVg195OMeIOriIn
tpWP4eFya5rTpIFfIdHdIxyXsd6hF/LrRc9BMWTY1/uOLrpYjTf7chbdNaxhwH7k
buvKxBvCvmXmd6v/AeQQAXbUkdSnbTKDaB9B7IlUTcDJyPBJXvFS1IzzjN6vV+06
XBwHx5ECgYEAyRZLzwnA3bw8Ep9mDw8JHDQoGuQkFEMLqRdRRoZ+hxnBD9V9M0T6
HRiUFOizEVoXxf6zPtHm/T7cRD8AFqB+pA/Nv0ug6KpwUjA4Aihf5ADp0gem0DNw
YlVkCA6Bu7c9IUlE0hwF7RLB7YrryJVJit9AymmUTUUHCQTWW2yBhC8CgYEAxoHS
HGXthin5owOTNPwLwPfU2o7SybkDBKyW69uTi0KxAl3610DjyA/cV2mxIcFlPv1y
HualGd9eNoeCMBy/AUtjzI0K77yeRpjj321rj6k8c8bYWPHH539SiBXLWTY/WQ0w
pxfT3d/Z4QMh5d6p+p5f3UIrXESYQd+fAaG5tNsCgYEAksTdTB4YUT9EsWr6eN9G
jPlclFQUKV3OMvq77bfYvg8EJORz32nnDDmWS7SUjoOtemwutBlMeWbaKk25aMp3
5JNMXuV6apeMJ9Dd8GU7qBUqlIvVK31/96XPvzmnYzWZPqRVwO2HPcRFG3YcJmkg
JmZQyexJvCQ3wFNxiYUm+y0CgYBXQSMhFnCUg4jWbbDcHlnwRT+LnjHrN2arPE3O
eKLfGL6DotmqmjxFaStaRPv2MXMWgAMUsB8sQzG/WEsSaOBQaloAxJJlFIyhzXyE
bi1UZXhMD8BzQDu1dxLI/IN4wE6SDykumVuocEfuDxlsWDZxEgJjWD2E/iXK9seG
yRa+9wKBgEydVz+C1ECLI/dOWb20UC9nGQ+2dMa+3dsmvFwSJJatQv9NGaDUdxmU
hRVzWgogZ8dZ9oH8IY3U0owNRfO65VGe0sN00sQtMoweEQi0SN0J6FePiVCnl7pf
lvYBaemLrW2YI2B7zk5fTm6ng9BW/B1KfrH9Vm5wLQBchAN8Pjbu
—–END RSA PRIVATE KEY—–
```

‘개인 키를 비공개로 유지하자.’ 이 말은 매우 제한된 권한(600)으로 보호하고 누구에게도 드러내지 말라는 의미다.

여기에 대응하는 공개 키는 다음과 같다.

```bash
—–BEGIN PUBLIC KEY—–
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAm+036O2PlUQbKbSSs2ik
6O6TYy6+Zsas5oAk3GioGLl1RW9Ni8kagqdnD69Et29m1vl5OIPsBoW3OWb1aBW5
e3J0x9prXI1W/fpvuP9NmrHBUN4ES17VliRpfVH3aHfPC8rKpv3GvHYOcfOmMN+H
fBZlUeKJKs6c5WmSVdnZB0R4UAWuQ30aHEBVqtrhgHqYDBokVe0/H4wmwZEIQTIN
WniCOFR5UphJf5nP8ljGbmPxNTnfb/iHS/chjcjF7TGMG36e7EBoQijZEUQs5IBC
eVefOnFLK5jLx+BC//X+FNzByDilTt+l28I/3ZN1ujhak73YFbWjjLR2tjtp+LQg
NQIDAQAB
—–END PUBLIC KEY—–
```

CSRCertificate Signing Request은 다음과 같다.

```bash
—–BEGIN CERTIFICATE REQUEST—–
MIICzjCCAbYCAQAwgYgxFDASBgNVBAMMC2V4YW1wbGUuY29tMQswCQYDVQQLDAJJ
VDEPMA0GA1UECAwGTG9uZG9uMRIwEAYDVQQKDAlBQ01FIEluYy4xIDAeBgkqhkiG
9w0BCQEWEWFkbWluQGV4YW1wbGUuY29tMQswCQYDVQQGEwJHQjEPMA0GA1UEBwwG
TG9uZG9uMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAm+036O2PlUQb
KbSSs2ik6O6TYy6+Zsas5oAk3GioGLl1RW9Ni8kagqdnD69Et29m1vl5OIPsBoW3
OWb1aBW5e3J0x9prXI1W/fpvuP9NmrHBUN4ES17VliRpfVH3aHfPC8rKpv3GvHYO
cfOmMN+HfBZlUeKJKs6c5WmSVdnZB0R4UAWuQ30aHEBVqtrhgHqYDBokVe0/H4wm
wZEIQTINWniCOFR5UphJf5nP8ljGbmPxNTnfb/iHS/chjcjF7TGMG36e7EBoQijZ
EUQs5IBCeVefOnFLK5jLx+BC//X+FNzByDilTt+l28I/3ZN1ujhak73YFbWjjLR2
tjtp+LQgNQIDAQABoAAwDQYJKoZIhvcNAQELBQADggEBAGIQVhXfuWdINNfceNPm
CkAGv4yzpx88L34bhO1Dw4PYWnoS2f7ItuQA5zNk9EJhjkwK8gYspK7mPkvHDbFa
Um7lPSWsm3gjd3pU7dIaHxQ+0AW9lOw5ukiBlO4t3qgt+jTVZ3EhMbR0jDSyjTrY
kTgfuqQrGOQSmLb5XviEtCcN0rseWib3fKIl8DM69JiA2AALxyk7DCkS1BqLNChT
pnbgvtlUhc4yFXNCtwPGskXIvLsCn2LRy+qdsPM776kDLgD36hK0Wu14Lpsoa/p+
ZRuwKqTjdaV23o2aUMULyCRuITlghEEkRdJsaXadHXtNd5I5vDJOAAt46PIXcyEZ
aQY=
—–END CERTIFICATE REQUEST—–
```

이 특정 CSR은 서버의 공개 키와 영국 런던을 기반으로 하는 기업 ACME에 관한 자세한 정보, 도메인 이름 `example.com`를 포함한다.

마지막으로 서명된 HTTPS 인증서는 다음과 같다.

```bash
—–BEGIN CERTIFICATE—–
MIIDjjCCAnYCCQCJdR6v1+W5RzANBgkqhkiG9w0BAQUFADCBiDEUMBIGA1UEAwwL
ZXhhbXBsZS5jb20xCzAJBgNVBAsMAklUMQ8wDQYDVQQIDAZMb25kb24xEjAQBgNV
BAoMCUFDTUUgSW5jLjEgMB4GCSqGSIb3DQEJARYRYWRtaW5AZXhhbXBsZS5jb20x
CzAJBgNVBAYTAkdCMQ8wDQYDVQQHDAZMb25kb24wHhcNMTYwNDE5MTAzMjI1WhcN
MTcwNDE5MTAzMjI1WjCBiDEUMBIGA1UEAwwLZXhhbXBsZS5jb20xCzAJBgNVBAsM
AklUMQ8wDQYDVQQIDAZMb25kb24xEjAQBgNVBAoMCUFDTUUgSW5jLjEgMB4GCSqG
SIb3DQEJARYRYWRtaW5AZXhhbXBsZS5jb20xCzAJBgNVBAYTAkdCMQ8wDQYDVQQH
DAZMb25kb24wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCb7Tfo7Y+V
RBsptJKzaKTo7pNjLr5mxqzmgCTcaKgYuXVFb02LyRqCp2cPr0S3b2bW+Xk4g+wG
hbc5ZvVoFbl7cnTH2mtcjVb9+m+4/02ascFQ3gRLXtWWJGl9Ufdod88Lysqm/ca8
dg5x86Yw34d8FmVR4okqzpzlaZJV2dkHRHhQBa5DfRocQFWq2uGAepgMGiRV7T8f
jCbBkQhBMg1aeII4VHlSmEl/mc/yWMZuY/E1Od9v+IdL9yGNyMXtMYwbfp7sQGhC
KNkRRCzkgEJ5V586cUsrmMvH4EL/9f4U3MHIOKVO36Xbwj/dk3W6OFqTvdgVtaOM
tHa2O2n4tCA1AgMBAAEwDQYJKoZIhvcNAQEFBQADggEBABwwkE7wX5gmZMRYugSS
7peSx83Oac1ikLnUDMMOU8WmqxaLTTZQeuoq5W23xWQWgcTtfjP9vfV50jFzXwat
5Ch3OQUS53d06hX5EiVrmTyDgybPVlfbq5147MBEC0ePGxG6uV+Ed+oUYX4OM/bB
XiFa4z7eamG+Md2d/A1cB54R3LH6vECLuyJrF0+sCGJJAGumJGhjcOdpvUVt5gvD
FIgT9B04VJnaBatEgWbn9x50EP4j41PNFGx/A0CCLgbTs8kZCdhE4QFMxU9T+T9t
rXgaspIi7RA4xkSE7x7B8NbvSlgP79/qUe80Z7d8Oolva6dTZduByr0CejdfhLhi
mNU=
—–END CERTIFICATE—–
```

모든 부분은 연결되어 있으며 서로 일치해야 한다.  공인된 인증 기관에서 서명하지 않았기 때문에 자체 서명 인증서라고 한다.

# SSL 구축방법

OpenSSL이 설치되었는지 다음 명령을 사용해 확인한다.

```bash
# openssl version
```

아직 설치되지 않았다면 명령줄을 열고 OpenSSL을 설치한다.

```bash
# dnf -y install openssl
```

```bash
[Server2] # mkdir pki
[Server2] # cd pki/
[Server2] # pwd
/root/pki
```

그 다음 다음 명령으로 개인 키와 CSR을 생성한다.

```bash
# openssl req -newkey rsa:2048 -nodes -keyout example.com.key -out example.com.csr
req : openssl에서 인증 요청서를 만드는 메뉴얼 파일을 볼 수있다.
newkey : 새로운 방식
```

개인 키가 생성되고 CSR에 대한 몇 가지 질문을 요청받는다.

```bash
Generating a 2048 bit RSA private key
……………………+++
……………………………………………………….+++
writing new private key to ‘example.com.key’
—–
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter ‘.’, the field will be left blank.
```

모든 질문에 알맞은 답을 제공하고(서명된 인증서에 공개), HTTPS 인증서를 요청하는 도메인 이름과 정확히 일치해야 하는 ‘Common Name’ 섹션에 특별히 주의한다. 최상위 수준 도메인만([example.com](http://example.com/)) 포함한다. CA는 보통 www 하위 도메인(예: [www.example.com](http://www.example.com/)) 역시 추가한다.

```bash
Country Name (2 letter code) [AU]: KR
State or Province Name (full name) [Some-State]:Seoul
Locality Name (eg, city) []:Seoul
Organization Name (eg, company) [Internet Widgits Pty Ltd]:soldesk
Organizational Unit Name (eg, section) []:IT
Common Name (e.g. server FQDN or YOUR name) []:example.com
Email Address []:master@example.com

Please enter the following ‘extra’ attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
```

### HTTPS 인증서 얻기

웹사이트 인증서를 얻기 위해 먼저 HTTPS 인증서 공급 업체로부터 HTTPS 인증서 크레딧(DV, OV, EV, 단일 사이트, 멀티 사이트, 와일드 카드)을 구매한다. 인증서 크레딧 구매 뒤 선택한 도메인에 구매한 크레딧을 쓸 인증서 서명 요청을 해야 한다. `BEGIN CERTIFICATE REQUEST`와 `END CERTIFICATE REQUEST`를 포함해 전체 CSR 텍스트 제공(필드에 붙여 넣기 하거나 업로드)을 요청받는다. EV나 OV 인증서를 받고 싶다면 인증서 요청자의 법적 신원을 제공해야 한다. 또한 확인을 위해 회사와 관련된 추가 문서를 제출해야 한다. 인증서 등록 기관은 요청(그리고 모든 지원 문서)을 검증한 다음 서명된 HTTPS 인증서를 발행한다.

### **HTTPS 인증서 얻기**

호스팅 공급 업체나 HTTPS 등록 기관에 따라 제품과 등록 절차가 다를 수 있으나 일반적으로 비슷한 방식이다.

1. HTTPS 인증서 공급 업체를 찾는다.
2. 인증서 유형(DV, OV, EV, 단일 사이트, 멀티 사이트, 와일드 카드)을 선택하고 ‘Add to cart’를 클릭한다. 선호하는 지급 방법을 지정하고 지불을 완료한다.
3. 도메인에 새로운 HTTPS 인증서를 활성화한다. 인증서 서명 요청을 붙여 넣거나 업로드할 수 있다. 시스템은 CSR에서 인증서 세부 사항을 뽑아낸다.
4. ‘Domain Control Validation’이라는 방식을 선택하라는 요청을 받는다. 이메일이나 HTML 파일(HTTP 기반) 업로드, 도메인 영역 파일(DNS 기반)에 `TXT` 레코드를 추가를 통해 수행한다.
5. 검증이 완료되고 HTTPS 인증서가 발행될 때까지 잠깐 기다린다. 서명된 HTTPS 인증서를 다운로드한다.

### **자체 서명 인증서**

인증 기관을 통하지 않고 스스로 인증서를 서명할 수도 있다. 이 인증서는 다른 인증서만큼이나 암호화 방법으로 우수하기 때문에 테스트 목적으로는 좋으나, 브라우저에서는 신뢰하지 않으므로 보안 경고를 표시한다. 어떤 것이라도 클레임이 포함할 수 있지만 제 3의 당사자의 검증은 통과하지 못한다. 사용자가 해당 웹사이트를 신뢰한다면 인증서를 저장하고 향후 방문에서 신뢰하도록 브라우저에서 예외를 추가할 수 있다.

앞의 예제 인증서는 자체 서명된 인증서다. `example.com` 도메인용으로 사용할 수 있으며 유효기간 내에서 잘 동작한다.

OpenSSL을 사용할 수 있는 모든 플랫폼에서 자체 서명 인증서를 만들 수 있다.

```bash
# openssl x509 -signkey example.com.key -in example.com.csr -req -days 365 -out example.com.crt
```

```bash
[SERVER2]# ls -l
total 12
-rw-r--r--. 1 root root 1302 Jan 26 11:12 example.com.crt
-rw-r--r--. 1 root root 1045 Jan 26 11:08 example.com.csr
-rw-------. 1 root root 1704 Jan 26 11:08 example.com.key
[SERVER2]# file *
example.com.crt: PEM certificate
example.com.csr: PEM certificate request
example.com.key: ASCII text
```

자체 서명 인증서를 사용할 수 있다면 서버에 이 인증서를 설치해야 한다. 같은 공급 업체의 호스팅과 HTTPS 등록 서비스를 사용하고 있다면(많은 호스팅 공급 업체가 HTTPS 인증서를 판매한다), 웹사이트용으로 새로 구매한 HTTPS 인증서를 설치하고 활성화하는 자동화된 절차가 있을 것이다. 다른 곳에서 호스팅 중 이라면 인증서를 다운로드하고 인증서를 사용할 수 있도록 서버를 구성해야 한다.

## 웹사이트에 HTTPS 인증서 설치하기

생성한 개인 키(example.com.key)와 인증서 서명 요청(example.com.csr), 유효한 HTTPS 인증서(example.com.crt)를 적절한 위치에 넣는다.

```bash
# cp example.com.crt /etc/pki/tls/certs/
# cp example.com.key /etc/pki/tls/private/
# cp example.com.csr /etc/pki/tls/private/
# restorecon -RvF /etc/pki/
```

파일은 루트가 소유해야 하며 600이라는 퍼미션 설정으로 보호해야 한다.

```bash
# chown -R root /etc/pki/tls/certs /etc/pki/tls/private
# chmod -R 0600 /etc/pki/tls/certs /etc/pki/tls/private
```

### 아파치

웹사이트의 HTTPS 버전을 활성화하는 절차는 다음과 같다.

- mod_ssl이 서버에 설치되었는지 확인한다.
- 획득한 HTTPS 인증서(`.crt`) 파일을 서버로 업로드한다.
- 아파치 서버 구성 파일을 편집한다.

`mod_ssl`을 확인하는 것으로 시작한다. 운영체제에 따라 다음 구문 중 하나가 동작해야 한다.

```bash
# httpd -M | grep ssl
```

mod_ssl이 설치됐으면 다음과 같은 결과가 표시된다.

```bash
ssl_module (shared)
Syntax OK
```

약간 다른 유사한 결과가 나올 수도 있다.

mod_ssl 이 없거나 활성화되지 않는 경우 운영체제에 따라 다음 작업을 시도해본다.

```bash
# dnf -y install mod_ssl
# systemctl restart httpd
```

SSL 사용

```bash
# vi /etc/httpd/conf.d/vitual1.conf
<Directory /srv/site1/www>
Require all granted
AllowOverride None
</Directory>

<VirtualHost 192.168.10.210:80>
DocumentRoot /srv/site1/www
ServerName site1.example.com
ServerAdmin webmaster@site1.example.com
ErrorLog "logs/site1_error_log"
CustomLog "logs/site1_access_log" combined
</VirtualHost>

<VirtualHost 192.168.10.210:443>
ServerName site1.example.com
**SSLEngine on
SSLCertificateFile /etc/pki/tls/certs/example.com.crt 
SSLCertificateKeyFile /etc/pki/tls/private/example.com.key
SSLCertificateChainFile /etc/pki/tls/private/example.com.csr**
DocumentRoot /srv/site1/www
ServerAdmin webmaster@site1.example.com
ErrorLog "logs/site1_error_log"
CustomLog "logs/site1_access_log" combined
</VirtualHost>
```

**[SERVER2]# firewall-cmd --permanent --add-service=https**

**[SERVER2]# firewall-cmd --reload**

**[SERVER2]# systemctl restart httpd**

```bash
[SERVER2]# ss -ant | grep :443
LISTEN    0         128                       *:443                   *:*
```

```bash
[SERVER2]# curl https://site1.example.com
curl: (6) Could not resolve host: site1.example.com
[SERVER2]# curl -k https://site1.example.com
site1 web

※ 만약 안 될 시 /etc/resolv.conf 파일에 nameserver가 200으로 되어있는지 확인

[SERVER1]# curl https://site1.example.com
curl: (60) SSL certificate problem: self signed certificate
More details here: https://curl.haxx.se/docs/sslcerts.html

curl failed to verify the legitimacy of the server and therefore could not
establish a secure connection to it. To learn more about this situation and
how to fix it, please visit the web page mentioned above.
[SERVER1]# curl -k https://site1.example.com
site1 web
```

아파치 구성 파일을 편집한다(httpd.conf).

```bash
Listen          80

Listen          443

 

<VirtualHost *:80>

ServerName example.com

ServerAlias www.example.com

Redirect 301 / https://www.example.com/

</VirtualHost>

 

<VirtualHost *:443>

ServerName example.com

Redirect 301 / https://www.example.com/

</VirtualHost>

 

<VirtualHost *:443>

ServerName www.example.com

…

SSLEngine on

SSLCertificateFile/path/to/signed_certificate_followed_by_intermediate_certs

SSLCertificateKeyFile /path/to/private/key

 

    # 클라이언트 인증서 인증을 사용할 때 다음 지시문의 주석을 해제한다.

    #SSLCACertificateFile  /path/to/ca_certs_for_client_authentication

 

# HSTS (mod_headers is required) (15768000 seconds = 6 months)

Header always set Strict-Transport-Security “max-age=15768000”

…

</VirtualHost>

 

# 중간 구성, 필요에 따라 조정

SSLProtocol         all -SSLv3

SSLCipherSuite      ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS

SSLHonorCipherOrder on

SSLCompression          off

SSLSessionTickets       off

 

# OCSP Stapling, httpd 2.3.3 이상

SSLUseStapling                  on

SSLStaplingResponderTimeout     5

SSLStaplingReturnResponderErrors    off

SSLStaplingCache                shmcb:/var/run/ocsp(128000)
```

이 구성은 앞서 언급한 것처럼 [Mozilla SSL Configuration Generator](https://mozilla.github.io/server-side-tls/ssl-config-generator/)를 사용해 생성했다(최신 구성을 확인하자). 인증서와 개인 키 경로 편집한 부분을 확인하자. 제공된 구성은 중간 설정을 사용해 생성했으며, 각 설정에 대한 제약 사항과 브라우저 구성을 보고 가장 알맞은 스위트를 결정하자.

HTTP에서 HTTPS로 리디렉션뿐만 아니라 비`www`에서 `www` 도메인으로(SEO에 유용) 리디렉션을 다루기 위해 생성된 코드에 몇 가지를 수정했다.

### NGINX

nginx 구성 파일을 편집한다(nginx.conf).

/etc/nginx/nginx.conf

```bash
server {

listen 80 default_server;

listen [::]:80 default_server;

 

# 301 Moved Permanently 응답과 함께 모든 HTTP 요청을 HTTPS로 리디렉션한다.

return 301 https://$host$request_uri;

}

 

server {

listen 443 ssl http2;

listen [::]:443 ssl http2;

 

# SERVER HELLO에서 클라이언트에 보낸 인증서는 ssl_certificate에서 연결된다.

ssl_certificate /path/to/signed_cert_plus_intermediates;

ssl_certificate_key /path/to/private_key;

ssl_session_timeout 1d;

ssl_session_cache shared:SSL:50m;

ssl_session_tickets off;

 

# DHE ciphersuites용 Diffie-Hellman 매개변수는 2048 비트 권장

ssl_dhparam /path/to/dhparam.pem;

 

# 중간 구성. 필요에 따라 조정

ssl_protocols TLSv1 TLSv1.1 TLSv1.2;

ssl_ciphers ‘ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS’;

ssl_prefer_server_ciphers on;

 

    # HSTS (ngx_http_headers_module 필수) (15768000초 = 6개월)

add_header Strict-Transport-Security max-age=15768000;

 

# OCSP Stapling —

# ssl_certificate의 URL에서 OCSP 레코드를 불러와 캐시에 저장한다.

ssl_stapling on;

ssl_stapling_verify on;

 

## 루트 CA 와 중간 인증 기관을 사용해 OCSP 응답의 신뢰 사슬을 검증한다.

ssl_trusted_certificate /path/to/root_CA_cert_plus_intermediates;

resolver <IP DNS resolver>;

 

….
```

### 혼합 콘텐츠 경고

주소 줄 옆에 경고 표시와 ‘안전하지 않음! 이 페이지의 일부 콘텐츠는 암호화되지 않았습니다(마이크로소프트 에지 브라우저)’를 볼 수 있다. 이 부분이 설치가 잘못됐다는 것은 아니다. 로컬이나 원격 서버에서 리소스(이미지, 스타일시트, 스크립트 등)에 대한 모든 링크는 `http://`로 시작하지 않는다. 모든 리소스는 루트(`/images/image.png`, `/styles/style.css` 등)에 대한 상대 경로나 현재 문서(`../images/image.png`)에 대한 상대 경로를 가리키거나, `<script src=“https://code.jquery.com/jquery-3.1.0.min.js"></script>`처럼 `https://`로 시작하는 완전한 URL이어야 한다.

이러한 팁은 혼합 콘텐츠mixed-content 경고를 제거하고 닫힌 자물쇠를 느낌표 없이 표시한다.

### 서버 테스트

서버를 구성하고 웹사이트를 HTTPS에서 실행한 후 Qualys SSL Server Test를 사용해 보안 구성을 확인하는 것이 좋다. 이 테스트를 수행하면 웹사이트를 스캔하고 구성에 대한 포괄적인 평가와 취약점, 권장 설정을 알려준다. 다음의 조언이 서버 보안 구성을 더 개선시킬 것이다.

### 갱신

인증서는 지정한 기간 동안 유효하다(보통 1년 정도다). 갱신의 마지막 순간까지 기다리지 않도록 하자. 등록 기관에서는 갱신 날짜가 다가오면 메일을 보내기 시작한다. 첫 번째 알림을 받자마자 새로운 인증서를 발행하자. 절차는 거의 동일하다. 새로운 인증서 서명 요청을 만들고 새로운 HTTPS 인증서를 얻어서 서버에 설치한다. 인증서의 유효성은 서명 시점에 시작되고 만료일은 현재 인증서가 만료된 후 1년으로 설정된다. 따라서 이전 인증서와 새 인증서 모두가 유효한 시기가 있고, 이전 인증서가 만료된 후 완전한 새해가 시작된다. 겹치는 기간 동안 이전 인증서 만료 전에도 새로운 인증서는 정상 동작하기 때문에 웹사이트 서비스는 중단되지 않는다.

### 폐기

서버가 손상됐거나 누군가가 개인 키에 액세스할 수 있다고 생각되면 즉시 현재 HTTPS 인증서를 폐기해야 한다. 다른 등록 기관의 절차는 다를 수 있지만 일반적으로 등록 기관의 특수한 데이터베이스에서 손상된 인증서를 비활성으로 표시한 다음 새로운 HTTPS 인증서를 발행한다. 물론, 어느 누구도 여러분을 가장할 수 없도록 현재 인증서는 가능한 빨리 폐기하고 보안 위반의 원인을 조사하고 해결한 다음 새로운 인증서를 받도록 한다. 필요하면 등록 기관에 도움을 요청하자.

# 문서 작성

각각의 문제에 해당하도록 제안서 문서를 구성

컨설팅에 대한 제안

문제에 맞도록 해결 방안 제시 목적

- 문제

    소규모 기업에서 리눅스 서버를 사용하 dhcp를 구성한다고 가정하자
    현재 내부에는 dns nfs 가 구성 되어있고
    사무용 pc가 10대 가량 있다
    현 상황에서 가장 적절한 구성을 제안해보자

    unbound라는 캐시 전용 dns를 추가한다고 가정하자
    이를 구축하였을때의 장점과 변경되는 인프라 구성도는 어떻게 되는가?

    웹 서버를 구성하는 경우  기업 내부에 구축하여 구현하는 경우와 기업 외부에서 호스팅 하는 두가지 경우를 두고 각각에 필요한 시스템 및 필요 하드웨어 ,외부 서비스 이용시 파악해야 하는 요소들을 나열하고 두 경우를 비교해보자

    stratis를 활용할 방안을 제시해본다
    조건 : 현재 사용자는 리눅스를 잘 모른다
    현재 사용자에게 stratis가 가지는 장점을 제시해야 하고 기존 표준 파일시스템이 아닌stratis을 구성하여 사용자가 쓰도록 제안한다

    iscsi를 구성하여 블록 스토리지를 지원해야 한다
    이 경우 네트워크에서 병목현상을 제거하고 트래픽의 부하를 줄이기 위해 제안할 수 있는 것은 무엇인가
    조건 : iscsi를 구성할때 네트워크를 기존 네트워크가 아닌 iscsi data 전용으로 구성 해야 한다 이것을 사용자에게 이해시켜야 한다

어떻게 구성을 짤 것인가 고민해보고 상대방에게 구성을 위한 제안을 하는 것을 목적으로 문서 작성

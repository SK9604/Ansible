# NETWORK 개념적 이해

## 컴퓨터

컴퓨터는 [  정부   ] 이다.

컴퓨터 : 하드웨어와 소프트웨어로 이루어진 '어떠한 장치'

system software(OS)/application software(응용프로그램)로 이루어져 있는 특정한 기능을 실시할 수 있는 장치

OS ← H/W 자원 접근 / App ← H/W 자원 직접 X

IT에서의 아키텍쳐 : 설계도 정도로 이해

## Layer

Layer : 붙어있는 그림(stack모양)

Module : 붙어있지 않은 그림(필수 요소가 있어서 종속성을 가지는 경우도 존재, 연결점이 존재한다)

존립이 의존적인 개념도 : 하위층이 없는 경우 상위층은 존재할 수 없다.( rpm 종속성에 대한 해결 → dnf, yum)

상호 독립적이다 : 같은 회사라도 각 부서별로 나누어진 일이 있는 것 처럼 독립해서 운영되는 부분이 있다.

## 정부

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/35588bea-b04e-453f-96be-61177270c000/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/35588bea-b04e-453f-96be-61177270c000/Untitled.png)

물리적인 부분 : 영토 + 영공

논리적인 부분 : 정부 위로

Process : 가상의 영역을 가지고 있다 (고유한 메모리 영역)

침범 받을 수 없고 침범 당해서는 안되는 고유의 영역이다.

메모리 → 물리적인 addr / 가상의 addr 가 존재한다.

하드웨어 - 물리적

소프트웨어 - 논리적

IT에서 logical과 동일하게 사용되는 단어 : virtual

논리화 , 가상화, 추상화는 결국 동일하게 생각하면 된다!

가상/논리적 계층의 경우에는 컴퓨터가 진짜인것 처럼 믿는 것

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3a0a68fe-b714-4378-9263-6c7caef3017d/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3a0a68fe-b714-4378-9263-6c7caef3017d/Untitled.png)

운영체제 + 하드웨어 → platform

검경 : 디버거

하드웨어에서 제일 중요한 것 : cpu

kernel (os)(driver)

h/w(device)

하드웨어를 제어하기 위해서 커널에서는 device driver를 사용하여 장치와 통신하고 제어한다.

각각의 방 = memory

개인 = thread는 개인적인 공간을 가지고 있다.

개인이 여러개 있는 경우 → multi thread. 이러한 경우 중요한 토픽은 동기화(synchronization)이다.

동기화

프로세스를 진행하기 위해 사용되는 CPU, MEM등의 시스템에서 장치를 사용하기 위해 또는 해당 어플리케이션을 사용함에 있어 순서, 데이터에 대한 일치를 위해 사용하는 기술

만약 동기화가 되지 않거나 데이터가 일치되지 않은 상태에서 시스템에 장애가 생긴다면?

이후 log로 분석하는 경우 정확한 복구가 어려울 수 있다.

메모리의 경우 dump file자체로 복구가 힘들거나 분석이 어려운 경우도 있다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3ee8df6d-8a02-4d74-8aef-0435d2923593/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3ee8df6d-8a02-4d74-8aef-0435d2923593/Untitled.png)

device : dev/pts/0

process : bash (주체)

사이를 연결하는 것 : FILE (대상체)

주체가 대상체를 상대로 하는 대표적인 것

create/open

read/write

delete/close

프로세스가 파일을 [ ]다 = I/O

I/O를 하는 경우 형식

구성요소가 필요로 하는 형식이 있다.

형식은 format이라고 한다.

⭐이러한 형식을 [protocol]이라고 한다.

## FILE

유저모드 어플리케이션이 커널에 진입할 수 있도록 해주는 추상화된 인터페이스. 특정 데이터에 접근하기 위한 것. 실제로 file은 dummy이다.

어떠한 내용들을 담기 위한 공간으로 사용되는 것? → 공간에 DATA가 담겨 있는 것? → [ DISK ]에 기록되어진 정보의 집합(메타파일)이다!

객체 (object)

식별자(속성, 특성) → 무언가 분류하기 위함

메타파일

정보 + 데이터 접근을 위한 pointer : 실제 데이터는 pointer를 타고 간 어떤 저장공간에 있다.

## Filter

필터 공간이 하는 일 : 실시간 감시 역할

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ef201fa1-7a15-42ae-abcb-4464c978bfe7/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ef201fa1-7a15-42ae-abcb-4464c978bfe7/Untitled.png)

구성요소

← 이 구역에 공간이 존재하는 이유? (구성에 따라 다르지만 필터는 구성요소 위로 존재하는 경우도 있다) → FILTER

driver

## 실제 통신을 위한 개념도

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e10a271a-20de-49e8-b528-4227aee8b031/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e10a271a-20de-49e8-b528-4227aee8b031/Untitled.png)

로컬 : 파일 (나에게 모든 정보가 다 있기 때문)

네트워크 : 소켓 (상대방으로 연결할 수 있는 정보만 가져간다)

## SOCKET(소켓)

네트워크 통신을 위한 인터페이스이며 하나의 종착점이다.

## End-Point

네트워크 - 네트워크를 이용하는 주체와 네트워크를 위한 대상체가 존재

컴퓨터 - End-Point

그렇다면 라우터, 스위치 등의 장치는? 무엇인가? → 추상적인 인터페이스로서 socket을 이용 할 때 중간 지점. 라인

## 네트워크

사람과의 Network → 인맥, 연결관계

 Networking → 상호작용, 대화(정보습득)  (관계 형성에 대한 도구)

Computer간의 네트워크

## OSI 7 Layer

성공적인 상호작용을 위한 7가지 전제조건

- 컴퓨터 간의 대화에서 없어야 하는 것

컨셉

layer 형식의 그림 , 각 층의 역할

h/w kernel user영역과 프로세스의 위치

- **기본 구성 (전부 프로토콜이다)**

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1ef32f71-ce23-4bb8-aacb-cbb481ca4b26/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1ef32f71-ce23-4bb8-aacb-cbb481ca4b26/Untitled.png)

L1, L2 ← LAN (physical)

H/W > LAN으로 이해 (Local Area Network)

private network : 폐쇄망을 구성할 수 있는 네트워크

기본적으로 물리적으로 구성할 수 있는 곳이 lan이다. → 요즘은 확장되서 vxlan이 있다.(원격지에 떨어져 있지만 하나의 lan처럼 사용가능하다(보안성 뛰어남))

하나의 LAN을 구성하는 대표적 장치 : LAN

LAN : 폐쇄망을 구성하는 네트워크(HOME, Small Office)이며 LAN을 벗어난 네트워크를 실시 하기 위해서는 라우터라는 장비가 필요하다

로컬 네트워크를 벗어난 네트워크에서 통신을 하기 위해서 필요한 소프트웨어가 라우터에 존재한다.

L2 ← MAC 주소를 가지고 있다. NIC 카드의 식별자

MAC 주소 구조

16진수로 되어있으며 한 자리가 1byte(8bit)

16진수로 표기하기 위해서 0000 0000 으로 잘라서 표현한다.

4bit + 4bit로 두개의 16진수 자리를 표현한다. 1byte씩 6자리 → 48bit 체제

L3 ← WAN (L3부터 Virtual 영역)

IP, ARP, ICMP 도 다 프로토콜

IP주소를 가지고 있다 (IPv4)

L2의 MAC 주소와 L3의 IPv4 주소는 한 쌍을 이룬다.

HOST에는 IPv4주소가 있다.

LAN카드 뒤에는 RJ45라는 포트가 있다.

PC에는 LAN포트가 1개

host가 컴퓨터에 대한 식별자일 때 생각해 봐야 할 것?

NIC카드에는 포트가 여러 개 있다. → 각 포트의 ip주소가 다 다른 경우에 컴퓨터의 ip주소는 무엇일까? 

IP가 여러개 있다면 다수의 HOST이다.

철저히 사용자 입장에서 server 구축 상황을 모르는 상황에서 생각해야 한다.

L4 ← Port 번호를 가지고 있다

TCP/UDP 가 하는 것 : 한대의 서버에서 telnet, ssh, dns, web을 모두 운영중이다. client가 dns 서비스를 이용하기 위해서 서버에 접속한다면 서버는 어떻게 알 수 있을까?

여기서 사용되는게  port 번호 (/etc/services 파일) 65536개 (0-65535)

나 혼자 web, DNS 서비스를 이용하는 것이 아닌데 서버는 어떻게 분류하여 정확히 client에게 돌려보내줄까?

Port 번호

Socket 내부

File + @ (ip, port(tcp,udp) + ~) : 같이 바인딩이 되어있다

bind() : server → bind, client → connect

client 입장 → 요청하고 연결을 시도

server입장 → socket을 열어놓고 기다림. 연결이 들어오면 bind를 통해서 묶어준다.

Process : HTTP (80번 포트) 서비스 대기. socket을 거쳐서 온다. local, network file system(nfs)를 통해서 각종 컨텐츠 제공

소켓이 bind 정보로서 12345 port 번호를 사용하여 열고 있으며 해당 주소를 사용하여 특정 서비스(http)를 사용하고 있다. 소켓을 프로세스가 열고 있기 때문에 해당 소켓을 추적한다면 어느 프로그램에서 사용하는지 어느 서비스인지 확인 가능하다.

외부에서 사용자가 접근하면 port번호를 하나씩 소비해야한다.

Port 번호가 식별자로 사용될 때

레이어에 따라 서비스 번호일 수 있으며 물리적 장치의 링크번호 일수도 있다.

port 번호 구역

0-65535

2^16

한 HOST(IPv4에 대한 식별자, 물리적인 포트 하나)에서 열수 있는 최대 소켓 개수는 몇 개일까? 

한 HOST에서 service가 가능한 최대 tcp 세션 개수는? → 65536개까지

모든 소켓이 열리면 어떻게 되는가? → 더이상 서비스를 받을 수 없는 상태

DDOS(DIstributed DoS) 공격

Service에 대한 식별자 : 몇명의 client를 받아들일 수 있느냐. LAN포트 4개라면? → 2^16 * 4개

## Switch

목적지에 가기 위하여 선택해야 하는 것

```bash
MAC - L2 switch
IP - L3 switch
PORT - L4 switch
HTTP - L7 switch
```

아래로 갈 수록 가격 ↑, 정보 ↑

만약 기존에 존재하는 경로가 장애가 일어난 경우 어떻게 다른 경로를 찾아가는 것인가? → 인접한 장비끼리 통신

인접한 장비끼리 통신하여 만드는 것 - switching, routing

네트워크를 한다는 것은 장비들에서 일어나는 switching 반복이다!

RIP가 COST를 결정하는 방법 : HOP(홉) : data가 장비를 거쳐 갈 수 있는 횟수, 몇 개를 거쳐 가느냐
네트워크의 단점 : 제일 빠른 길 하나만 사용한다. > HOP count 를 사용하면 빠른길이 아니라 거치는 라우터 수가 적은 길만 사용한다. 프로토콜마다 다르다

나머지 경로는 제일 빠른 길이 장애가 날 때까지 잊어버린다.

1G를 사용하다가 10G가 있다면 1G를 더이상 사용하지 않고 10G만 사용한다. 문제는 나만 10G를 사용하는 것이 아니라 여기를 통과하는 모든 장비는 10G를 사용한다. band width를 모두 사용해버리면 병목현상이 발생한다.

1G라인이 널널하게 아무런 트래픽이 발생하지 않지만 사용할 수 없다.

→ 이것을 사용하기 위하여 소프트웨어를 사용하여 새로운 네트워크 라인을 생성하였다. 이것은 [SDN]이다.

## 블랙박스

Cisco 장비는 블랙박스이다.

HOST 개념을 가지고 있다. → ip가 할당되어 있다. 원격 작업이 가능한 interface가 있다.(port가 존재(물리적인 것뿐만 아님))

특정 기능을 하고 있다.

업데이트가 힘들다. → 오늘날은 살짝 틀린말이다

이러한 장비를 어플라이언스라고 한다.

## SDN

SDN장비를 사용하지 않는 이유

인프라는 한번 구축하고 나면 변경하기 힘들다.

SDN이 가능한 장비로 모두 변경해야 한다. (나만 사용하는게 아니라 상대도 사용해야 한다. 동시에 변경해야 하기 때문에 사실상 불가능하다.)

그렇기 때문에 새로 구성되는 장비와 가상네트워크, 클라우드에서 주로 쓰는 기술이다.

## OSI만 있는 것이 아니다.

## TCP/IP -DoD

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6bb930d6-a1aa-48ca-8aa8-74ccf699aba8/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6bb930d6-a1aa-48ca-8aa8-74ccf699aba8/Untitled.png)

## 네트워크와 택배

A의 집, B의 집 : HOST

선물 : payload, data

포장 : segment (encapsulation) → 패킷(packet)

송장 : header

이름 : port

주소 : ip

현관 : gateway

택배 차량 : isp

택배가 이동하는 과정 : session

받는 입장 : 위 과정을 반대로 하고 process까지 올라감

왜 나의 패킷은 오다가 사라지나? → L2 L3 L4 payload 형태로 현관을 통과한다

송장 : firewall, packet filtering → L3 (상대방 호스트 주소 존재)

언박싱 : IPS → L2~payload (port번호, tcp 헤더 정보 확인)

내부 물건 : DPI → payload

뽁뽁이까지 제거된 순 물건 : SPI

## 패킷

MTU(Maximum Trasmission Unit) 최대 전송 단위 - 1500byte

host + payload + segment

크기

1500byte

```bash
+--------------------+
| ip | tcp | payload |    (L3, L4, Data)
+--------------------+
   20        1460     byte
```

## 용어 정리

payload : data

segment : 포장된 data

packet : 전송을 위해 특정한 퐷을 가진 data

header : 실제 전송을 위한 metadata

MTU : 최대 전송 사이즈 (network에서) 

## 패킷의 이동

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dbe97715-57ae-4266-9b38-06720f2941d0/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dbe97715-57ae-4266-9b38-06720f2941d0/Untitled.png)

```bash
pc   pc
|    ↑   방향으로 이동한다.
|    | 
+----+
```

왼쪽PC에서 통신을 요청함 (L2 : switch 장치 , R : 라우터(L3 switching))

switch 장치 → 라우터 → ISP를 거쳐 server로 연결

server : daemon

client : web (wget 등 웹 접속 프로그램)

Program 이 메모리 상에 올라가면 process가 되고 메모리의 일정 공간을 점유한다.

버퍼란 공간. 크기는 ? → 알 수 없다. (프로그램을 만든 개발자만 알 수 있다)

Socket : 파일의 I/O를 위한 버퍼가 존재한다. network에서 사용하는 메모리

client쪽 프로세스와 하위의 network system을 이어주는 역할을 하며 read/write/send/recieve등 의 작업을 한다

NIC : R옆의 벽 - GateWay

Driver 와 NIC 사이 : Device Driver

MAC이 Driver에 올라와있는 이유 : 

1. L2에서 프레임을 만든다.
2. Mac 주소는 물리적인 주소이지만 동시에 논리적으로 설정되어 있는 주소이다. → 통신을 시도할 때 프라임으로 내보내기 전에 패킷들에 대해 작업을 할 때 신호체계로 전송을 할 때 신호는 MAC주소를 삽입한다. (수정이 가능한 주소이다.)
3. NIC카드랑 통신을 하면서 맥주소에 대한 기입이 들어간다

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fa84f864-d364-4496-b645-5f32f7d1d499/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fa84f864-d364-4496-b645-5f32f7d1d499/Untitled.png)

socket이 아닌 file인 이유 : network를 사용한다고 해서 모든 작업이 socket으로 사용하는 것이 아니다. server pc의 local로서 file로 사용한다. 프로그램으로 올라올 때 까지 파일로 작업한다.

블럭이 I/O하는 기본 사이즈 : 4K

퍼즐 : 분할되어 있는 파일. 단일파일이지만 512byte씩 disk에 찍혀있다. 각 퍼즐 한 조각을 4K로 볼 때 프로세스로 올리는 효율적인 방법이 무엇일까?

→ file을 잘게 쪼갠다. 4K씩 Read

Server : buffer가 존재. 쪼개진 조각의 일부분을 가지고 올라온다. (read from file) . move, send 작업

순차적으로 가져올 수 있는 이유 : inode 에는 block pointer가 존재하여 순서대로 올라온다.

Socket : buffer가 존재. 출력하는 작업이 필요하다. move - send() - write 중 write 작업. copy가 아니라 그대로 이전

TCP : 각 파일 조각에 tag 작업을 실시한다. 순서 식별을 위함

Socket : 잘라내기 (분해작업). tag 작업을 실시하는 파일 조각을 잘라주는 소켓에서 잘라준다. segment

ip : 잘라진 tag붙인 각 segment를 포장하여 packet이라는 단위로 tcp 통과하고 ip까지 통과하여 만들어준다.

네트워크를 통해 이동 - frame : 전기 신호

컴퓨터 : 입력 → 연산 → 출력

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e377364e-5d6c-4d08-a1b9-bec5554537e4/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e377364e-5d6c-4d08-a1b9-bec5554537e4/Untitled.png)

패킷에서 IP를 확인하고 도착지가 자신의 호스트인지 확인이후 패킷 open

패킷 내부에는 이전 그림 4번의 segment화 된 파일이 하나씩 들어있다.

socket : file I/O 버퍼. 파일을 하나씩 전송받아 분해된 파일을 조립하는 단계로 들어간다.

tcp : acknoledgement (TCP의 주요 기능중 하나) segment화 된 파일중 어디까지 잘 받았는지 확인시켜주는 기능. 받은 segment 번호 이후의 번호를 추가하여 전송한다.

client : 버퍼. 프로그램에서 file buffer에 있는 파일을 move시킨다.

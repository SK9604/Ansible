- **배운 내용**

    파일 내용 확인 명령어

    cat 명령어

    more 명령어

    head 명령어

    tail 명령어

    정리

    기타 관리용 명령어

    wc 명령어

    기타 관리용 명령어

    su 명령어

    id 명령어

    groups 명령어

    기타 관리용 명령어

    last 명령어

    lastlog 명령어

    lastb 명령어

    기타 관리용 명령어

    who 명령어

    w 명령어

    exit 명령어

    총 정리

---

# 내용 정리

## 파일 내용 확인 명령어

---

- cat 명령어

    ```bash
    # cat /etc/passwd
    # cat -n /etc/passwd
    # cat file1 file2 > file3
    ```

- more 명령어

    ```bash
    # cat /etc/services
    # more /etc/services
    # CMD | more
    # ps -ef | more
    # rpm -qa | more
    # cat /etc/services | more
    ```

- head 명령어

    ```bash
    # head /etc/passwd
    # head -5 /etc/passwd
    ```

- tail 명령어

    ```bash
    # tail /etc/passwd
    # tail -5 /etc/passwd
    # tail -f var/log/messages
    ```

### cat 명령어

---

cat 명령어는 텍스트 파일을 읽고, 결합하고 표준 출력으로 내보내는 명령어이다.

cat의 경우 `파일이 화면이상으로 길게 작성된 경우 순식간에 지나가버린다.`파일의 내용을 화면으로 출력. 파일의 내용을 화면에 연속적으로 출력하기 때문에 파이프(Pipe Line)을 사용하여 more 명령어에 연결하여 사용 가능.

**[명령어 형식]**

```bash
# cat file1                  /* file1 파일 내용을 출력 */
# cat file1 file2            /* file1, file2 파일 내용을 출력 */
# cat -n file1               /* file1 파일내용을 줄번호와 함께 출력 */
# cat file1 file2 > file3    /* file1, file2 출력 결과를 file3에 저장 */
```

cat -n /etc/passwd , nl /etc/passwd 명령어는 동일한 출력을 해줍니다.

**[명령어 옵션]**

**옵션 : 설명**

-e : 제어 문자를 ^ 형태로 출력하며 끝에 $를 추가
**-n :** 줄번호를 공백을 포함하여 화면 왼쪽에 나타냄
-s : 중복되고 겹치는 빈 행은 하나의 빈 행으로 처리
-v : 행바꿈 문자, tab를 제외한 제어문자를 ^ 형태로 출력
-E : 각 행 끝에 $ 문자 출력
-T : tab 문자를 출력
-A : -vET 옵션과 동일

```bash
# cat /etc/passwd 
-> 출력내용 생략
```

```bash
# cat -n /etc/passwd | more (# nl /etc/passwd | more)        /* 내용 앞에 번호가 붙어 출력 */
     1  root:x:0:0:root:/root:/bin/bash
     2  bin:x:1:1:bin:/bin:/sbin/nologin
     3  daemon:x:2:2:daemon:/sbin:/sbin/nologin
     4  adm:x:3:4:adm:/var/adm:/sbin/nologin
     5  lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
     6  sync:x:5:0:sync:/sbin:/bin/sync
     7  shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
     8  halt:x:7:0:halt:/sbin:/sbin/halt

# cat /etc/passwd | grep fedora
fedora:x:1001:1001::/home/fedora:/bin/bash
# cat -n /etc/passwd | grep fedora
48	fedora:x:1001:1001::/home/fedora:/bin/bash
		  라인번호와 UID, GID는 차이가 있을 수 있습니다.
```

파일 합치기

```bash
# cd /test
# rm -rf /test/*
# echo 1111 > file1 
# echo 2222 > file2 
# cat file1 file2
1111
2222
# cat file1 file2 > file3 
# cat file3
1111
2222
```

```bash
파일 생성
# cat > file5
linux
file
create           /* ctrl+D로 빠져나옴 */
# cat file5
linux
file
create
```

cat 명령어를 사용하여 바이너리 파일 확인 시

```bash
바이너리 파일을 cat 명령어로 보는 경우 비프(bepp)음이 계속 나오게 되며 이러한 경우 터미널 창을 종료 해야 함.

ex) # cat /bin/ls                               /* 바이너리 파일은 cat으로 열지 않는다 */
    # strings -f /bin/ls

미니멀 버전 : # dnf -y install binutils
```

```bash
# man strings
NAME
       strings - print the strings of printable characters in files.

SYNOPSIS
       strings [-afov] [-min-len]
               [-n min-len] [--bytes=min-len]
               [-t radix] [--radix=radix]
               [-e encoding] [--encoding=encoding]
               [-] [--all] [--print-file-name]
               [-T bfdname] [--target=bfdname]
               [--help] [--version] file...

DESCRIPTION
       For  each  file  given,  GNU  strings  prints  the  printable character
       sequences that are at least 4 characters long (or the number given with
       the  options  below)  and are followed by an unprintable character.  By
       default, it only prints the strings from  the  initialized  and  loaded
       sections  of  object  files;  for  other  types of files, it prints the
       strings from the whole file.

       strings is mainly useful  for  determining  the  contents  of  non-text
       files.

OPTIONS
       -f
       --print-file-name
           Print the name of the file before each string.
```

확실하지 않은 파일의 경우는 파일의 형식을 확인해본다

```bash
# cd /
# ls –F
bin@  boot/  data1/  data2/  data3/  data4/  dev/  etc/  home/  lib@  lib64@  media/  mnt/  opt/  proc/  restore/  root/  run/  sbin@  srv/  sys/  test/  tmp/  usr/  var/

# file *
bin:     symbolic link to `usr/bin'
boot:    directory
data1:   directory
data2:   directory
data3:   directory
data4:   directory
dev:     directory
etc:     directory
home:    directory
lib:     symbolic link to `usr/lib'
lib64:   symbolic link to `usr/lib64'
media:   directory
mnt:     directory
opt:     directory
proc:    directory
restore: directory
root:    directory
run:     directory
sbin:    symbolic link to `usr/sbin'
srv:     directory
sys:     directory
test:    directory
tmp:     sticky directory
usr:     directory
var:     directory
```

### more 명령어

---

큰 파일을 출력할 때 화면 크기 페이지 단위로 출력하며 하단에 "--More--(20%)"는 현재 내용을 20% 보았고 80% 남았다고 표현하며 화면에서 엔터(Enter)키를 누르면 한 개의 라인(line) 단위로 넘어가고 스페이스(space) 키를 누르면 한 페이지 단위로 넘어가는데 less 명령과 함께 사용 하면 더 효율적이다.

**[명령어 형식]**

```bash
# more file1      /* file1 파일을 출력 */
# more -c file1   /* file1 파일을 한행씩 지우면서 출력 (more와 같은 형태로 출력~) */
```

**[명령어 옵션]**

**옵션 : 설명**

-n(숫자) : 출력 행수를 지정
-c : 위에서부터 한 행씩 지운 후 한 행씩 출력
-d : 스페이스나 q를 누르라는 프롬프트를 출력
-f : 보통은 긴 칼럼의 행은 화면에서 행 바꿈을 하여 새로운 행으로 계산되는데 
      -f 옵션은 새로운 행으로 계산 하지 않으며 화면이 행이 아닌 논리적인 행 수를 계산
-s : 여러 개의 빈 공백행은 하나로 취급
-p : 스크롤하지 않으며 화면을 지우고 출력
-u : 밑줄 치기를 금지

cat & more CMD 차이점

```bash
# cat /etc/services 
# more /etc/services
```

cat명령어의 경우에는 모든 출력결과가 한번에 표시되어 지나가기 때문에 확인이 어렵고 more 명령어어 경우에는 한 페이지씩 걸려 확인 가능하기 때문에 모든 내용을 정상적으로 확인할수 있다.

"CMD | more" 형식 실습

```bash
# CMD        (EX: # help)               /* 쉘 내부(내장) 명령어의 목록 확인 */
# CMD | more (EX: # help | more)

# ps -ef | more 
# cat /etc/services | more 
# rpm -qa | more 
```

```bash
# cat /etc/services | more / * 상단부터 출력한다 */
---------------------------------------------------
# /etc/services:
# $Id: services,v 1.42 2006/02/23 13:09:23 pknirsch Exp $
#
# Network services, Internet style
#
# Note that it is presently the policy of IANA to assign a single well-known
# port number for both TCP and UDP; hence, most entries here have two entries
# even if the protocol doesn't support UDP operations.
# Updated from RFC 1700, ``Assigned Numbers'' (October 1994).  Not all ports
# are included, only the more common ones.
--More--
---------------------------------------------------

# more /etc/services
---------------------------------------------------
# /etc/services:
# $Id: services,v 1.42 2006/02/23 13:09:23 pknirsch Exp $
#
# Network services, Internet style
#
# Note that it is presently the policy of IANA to assign a single well-known
# port number for both TCP and UDP; hence, most entries here have two entries
# even if the protocol doesn't support UDP operations.
# Updated from RFC 1700, ``Assigned Numbers'' (October 1994).  Not all ports
# are included, only the more common ones.
--More--(0%)                          /* 0% 확인 */
---------------------------------------------------
```

cmd =  

well-known port

more 안에서 사용할 수 있는 여러 가지 키보드 키 값

more화면 창에서 h 또는 ?를 치면 아래와 같은 화면이 나오며 여러 가지 기능을 확인 할 수 있다.

```bash
Star (*) indicates argument becomes new default.
-------------------------------------------------------------------------------
**<space>                 Display next k lines of text [current screen size]**
z                       Display next k lines of text [current screen size]*
**<return>                Display next k lines of text [1]***
d or ctrl-D             Scroll k lines [current scroll size, initially 11]*
**q or Q or <interrupt>   Exit from more**
s                       Skip forward k lines of text [1]
f                       Skip forward k screenfuls of text [1]
b or ctrl-B             Skip backwards k screenfuls of text [1]
'                       Go to place where previous search started
=                       Display current line number
**/<regular expression>   Search for kth occurrence of regular expression [1]**
**n                       Search for kth occurrence of last r.e [1]**
!<cmd> or :!<cmd>       Execute <cmd> in a subshell
v                       Start up /usr/bin/vi at current line
ctrl-L                  Redraw screen
:n                      Go to kth next file [1]
:p                      Go to kth previous file [1]
:f                      Display current file name and line number
.                       Repeat previous command
-------------------------------------------------------------------------------
반드시 알아야 할 것들
spacebar : 매뉴얼 페이지에서 한 화면 단위로 넘어 갈 때 사용
Enter : 매뉴얼 페이지에서 한 라인씩 넘어 갈 때 사용
b : Back Screen, 한 화면 전 화면으로 넘어갈 때 사용
/pattern : 특정한 패턴을 빨리 찾을 때 사용
n : Next, 특정한 패턴을 찾은 후 다음 번째 똑같은 문자열을 찾을 때 사용
h : help 매뉴얼 페이지 안에서 사용 할 수 있는 명령어 소개
q : quit, 빠져나옴
```

### head 명령어

---

파일의 처음 시작 부분의 몇 줄을 출력 하고 자 할 때 사용. 따라서 긴 파일의 내용의 앞 부분만을 출력 하고자 할 때 유용하게 사용 되며 head 명령어에 아무런 옵션 없이 사용된 경우 문서의 처음 10줄을 보여 준다.

**[명령어 형식]**

```bash

# head /etc/passwd            (# head -10 /etc/passwd, # head -n 10 /etc/passwd)
# head -n 5 /etc/passwd/*     숫자에 해당하는 라인 번호 수 만큼만 출력 (기본은 10줄) */
# head -c 10 /etc/passwd/*    -c 옵션 다음에 오는 숫자 byte 수에 해당하는 만큼 출력 */
```

**[명령어 옵션]**

**옵션 : 설명**

-n (숫자) : 위쪽 행에서부터 출력할 행수를 지정   /* 자주 사용함 */
-c (숫자) : byte 수 만큼만 출력

**"head -n #" 실습**

```bash
# head -n 5 /etc/passwd    (# head -5 /etc/passwd)
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
```

```bash
# head -c 10 /etc/passwd
root:x:0:0
```

**head 명령어를 이용한 프로세스의 헤더 부분 출력**

```bash
# ps -ef 
# ps -ef | more 
# ps -ef | grep ssh
root       1488      1  0 16:51 ?        00:00:00 /usr/sbin/sshd -D
root       4092   1488  0 18:58 ?        00:00:00 sshd: root@pts/0
root       4354   4217  0 19:00 ?        00:00:00 /usr/bin/ssh-agent /bin/sh -c exec -l /bin/bash -c "env GNOME_SHELL_SESSION_MODE=classic gnome-session --session gnome-classic"
root       6513   1488  0 19:48 ?        00:00:00 sshd: root@pts/1
root       7119   6518  0 20:30 pts/1    00:00:00 grep --color=auto ssh
```

각각의 출력 내용이 무엇인지 정확히 알 수 없다.

```bash
# ps -ef | head –1
UID        PID  PPID  C STIME TTY          TIME CMD
```

```bash
# ps -ef | head -1 ; ps -ef | grep sshd  ( ; =  하나의 명령줄에 다수의 명령을 순차적으로 실행할 때)
UID         PID   PPID  C STIME TTY          TIME CMD
root       1266      1  0 12:38 ?        00:00:00 /usr/sbin/sshd -D
root       7878   1266  0 14:24 ?        00:00:00 sshd: root@pts/1
root       8047   7880  0 14:32 pts/1    00:00:00 grep --color=auto sshd
------------------------------------------------------------------------

출력 결과 분할
ps -ef | head -1 명령어의 결과
UID         PID   PPID  C STIME TTY          TIME CMD

ps -ef | grep sshd 명령어의 결과
root       1266      1  0 12:38 ?        00:00:00 /usr/sbin/sshd -D
root       7878   1266  0 14:24 ?        00:00:00 sshd: root@pts/1
root       8047   7880  0 14:32 pts/1    00:00:00 grep --color=auto sshd

ps -ef | head -1 ; ps -ef | grep sshd   두 명령어를 한번에 출력
```

```bash
# alias pps='ps -ef | head -1 ; ps -ef | grep $1'   /* $1 : 첫번째 인자(Argument) */
# pps sshd    (# pps syslogd)
UID         PID   PPID  C STIME TTY          TIME CMD
root       1266      1  0 12:38 ?        00:00:00 /usr/sbin/sshd -D
root       7878   1266  0 14:24 ?        00:00:00 sshd: root@pts/1
root       8047   7880  0 14:32 pts/1    00:00:00 grep --color=auto sshd
```

```bash
# vi ~/.bashrc (# gedit ~/.bashrc)
..... (중략) .....
#
# Sfecific Configuration
#
alias pps='ps -ef | head -1 ; ps -ef | grep $1'
```

```bash
# . ~/.bashrc   (# source ~/.bashrc) 
# pps syslogd 
-> 정상 출력 내용 확인
```

Unix 계열의 초창기 head와 유사한 명령어

```bash
# sed 5q /etc/passwd        /* 파일의 5줄을 출력하고, 끝내라(q)는 뜻 */
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
# sed -n '1,5p' /etc/passwd
```

### tail 명령어

---

tail은 텍스트파일이나 지정된 데이터의 마지막 몇 줄을 보여주는 데 사용하는 Unix 및 Unix계열 시스템에서의 프로그램이다. 파일의 끝 부분만 출력 하고자 할 때 사용하며, 아무런 옵션 없이 사용된 경우 문서의 마지막 10줄을 보여는데, 예를 들어서 사용자가 추가되면 /etc/passwd 파일에 마지막에 추가 된다. 이때 tail 명령어에 -1 옵션을 사용하여 사용자 추가를 확인 할 수 있다.

```bash
file1
+----------+
|          |
|          |
|          |
|          |
|          |
+----------+
```

**[명령어 형식]**

```bash
# tail /etc/passwd     (# tail -10 /etc/passwd, # taill -n 10 /etc/passwd)
# tail -5 /etc/passwd 
# tail -n +5 /etc/passwd < 상단의 라인에서 4개의 라인을 제거하고 나머지를 출력

# tail -f /var/log/messages
```

**[명령어 옵션]**

**옵션 : 설명**

-c (숫자) : 끝에서부터 지정된 수만큼의 바이트에 해당하는 정보를 보여준다.

**`-f :** 파일의 크기가 변할때마다 추가된 정보를 출력한다.`

-F : 위 -f옵션의 경우 파일크기가 변하여 5Mbytes 정도 되면 확장자에 숫자를 붙여 백업파일을 생성하고, 다시 본 파일은 0byte 부터 저장된다. 그래서 tail -f 파일명으로 실행중인 명령이 멈춰버린다는 문제가 생겨 재실행시켜줘야 하는 번거로움이 있다. -F옵션을 사용하면 이런 재실행문제 및 용량변화로 인한 문제를 걱정하지 않아도 된다. -f옵션때와 마찬가지로 Ctrl+C로 빠져나올 수 있다.

-(숫자) : 끝에서부터 지정된 수만큼의 줄을 보여준다.

-q : 출력결과에서 맨 윗줄에 입력파일명을 표시하지 않게 설정한다.

-v : -q와 반대로 출력결과에서 맨 윗줄에 입력파일명을 항상 표시해준다.

--help : 도움말을 보여준다.

--version : 버젼 정보를 보여준다.

**tail 명령어의 기본 사용법**

```bash
# tail -n 5 /etc/passwd   (# tail -5 /etc/passwd)
postfix:x:89:89::/var/spool/postfix:/sbin/nologin
sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
tcpdump:x:72:72::/:/sbin/nologin
user01:x:1000:1000:user01:/home/user01:/bin/bash
fedora:x:1001:1001::/home/fedora:/bin/bash
```

```bash
# tail -c 15 /etc/passwd
dora:/bin/bash
```

**로그 파일 모니터링(EX: tail -f CMD)**

tail은 실시간으로 파일의 변화를 감지할 수 있게 해주는 -f 옵션이라는 특별한 명령행 옵션을 가지고 있다. 

마지막 몇줄을 출력하고 끝내는 것에 그치지 않고, tail은 그 줄들을 표시하고 파일을 감독한다. 새 줄들이 다른 프로세스에 의해 그 파일에 추가될 때, tail의 -f옵션은 그 표시또한 실시간으로 업데이트한다. 이 옵션은 특히 로그파일(입출력정보파일)들을 감독할때 유용하다. 다음의 명령구문은 messages라는 파일의 마지막 열줄을 보여주고 새 줄들이 추가되면 그 줄들을 추가하여 보여준다.

- [참고] telnet 서비스 Open 방법(일반사용자)

[질문] 파일이 30 라인으로 되어져 있는데 파일 중간의 10라인만 출력해 볼 수 있나요?

```bash
# cp /etc/passwd /test/filename
# cd /test
# head -20 filename | tail –10
  head로 상단에서 20개 라인을 출력하고 PIPE로 받아 tail로 아래에서 10개 라인 출력
# nl filename | head -20 | tail -10
		11  uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin
    12  operator:x:11:0:operator:/root:/sbin/nologin
    13  games:x:12:100:games:/usr/games:/sbin/nologin
    14  gopher:x:13:30:gopher:/var/gopher:/sbin/nologin
    15  ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
    16  nobody:x:99:99:Nobody:/:/sbin/nologin
    17  vcsa:x:69:69:virtual console memory owner:/dev:/sbin/nologin
    18  apache:x:48:48:Apache:/var/www:/sbin/nologin
    19  exim:x:93:93::/var/spool/exim:/sbin/nologin
    20  rpc:x:32:32:Portmapper RPC user:/:/sbin/nologin
```

응용문제 (file1 앞의 5개 라인과 뒤의 5개 라인을 출력하자.)

```bash
# cat -n file1 | head -5; cat -n file1 | tail -5
```

```bash
[EX3] 서버를 실시간적으로 모니터링
[TERM1] # top                        (# gnome-system-monitor)
[TERM2] # tail -f /var/log/messages  (# gnome-system-log)

# tail -f /var/log/messages | grep -i DHCP 
# tail -f /var/log/messages | grep -i DNS 
# tail -f /var/log/messages | grep oracle 
# tail -f /var/log/messages | grep wasuser  (특정 서비스에 대한 모니터링)

또 다른 활용방안

# cat /var/log/messages | egrep –i '(warn|err|alert|emerg)'

grep  : 한가지 단어만 필터링
egrep : 두가지 이상 단어 필터링 가능
```

**정리**

```bash
cat -> 텍스트 파일을 열어서 확인하거나 새로운 텍스트 파일을 생성하거나 두 개 이상의 파일을 결합하여 새로운 파일로 생성. 출력
more -> 화면 이상으로 긴 파일의 경우에 순식간에 화면에서 지나가기 때문에 중간에 있는 내용을 확인하기 위해 사용되는 명령어
head -> 파일의 윗부분을 확인하는 명령어. 기본값은 10줄
tail -> 파일의 아랫부분을 확인하는 명령어. 기본값은 10줄
tail -f -> 파일에서 새로 생성되는 데이터를 출력해주는 용도. 모니터링 용으로 많이 활용
tail -f file1 | grep [text] -> 파일의 모든 내용을 확인하는 것이 아니라 [text] 구문만 따로 확인하기 위하여 사용
tail -f file1 | grep -E '(text1|text2|text3)' -> 파일의 모든 내용을 확인하는 것이 아니라. text1, text2, text3의 내용이 검색되는 경우에만 출력
tty = teletypewriter
```

## 기타 관리용 명령어

---

- wc 명령어

    ```bash
    # wc -l /etc/passwd
    # ps -ef | wc -l
    # cat /etc/passwd | wc -l
    # rpm -qa | wc -l
    ```

[참고] 데이터수집

```bash
# ps -ef | grep httpd | wc -l
# df -h | tail-1 | awk '{print $5}'
# cat /var/log/messages | grep 'START: telnet' | wc -l
```

### wc 명령어

---

파일 내의 문자수, 단어 수 그리고 라인수를 확인하고자 할 때 사용한다. wc 명령어를 사용하여 프로세스의 수, 시스템에 설치된 패치의 수, 시스템에 설치된 패치의 수 등을 확인 할 때 사용 할 수 있다. wc 명령어에 -l 옵션은 쉘스크립트나 파일에 대한 무결성 체크 등 많은 곳에서 활용이 가능하다.

**[명령어 형식]**

```bash
# wc /etc/passwd 
# wc –l /etc/passwd 
# wc –w /etc/passwd 
# wc –c /etc/passwd
```

**옵션 : 설명**

-c : 문자수만 출력
-l : 라인수만 출력
-w : 단어수만 출력
-L : 가장 긴줄 한줄만 출력

**wc 명령어 사용법**

```bash
# wc /etc/passwd
59    104   2902    /etc/passwd
# wc -l /etc/passwd
59       /etc/passwd
# wc -w /etc/passwd /* 단어수 (word) */
104       /etc/passwd
# wc -c /etc/passwd /* 문자수 (byte) */
2902      /etc/passwd
```

**시스템 사용자 수 확인**

```bash
# cat /etc/passwd | wc –l
59
# wc –l /etc/passwd
59 /etc/passwd
```

**실행중인 프로세스의 수 확인**

```bash
# ps -ef | wc -l
98
해당 숫자에서 제일 상단위 헤더를 제외하고 읽는다.

```

**설치된 패키지 수 확인**

```bash
# rpm -qa | wc –l
1451
```

**시스템성능/사용량 카운트 수집 : Data Gathering**

```bash
Apache Webserver
- apache 1.3.X(Process 방식)
- apache 2.X  (Thread 방식)

Web Client ------------> Web Server(www.daum.net)
http://www.daum.net      httpd
```

```bash
# yum -y install httpd    /* centos7 이상에선 yum 대신 dnf 사용 */
# systemctl restart httpd 
# systemctl status httpd
httpd.service - The Apache HTTP Server
   Loaded: loaded (/usr/lib/systemd/system/httpd.service; disabled)
   Active: active (running) since 월 2018-03-05 14:54:49 KST; 12s ago
     Docs: man:httpd(8)
           man:apachectl(8)
 Main PID: 9019 (httpd)
   Status: "Total requests: 0; Current requests/sec: 0; Current traffic:   0 B/sec"
   CGroup: /system.slice/httpd.service
....(중략)

-> 에러메세지 무시
```

```bash
# ps -ef | grep httpd
root       9019      1  0 14:54 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND
apache     9020   9019  0 14:54 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND
apache     9021   9019  0 14:54 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND
apache     9022   9019  0 14:54 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND
apache     9023   9019  0 14:54 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND
apache     9024   9019  0 14:54 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND
```

```bash
# ps -ef | grep httpd | wc -l > apache.count 
# cat apache.count
9
```

**디스크 사용량을 모니터링**

```bash
# df –k
Filesystem     1K-blocks    Used Available Use% Mounted on
/dev/sda8       58223848 4624432  53599416   8% /
devtmpfs          926916       0    926916   0% /dev
tmpfs             935380      84    935296   1% /dev/shm
tmpfs             935380    9132    926248   1% /run
tmpfs             935380       0    935380   0% /sys/fs/cgroup
/dev/sda7         508588   25852    482736   6% /home
/dev/sda6         508588   25760    482828   6% /data4
/dev/sda5         508588   25760    482828   6% /data3
/dev/sda3         508588   25760    482828   6% /data2
/dev/sda2         508588   25760    482828   6% /data1
```

```bash
# df –k /
Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/sda8       58223848 4624432  53599416   8% /
```

```bash
# df -k / | tail -1
/dev/sda8       58223848 4624432  53599416   8% /
```

```bash
# df -k / | tail -1 | awk '{print $5}' > df.count 
# cat df.count
8%
```

```bash
# df -k / | tail -1 | awk '{print $5}' | awk -F% '{print $1}' > df.count 
# cat df.count
8
```

[참고] awk 명령어

awk는 라인을 받아와서 구분자를 통해 구분하고 print 명령으로 출력하게 된다.

awk 명령어를 사용하기 전에 꼭 알아두어야 할 것은 기본적으로 탭 또는 공백으로 구분되는 각각의 단어들을 하나의 변수로 처리한다는 것이다. 탭과 공백을 무시하고 특정문자 콜론(:)이나, 세미콜론(;) 콤마(,) 등을 구분문자로 사용하고자 한다면 -F 옵션을 사용하면 된다.

```bash
명령어 형식 = awk [option] [-F] ['{script}']

# cd /test
# touch file1 file2 file3
# ls -l | grep "^-" | awk '{print "vi "$9}'
vi file1
vi file2
vi file3
```

ls -l 명령어로 현재 디렉토리의 목록을 출력하여 나온 결과를 grep 명령을 통해 "^-" 에 해당되는 값을 출력하여 awk 명령으로 "vi "$9 포맷형식으로 출력한 내용을 test.sh 파일에 복사하여 넣어라 라는 것입니다.

## 기타 관리용 명령어

---

- su 명령어

    ```bash
    # su user01
    # su - user01
    ```

- id 명령어

    ```bash
    # id
    # id user01
    ```

- groups 명령어

    ```bash
    # groups
    # groups user01
    # groups user01 root
    ```

### su 명령어

---

다른 사용자의 권한으로 쉘을 실행한다. 서버에 접속한 상태에서 로그아웃 없이 다른 사용자로 전환할 수 있음(windows의 사용자 전환 - terminal service (application)를 자동으로 만들어 놓아야 사용자 전환이 실행가능) 원격 접속시에 다른 사용자로 로그인하기 위해 로그아웃하면 접속이 종료가 되는데 접속이 종료 되지 않은 상태에서 다른 사용자로 로그인하고자 할 때 사용한다.

한명의 관리자가 여러 계정을 사용하는 경우 유용하다.

일반사용자가 다른 사용자가 되는 것을 권한이 높아지는 것이기 때문에 전환(Switching) 되는 사용자의 암호를 맞추어야만 전환이 가능하고, root 사용자가 다른사용자로 전환하는 경우에는 권한이 낮아지는 것이기 때문에 암호입력 없이 전환이 가능하다.

- [ ]  (사용자 전환의 예)

일반사용자(**user01**) ---->	다른 일반사용자(**user02**)
일반사용자(**user01**) ---->	관리자(**root**)
관리자(**root**) ---->	일반사용자(**user01**)

su 명령어 다음에 전환하고 싶은 사용자 이름이 없는 경우 root 사용자로 전환된다. 
그리고 su 명령어에 '-' 기호 없이 다른 사용자로 전환하는 경우 지정된 사용자로 전환이 되지만 이전 사용자가 쓰고 있던 export 변수들의 설정이 그대로 따라온다. su 명령어에 '-' 기호를 붙이고 다른 사용자로 전환하는 경우 지정된 사용자로 새로 로그인한 것 처럼 동작을 시켜서 사용자 환경변수로 모두 변경한다.(DB를 운영하는 oracle 사용자)

**[명령어 형식]**

```bash
# su [fedora]
# su - [fedora]
```

**su 명령어의 전환 형식 실습**

```bash
# cd /etc 
# pwd
/etc
```

```bash
# su fedroa 
$ id
uid=1001(fedora) gid=1001(fedora) groups=1001(fedora)
```

```bash
$ pwd
/etc
```

```bash
$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
```

```bash
$ exit 

# cd /etc 
# pwd
/etc
```

```bash
# su – fedora 
$ id
uid=1001(fedora) gid=1001(fedora) groups=1001(fedora)
```

```bash
$ pwd
/home/fedora
```

```bash
$ echo $PATH
/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/fedora/.local/bin:/home/fedora/bin
```

```bash
$ exit 
#
```

**fedora 사용자가 다른 사용자로 전환하는 경우**

```bash
# ssh fedora@localhost
fedora@localhost's password: (fedora)
Last login: Wed Jan  8 12:34:36 2014 from localhost.localdomain
-> 암호입력
```

```bash
$ cat /etc/shadow
cat: /etc/shadow: Permission denied
권한이 없기 때문에 파일의 내용을 확인할수 없다.
```

```bash
$ ls -l /etc/shadow
---------- 1 root root 1276  3월  5 14:54 /etc/shadow
자신의 계정이상으로 권한이 필요한 파일,디렉토리의 접근,수정에 사용한다.
```

```bash
$ su –        ($ su - root)
Password: (redhat)
-> root 사용자의 암호 입력
```

```bash
# id
uid=0(root) gid=0(root) groups=0(root)
```

```bash
# cat /etc/shadow
-> 파일 내용 확인
```

```bash
# exit 
$ exit 
#
```

su와 sudo의 차이점

```bash
관리자 비밀번호의 유무
su   - 관리자 비밀번호를 알려줘야한다
sudo - 해당 사용자가 사용할 수 있는 관리용 명령어를 제어할 수 있다.
```

### id 명령어

---

사용자의 uid, gid, groups을 보여줌 (사용자 이름의 길이가 긴 경우 메모리 기억공간의 낭비가 심함. but 정수로 사용자의 이름을 구분하는 경우 메모리 기억공간을 효율적으로 사용가능. 정수로 사용하여 4byte씩 사용될 경우 0 ~ 4294967295명까지 구분이 가능)

**[명령어 형식]**

```bash
# id 
# id -u root 
# id -g root
```

**[명령어 옵션]**

**옵션 : 기능**

-g : 기본 그룹의 gid를 출력 (사용자가 소속되어 있는 기본 그룹)
-G : 사용자가 속한 모든 그룹의 gid를 출력
-u : 사용자의 uid를 출력
-n : -u과 함께 사용하여 숫자 대신 이름 출력

**id 명령어 사용**

```bash
# id
uid=0(root) gid=0(root) groups=0(root)
```

```bash
# id –g root
0
```

```bash
# id -G root
0
```

```bash
# id –Gn root
root
```

동일한 방법으로 fedora 계정에 대하여 확인해봅시다.

### groups 명령어

---

[명령어 형식]

```bash
# groups	            /* 현재 사용중인 사용자의 그룹을 보여줌 */
# groups user1	      /* user1의 그룹을 보여줌 */
# groups user1 user2	/* user1, user2의 그룹을 보여줌 */
```

**groups 명령어 사용법**

```bash
# groups
root
```

```bash
# groups fedora
fedora : fedora
```

```bash
# groups fedora root
fedora : fedora
root : root
```

```bash
# cat /etc/group
root:x:0:root
bin:x:1:root,bin,daemon
daemon:x:2:root,bin,daemon
sys:x:3:root,bin,adm
adm:x:4:root,adm,daemon
..... (중략) ....
sabayon:x:86:
fedora:x:500:
user01:x:501:

-> 시스템에 선언된 모든 그룹들에 대한 기본적인 정보를 표시한다.
```

group에 사용자를 추가할 경우

```bash
# adduser –G [GROUP] [USER]
```

[참고사항]

```bash
UNIX 계열 계정이 그룹에 가입할때 그룹의 갯수가 16개 이상이 되면 최초 가입된 그룹부터 삭제
LINUX 계열 리눅스에서는 UNIX에서 일어나는 문제가 없다.
```

```bash
# usermod -aG g17
# groups user1
	g2 g3 - g17

SEVER -> 고가의 장비의 가격 (?...?억)
warranty -> A/S 기간
life time

DNS SERVER
domain -> IP

중앙집중식 계정 관리
```

## 기타 관리용 명령어

---

- last 명령어

    ```bash
    # last
    # last user01
    # last reboot
    # last -20
    # last -f /var/log/wtmp.0
    ```

- lastlog 명령어

    ```bash
    # lastlog
    # lastlog -u user01
    # lastlog -t 10
    ```

- lastb 명령어

    ```bash
    # lastb
    # lastb -20
    ```

### last 명령어

---

서버를 이용하는 각 계정사용자들의 로그인 정보를 보여주는 명령어이다. 흔히 관리자는 각 계정별로 서버에 접속한 시간과 IP주소 등을 확인해야 할 경우가 있다. 또한 특정 계정의 서버 접속정보를 확인해야 할 때 에도 마찬가지이다. 다양한 방법으로 사용자들의 로그인정보를 조사한다.

**[명령어 형식]**

```bash
# last 
# last root 
# last -5 /* 5행의 결과만을 확인 */
# last -R /* last의 결과에서 호스트(IP주소)접속기록을 제외한 결과만을 출력 */
# last -a /* last의 결과중 호스트(IP주소)정보를 맨 마지막에 출력 */
```

**[명령어 옵션]**

**옵션 : 설명**

-n : (num) 지정한 num 만큼의 줄만 보여준다.
-f : (file) 지정한 파일에서 정보를 불러온다.
-R : 보여주는 목록에서 hostname(IP주소)필드는 보여주지 않는다.
-a : 보여주는 목록에서 hostname(IP주소)필드를 마지막 필드에 보여준다.
-d : 다른 호스트에서 접속한 것만 보여준다.
-x : shutdown이 일어난 상태나, run level이 바뀐 상태를 보여준다.

**last 명령어 사용**

[TERM1] fedora 사용자의 터미널

```bash
# ssh fedora@localhost 
-> fedora 사용자의 암호 입력
$ tty
/dev/pts/#
```

[TERM2] 관리자 터미널

```bash
# last               /* 최근기록이 상단에 출력된다. head 명령어와 같이 사용된다 */
fedora   pts/2        192.168.0.1      Wed Feb 10 10:27   still logged in
root     pts/1        192.168.0.1      Wed Feb 10 10:25   still logged in
reboot   system boot  2.6.18-164.el5   Wed Feb 10 10:23          (00:08)
root     pts/2        linux200         Wed Jan 27 14:11 - 14:28  (00:16)
root     pts/1        192.168.0.1      Wed Jan 27 14:11 - 14:28  (00:17)
fedora   pts/2        192.168.0.1      Wed Jan 27 13:52 - 14:10  (00:18)
root     pts/1        192.168.0.1      Wed Jan 27 13:40 - 14:10  (00:29)
root     pts/4        :0.0             Wed Jan 27 13:39 - 13:39  (00:00)
root     pts/3        192.168.0.1      Wed Jan 27 13:30 - 13:39  (00:09)
root     pts/3        192.168.0.1      Wed Jan 27 13:29 - 13:30  (00:00)
root     :0                            Wed Jan 27 13:27 - crash (13+20:55)
root     :0                            Wed Jan 27 13:27 - 13:27  (00:00)
```

**출력 내용 설명**

```bash
# last -5
fedora   pts/2        192.168.10.1     Fri Mar 13 10:08   still logged in   
root     pts/1        192.168.10.1     Fri Mar 13 10:04   still logged in   
fedora   pts/1        localhost        Thu Mar 12 16:55 - 17:00  (00:04)

root             LOGIN 이름(어떤 계정으로 접속하였는지 확인)
pts/1            터미널 번호
192.168.10.1     접속지 IP 

Fri Mar 13 10:04 , Wed Jan 27 14:11 - 14:28  LOGIN 시간을 나타낸다. 만약 로그아웃까지 완료하였으면 (14:11 - 14:28)의 형식으로 출력된다. 시간은 분단위로 측정되지만 절대 시간으로 초단위로 계산 되는 것이 ㅇ
still logged in  현재 로그인중. 만약 로그아웃까지 완료하였으면 (00:04 작업 진행시간)으로 출력된다.
```

```bash
# last -5                          (# last | head –5)/* 상위 5개 라인 출력 */ 
fedora   pts/2        192.168.0.1      Wed Feb 10 10:27   still logged in
root     pts/1        192.168.0.1      Wed Feb 10 10:25   still logged in
reboot   system boot  2.6.18-164.el5   Wed Feb 10 10:23          (00:09)
root     pts/2        linux200         Wed Jan 27 14:11 - 14:28  (00:16)
root     pts/1        192.168.0.1      Wed Jan 27 14:11 - 14:28  (00:17) 

wtmp begins Tue Jan 26 01:25:16 2010

상위라인으로 출력하는 이유는 최신의 정보가 위에서 부터 쌓이고 있다.
```

**/var/log/wtmp.# 파일 읽기**

```bash
# file /var/log/wtmp                                      /* data 파일 타입을 가지고 있다 */
/var/log/wtmp: data
```

```bash
# file /etc/passwd                                        /* text 파일의 경우에 확인 가능 */
/etc/passwd: ASCII text
```

```bash
# cat /var/log/wtmp                                       /* 파일을 열수 있는 형식 아님 */
췱:0root?rKNJ췱:0:0root?r?
pts/1R.rKP(mpts/3S.smpts/4S.rK?쫚pts/1ts/1root192.168.0.1^.rKNp웸npts/1횲rKblpts/2JNrK懲
...... (중략) ......
```

```bash
# last -f /var/log/wtmp    (# last)
root     pts/1        192.168.0.1      Wed Feb 10 15:47   still logged in
root     pts/1        192.168.0.1      Wed Feb 10 12:56 - 14:40  (01:44)
root     :0                            Wed Feb 10 12:44   still logged in
root     :0                            Wed Feb 10 12:44 - 12:44  (00:00)
root     pts/4        linux200         Wed Feb 10 12:43 - 12:56  (00:12)
root     pts/3        linux200         Wed Feb 10 12:32 - 12:56  (00:23)
root     pts/2        192.168.0.1      Wed Feb 10 11:53 - 15:12  (03:18)
fedora   pts/2        192.168.0.1      Wed Feb 10 10:27 - 11:33  (01:05)
root     pts/1        192.168.0.1      Wed Feb 10 10:25 - 12:56  (02:30)
```

**[참고] last -f 옵션 사용하는 경우**

```bash
# cd /var/log 
# ls wtmp* 
wtmp  wtmp.0  wtmp.1  wtmp.2 ....

# last   -----> /var/log/wtmp
# last –f /var/log/wtmp.0  < 정책에 의해 로그가 일정 기간이 지나면 다른 파일로 저장된다 >
/etc/logrotate.conf 파일에 의해 결정
기간이 지난 파일의 로그인기록을 확인할 경우 사용한다.

last -f 사용하는 이유
log 파일은 시간이 지나게 되면 스케쥴러, 로그 용량 관리에 의하여 백업되고 새로운 파일로 다시 시작하게 된다.

wtmp < 시작파일
시간이 지나서 백업
wtmp.0 < 기존 파일 백업
wtmp < 새로운 파일 시작

이후에 기존의 로그 파일은 wtmp.0를 읽으려해도 새로운 파일인 wtmp파일만 접근을 시도한다

기존에 존재하던 wtmp.0 (백업파일)을 읽고 확인하기 위해서 필요한 옵션이 -f 옵션이다.
```

**last 명령어의 사용 예**

```bash
(개발자 요청 내용) 어제 파일(예: file.log)을 삭제한 사용자를 검색해 달라.

(정보1) 어제 파일이 지워졌다.
# last | grep 'Jun  8'
(정보2) 지워진 파일의 이름 : file.log
# cat ~/.bash_history 
# cat ~/.bash_history | grep 'file.log' | grep rm
```

[작업 준비]

```bash
# cd /test 
# chmod 777 /test 
# touch file.log 

# ssh fedora@localhost 
fedora 사용자로 로그인

$ rm –rf /test/file.log 
$ ls /test 
-> file.log 파일이 지워졌는지 확인

$ exit
```

```bash
# last | grep 'Sep  9'
fedora   pts/4        linux249         Fri Sep  9 10:29 - 10:30  (00:00)    
root     pts/3        :0.0             Fri Sep  9 10:11   still logged in   
fedora   pts/2        linux249         Fri Sep  9 10:11   still logged in   
root     pts/2        linux249         Fri Sep  9 10:10 - 10:10  (00:00)    
root     pts/1        :0.0             Fri Sep  9 10:00   still logged in   
root     pts/1        :0.0             Fri Sep  9 09:59 - 10:00  (00:00)    
root     :0                            Fri Sep  9 09:59   still logged in   
root     :0                            Fri Sep  9 09:59 - 09:59  (00:00)    
reboot   system boot  2.6.18-164.el5   Fri Sep  9 09:56          (00:35)
```

```bash
# egrep -l "file.log" /home/*/.bash_history
/home/fedora/.bash_history
```

```bash
# egrep "file.log" /home/fedora/.bash_history
rm -rf /test/file.log
```

```bash
# last | awk '{print $1}' | sort | uniq
```

last → 접속 기록을 확인.

파일, 변경, 삭제가 일어 난 경우

접근 기록을 찾기 위한 첫 번째 사용 명령어

```bash
# last | grep -E '(Nov 30|Nov 29)' | awk '{print $1}' | sort | uniq

# grep -l "file.log" /home/*/.bash_history < 전체 사용자를 대상으로 검색
# grep "file.log" /home/fedora/.bash_history < 특정 사용자를 대상으로 검색

cat /var/log/message
cat /var/log/secure

후처리:
파일 권한에 대한 관리
chmod 775 /* 삭제 권한 제한 */
```

### lastlog 명령어

---

사용자의 마지막 로그인 정보만을 출력 해준다. lastlog는 /var/log/lastlog라는 파일의 내용을 출력해 준다. 로그인할 때 마지막 로그인 정보가 출력되는데 이때 출력되는 정보가 /var/log/lastlog의 정보이다. 사용자 계정을 지우게 되면 /var/log/lastlog 파일에도 사용자계정에 해당 정보도 삭제된다.

**[명령어 형식]**

```bash
# lastlog
# lastlog -u feodra /* 지정한 로그인명의 lastlog 정보만을 보여준다. */
# lastlog -t 3 /* 지정한 날짜기간 안에 로그인한 정보만을 보여준다 */
```

**[명령어 옵션]**

**옵션 : 설명**

-u : 지정된 사용자의 lastlog 기록을 보여줌
-t : 지정된 날짜기간 안의 로그인 정보만 출력해 준다.

**lastlog 명령어 사용법**

```bash
# telnet localhost (# ssh localhost)
login as: root
root@192.168.0.200's password:
Last login: Wed Feb 10 10:25:22 2010 from 192.168.0.1 
# exit
```

```bash
# lastlog
Username         Port     From             Latest
root             pts/2    linux249         Fri Sep  9 10:41:24 +0900 2011
bin                                        **Never logged in**
daemon                                     **Never logged in**
adm                                        **Never logged in**
lp                                         **Never logged in**
sync                                       **Never logged in**
shutdown                                   **Never logged in**
halt                                       **Never logged in**
mail                                       **Never logged in**

..... (중략) .....

rpcuser                                    **Never logged in**
named                                      **Never logged in**
hsqldb                                     **Never logged in**
sshd                                       **Never logged in**
haldaemon                                  **Never logged in**
avahi-autoipd                              **Never logged in**
xfs                                        **Never logged in**
gdm                                        **Never logged in**
sabayon                                    **Never logged in**
fedora           pts/4    linux249         Fri Sep  9 10:29:54 +0900 2011
user01           pts/3    linux249         Thu Sep  8 10:26:39 +0900 2011
```

출력내용설명

```bash
Username         Port     From             Latest
root             pts/2    linux249         Fri Sep  9 10:41:24 +0900 2011
sabayon                                    **Never logged in**

Username     계정이름
Port         터미널 정보
From         접속을 시도한 호스트
Latest       최종 접속 일자,시간  ( **Never logged in**)> 단 한번도 접속한 적이 없다는 의미
```

```bash
# lastlog –u fedora
Username         Port     From             Latest
fedora           pts/2    192.168.0.1      Wed Feb 10 10:27:47 +0900 2010
```

### lastb 명령어

---

접속 실패 로그를 출력해준다. /var/log/btmp파일에 로그가 저장된다. cat이라는 명령어를 통해서 안의 내용을 열어보면 파일의 내용이 제대로 나오지 않는다. 이 파일의 내용을 보기 위해서 우리가 사용하는 명령어가 바로 lastb라는 명령어다. 보통 블루투스 공격(임의의 사용자 계정과 임의의 패스워드로 내 시스템에 접속하려는 것)을 당하는지, 당했는지와 어떤 사용자가 잘못 로그인을 했는지와 같은 정보를 확인 할 수 있다.

`관리자만 확인 가능하다`

**[명령어 형식]**

```bash
# lastb
```

**[명령어 옵션]**

**옵션 : 설명**

-n : (num) 지정한 num 만큼의 줄만 보여준다.
**-f :** (file) 지정한 파일에서 정보를 불러온다.
-R : 보여주는 목록에서 hostname(IP주소)필드는 보여주지 않는다.
-x : shutdown이 일어난 상태나, run level이 바뀐 상태를 보여준다.

**lastb 명령어 실습**

(전제 조건) user01 사용자가 존재해야 한다.

```bash
[192.168.10.252]
# cat /etc/passwd | grep user01 
# useradd user01 
# passwd user01
```

```bash
# ssh user01@192.168.10.252
user01@192.168.10.252 is password:  <----- 잘못된 암호 입력
Permission denied, please try again.
user01@192.168.10.252 is password:  <----- 잘못된 암호 입력
Permission denied, please try again.
user01@192.168.10.252's password:   <----- 잘못된 암호 입력
Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).
```

```bash
192.168.10.252로 root 접속
# lastb
user01   ssh:notty    localhost.locald Sat Mar 23 15:49 - 15:49  (00:00)    
user01   ssh:notty    localhost.locald Sat Mar 23 15:49 - 15:49  (00:00)    
user01   ssh:notty    localhost.locald Sat Mar 23 15:49 - 15:49  (00:00)    
rppt     :0                            Wed Feb 13 17:48 - 17:48  (00:00)    
root     ssh:notty    172.16.9.1       Mon Feb  4 15:35 - 15:35  (00:00)    
root     ssh:notty    172.16.9.1       Mon Feb  4 15:35 - 15:35  (00:00)    
ftp      ssh:notty    172.16.9.1       Mon Feb  4 15:35 - 15:35  (00:00)
..... (중략) .....
```

```bash
# lastb –5              /* 지정된 만큼만 기록을 보여줌 */
user01   ssh:notty    localhost.locald Sat Mar 23 15:49 - 15:49  (00:00)    
user01   ssh:notty    localhost.locald Sat Mar 23 15:49 - 15:49  (00:00)    
user01   ssh:notty    localhost.locald Sat Mar 23 15:49 - 15:49  (00:00)    
rppt     :0                            Wed Feb 13 17:48 - 17:48  (00:00)    
root     ssh:notty    172.16.9.1       Mon Feb  4 15:35 - 15:35  (00:00)    

btmp begins Wed Apr 11 13:33:02 2012
```

```bash
# lastb | grep user01
user01   ssh:notty    localhost.locald Sat Mar 23 15:49 - 15:49  (00:00)    
user01   ssh:notty    localhost.locald Sat Mar 23 15:49 - 15:49  (00:00)    
user01   ssh:notty    localhost.locald Sat Mar 23 15:49 - 15:49  (00:00)
```

```bash
# lastb | grep user01 | wc –l
3
```

사용자로 접근 하는 경우 로그인시 신경 써야 하는 내용

```bash
# ssh fedora@localhost
fedora@localhost's password: 
Activate the web console with: systemctl enable --now cockpit.socket

Last failed login: Mon Nov 30 15:54:32 KST 2020 from ::1 on ssh:notty
There were 3 failed login attempts since the last successful login.
Last login: Mon Nov 30 15:06:41 2020 from ::1

/* Last failed login 기록이 남아있다면 위험하다 */
```

## 기타 관리용 명령어

---

- who 명령어

    ```bash
    # who
    ```

- w 명령어

    ```bash
    # w
    # w user01
    # while true
     > do
     > w user01
     > sleep 2
     > done
    ```

### who 명령어

---

who 명령을 통해 누가 로그인해 있는지, 어떤 장치를 이용하고 있는지, 언제 로그인했는지, 어디에서 로그인했는지 등의 정보를 알 수 있다. **/var/run/utmp**의 내용을 보여줌!

**[명령어 형식]**

```bash
# who      /* 현재 시스템에 접속 중인 모든 사용자 */
# who -r   /* 현재 사용자의 Runlevel 확인 */
# who am i /* 로그인한 사용자 정보 확인 */
# who -H   /* 헤드라인과 같이 출력 */
# whoami   /* 현재 사용자명 확인 , 유효사용자를 확인한다*/
```

**[명령어 옵션]**

**옵션 : 기능**

-i : idle time 과 함께 사용자 출력
-m : who 명령을 실행한 사용자 표시
-q : 사용자 이름과 사용자수 출력
-w, -T : 각 사용자의 메시지 설정 상태 출력
-H : 헤드라인 정보 표시
-r : run-level 확인

**who 명령어 실습**

192.168.10.252 서버에 설치되어 있는 telnet 서비스로 접속을 하여 현재 사용자에 대하여 확인해보자.

[TERM1] fedora 사용자의 윈도우

```bash
# telnet 192.168.10.252 
-> fedora 사용자로 로그인

$ id
uid=1001(**fedora**) gid=1001(**fedora**) groups=1001(**fedora**) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
```

```bash
$ pwd
/home/fedora
```

```bash
$ tty
/dev/pts/[NUMBER]
[NUMBER]는 부여받는 터미널 번호에 따라 다르다.
```

[TERM2] root 사용자의 윈도우

```bash
# who
root     pts/1        Feb 10 15:47 (192.168.0.1)          /* Putty로 로그인하여 작업중 */
root     pts/2        Feb 10 16:34 (192.168.0.1)
**fedora   pts/[NUMBER] Feb 10 22:50 (192.168.0.1)**
root     :0           Feb 10 12:44
root     pts/3        Feb 10 21:33 (192.168.0.1)
```

```bash
(명령어 출력 결과 해석)
-------------------+--------------------------
필드 설명            |
-------------------+--------------------------
root               | 사용자 정보
pts/1              | 제어 터미널
Feb 10 15:47       | 로그인 시간
192.168.0.1        | 원격호스트
-------------------+--------------------------
```

[TERM1] fedora 사용자의 윈도우

```bash
$ exit
#
```

**who 명령어 실습**

```bash
# ssh root@192.168.10.252
The authenticity of host '192.168.10.252 (192.168.10.252)' can't be established.
RSA key fingerprint is 3b:25:5b:9a:ae:0f:ba:fc:85:66:73:d4:fc:e2:78:c6.
Are you sure you want to continue connecting (yes/no)? yes 
Warning: Permanently added '192.168.10.252' (RSA) to the list of known hosts.
root@172.16.9.249's password: (centos)
Last login: Thu Jan  9 11:38:41 2014 from 192.168.10.200
```

```bash
# hostname
server2.example.com
```

```bash
# id
uid=0(root) gid=0(root) groups=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
```

```bash
# tty
/dev/pts/4
```

```bash
# who
root     :0           2014-02-12 22:29
root     pts/1        2014-02-12 22:29 (:0.0)
root     pts/2        2014-02-13 10:29 (linux205.example.com)
root     pts/3        2014-02-13 10:31 (linux206.example.com)
root     pts/4        2014-02-13 10:29 (linux249.example.com)
root     pts/5        2014-02-13 10:29 (linux208.example.com)
root     pts/6        2014-02-13 10:29 (linux218.example.com)
root     pts/7        2014-02-13 10:29 (linux201.example.com)
root     pts/8        2014-02-13 10:30 (linux207.example.com)
root     pts/9        2014-02-13 10:30 (linux219.example.com)
root     pts/10       2014-02-13 10:30 (linux214.example.com)
root     pts/11       2014-02-13 10:31 (linux200.example.com)
..... (중략) .....

# exit 
#
```

## w 명령어

---

시스템에 login한 사용자가 어떤 명령어를 실행하고 있는지 알아보는 명령어이며, /proc 디렉토리로 부터 사용자에 대한 정보와 실행중인 명령어에 대한 정보를 추출해 낸다.

**[명령어 형식]**

```bash
# w 
# w user01
```

```bash
# w
10:34:14 up 28 min,  3 users,  load average: 0.00, 0.01, 0.01
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
root     :0                        10:07   ?xdm?  12.60s  0.19s /usr/bin/gnome-ses
root     pts/1    :0.0             10:10    0.00s  0.03s  0.00s w
root     pts/3    :0.0             10:27    7:00   0.02s  0.02s bash
```

**w 명령어 실습**

[TERM1] root 사용자 윈도우

```bash
-> putty 프로그램을 통해 리눅스 서버(192.168.10.252)에 접속
login : root
passwd : (redhat)
```

[TERM2] fedora 사용자 윈도우

```bash
# ssh fedora@192.168.10.252
fedora@192.168.10.252's password: (fedora)
Activate the web console with: systemctl enable --now cockpit.socket

Last login: Wed Aug 26 10:01:21 2020 from 192.168.10.252
```

[TERM3] user01 사용자 윈도우

```bash
# telnet localhost 
user01 사용자로 로그인
```

```bash
$ vi /etc/passwd
```

[TERM4] root 사용자 윈도우(분석하는 터미널)

```bash
# w
10:43:47 up 38 min,  7 users,  load average: 0.00, 0.03, 0.01
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
root     :0                        10:07   ?xdm?  14.78s  0.19s /usr/bin/gnome-ses
root     pts/1    :0.0             10:10    2:56   0.03s  0.00s ssh fedora@localho
root     pts/3    :0.0             10:27   48.00s  0.02s  0.00s telnet localhost
root     pts/2    172.16.9.1       10:39    3:43   0.01s  0.01s -bash
fedora   pts/4    localhost.locald 10:40    2:51   0.01s  0.01s -bash
user01   pts/5    localhost.locald 10:42   48.00s  0.04s  0.03s vim /etc/passwd
root     pts/6    :0.0             10:43    0.00s  0.01s  0.00s w
```

**악의적인 사용자 로그아웃 시키기**

[TERM4] 관리자 윈도우

```bash
# w
10:43:47 up 38 min,  7 users,  load average: 0.00, 0.03, 0.01
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
root     :0                        10:07   ?xdm?  14.78s  0.19s /usr/bin/gnome-ses
root     pts/1    :0.0             10:10    2:56   0.03s  0.00s ssh fedora@localho
root     pts/3    :0.0             10:27   48.00s  0.02s  0.00s telnet localhost
root     pts/2    172.16.9.1       10:39    3:43   0.01s  0.01s -bash
fedora   pts/4    localhost.locald 10:40    2:51   0.01s  0.01s -bash
user01   pts/5    localhost.locald 10:42   48.00s  0.04s  0.03s vim /etc/passwd
root     pts/6    :0.0             10:43    0.00s  0.01s  0.00s w
```

```bash
# w user01
10:48:23 up 42 min,  7 users,  load average: 0.00, 0.02, 0.00
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
user01   pts/5    localhost.locald 10:42    5:24   0.04s  0.03s vim /etc/passwd
```

```bash
# while true
> do
> echo
> echo "============`date`============"
> w user01
> sleep 2
> done
```

```bash
# ps -u user01    (# ps -fu user01)
PID TTY          TIME CMD
 8064 pts/5    00:00:00 bash
 8100 pts/5    00:00:00 vim
```

```bash
# kill -9 8064 
#
```

[참고] 원격서버에 접속시

```bash
원격서버에 접속하여 접속한 서버의 이름, 사용자, 작업 디렉토리 확인
# ssh 172.16.9.252
root 사용자로 로그인

# hostname
# id
# pwd
```

[참고] 관리 서버에 접속시

```bash
자신이 관리하는 서버에 접속하여 오늘 로그인/로그아웃 사용자 정보 확인
현재 접속되어져 있는 사용자 확인
현재 접속된 사용자가 수행하는 명령어 확인
# last
# who
# w
```

로그를 저장하는 여러가지 방법

```bash
# tlog-rec -w file -o /root/tlog1.log
-w : 파일 형식
-o : file-path
# tlog-play -i /root/tlog1.log
-i : file-path
```

### exit 명령어

---

현재의 프로세스(현재쉘)를 종료한다.

**[명령어 형식]**

```bash
# exit [Number] /* 값을 지정해준다면 0은 정상종료, 1~255는 비정상 종료 */
```

**서브 쉘 종료 해보자**

```bash
# ps
PID TTY          TIME CMD
21224 pts/11   00:00:00 bash
```

```bash
# bash
```

```bash
# ps
PID TTY          TIME CMD
21224 pts/11   00:00:00 bash
21316 pts/11   00:00:00 bash
```

```bash
# exit
exit
```

```bash
# ps
PID TTY          TIME CMD
21224 pts/11   00:00:00 bash
```

**서버에 접속 후 로그 아웃**

```bash
# ssh 172.16.9.252 
root 사용자로 접속

# hostname 
# id 
# pwd 

# ps 
# exit 
#
```

**사용자 전환후에 원래 사용자로 전환**

```bash
# su – user01 
$ ps 
$ exit 
#
```

[참고]

```bash
쉘 스크립트 작성시에 사용되는 exit 
상태값 지정
```

## 총 정리

---

```bash
- plain text를 보는 명령어들 -
plain text > 그래픽, 오브젝트에 대한 표현이 아니라 읽을 수 있는 자료의 문자열
cat  : 파일을 결합하여 읽어내거나, 파일을 읽거나, 파일을 결합하여 새로운 파일로 생성
more : cat의 단점을 보완(파일을 읽을 때 화면보다 큰 파일의 경우에도 마지막까지 한순간에 읽고 지나간다.) 한 페이지씩 파일을 멈추어 확인 할 수 있다.
head : 파일의 첫부분을 확인하는 용도
tail : 파일의 뒷부분을 확인하는 용도 (tail -f: 모니터링 용도, 데이터가 새로 생성되는 경우에 화면에 출력을 해 준다.)
			 tee > 디스크에 저장 + 모니터 출력

- 기타 관리용 명령어들 -
wc      : word count. 파일의 데이터가 몇 개의 단어, 문자, 라인으로 되어 있는지 확인하는 명령어 (-l : 라인 수)
su      : 하위 쉘을 생성하며 타 계정으로 접속할 때 사용(- 유무)
		     - 없는 경우 : 환경변수를 재적용하지 않기 때문에 실제 변경된 유저의 권한이 닌 이전 사용자의 권한으로 실행되는 문제점이 발생 할 수 있다.
		     - 있는 경우 : 환경변수를 적용하기 때문에 이전 사용자의 권한으로 실행되는 문제가 발생 하지 않는다.
sudo    : 사용자가 다른 사용자로 치환하여 명령어를 사용할 때 쓰는 명령어

su, sudo 차이점 > 변경하는 계정의 비밀번호를 알아야 하느냐? 몰라도 되느냐

id      : 사용자의 uid, gid, group 정보를 볼 수 있는 명령어
groups  : 사용자의 그룹을 확인 할 수 있는 명령어
last    : 접속 기록을 확인하는 명령어
lastlog : 계정단위로 마지막 접속 기록을 확인하는 명령어
lastb   : 사용자가 접속에 실패한 로그
who     : 현재 접속중인 사용자가 누구인지를 확인하는 경우에 사용하는 명령어
w       : 현재 접속중인 사용자가 무슨 명령어를 입력하고, 실행하는지 확인하는 명령어
while   : 
				  while true : 반복문을 시작
				  do         : 여기서부터 본문
				  action     : 반복문에서 실제로 동작하는 부분
				  done       : 여기까지가 본문
tlog    : 모니터에 입 출력되는 내용을 시간 단위로 저장하고 json format으로 저장한다. 이후에 해당 파일을 재생하여 이전에 작업한 것을 실시간으로 확인 가능하다. tlog 자체로는 명령어가 존재하지 않는다.
			    tlog-rec, tlog-play 명령어가 있으니 확인
script  : 모니터에 출력된 내용을 저장하여 이후에 확인 용도로 사용한다.
exit    : 종료를 하는 경우 뒤에 숫자를 입력하여 $?값을 변경 할 수 있다.
```

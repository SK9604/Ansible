- **VMware**

    # 저장

    리눅스 환경 저장하는 방법

    1. 스냅샷(snapshot)

        빠르게 예전 시점으로 돌아갈 수 있다.

        백업 대용으로 사용시 머신이 망가지는 경우가 존재. 여러개의 시점을 생성하는 경우 디스크 I/O이 많아져 성능이 떨어질 수 있다.

    2. OVF Open Virtualization Format

        이기종 플랫폼(windows, mac..)간의 가상머신 이동. 서버로의 이동 등이 자유롭다.

        import, export하는데 시간이 상당히 오래 걸린다.

    3. ZIP

        빠르다

        이기종간의 배포 불가능. 파일 자체가 문제가 생길 경우도 존재한다.

    # 가상 머신 작업

    1. 복사
        - link clone : 원본을 참조하여 생성되는 클론. 용량이 작지만 원본에 문제가 생기는 경우에 사용이 불가능하다.
        - full clone : 원본과 별도의 파일로 생성되는 클론. 원본과 별개이기 때문에 원본에 문제가 생겨도 가상머신 사용에 문제가 없지만 용량 측면에서는 좋지 않다.
    2. 호스트이름 설정

        ```bash
        # hostname                                          /* 확인 */
        # hostnamectl set-hostname server2.example.com      /* 변경 */
        ```

    3. 네트워크 설정

        [유선 연결됨] → [유선 네트워크 설정] → [유선 켬 옆 설정 버튼] → [IPv4 탭] → [주소에 주소] → 192.168.10.252 입력 → [유선 켬 스위치 껐다 키기]

        ```bash
        # ifconfig
        ip 주소 확인
        # ping www.google.com 
        네트워크 설정 확인
        ```

- **터미널**

    # 터미널 사용 팁

    1. 터미널 글씨 크기 조절

        ```bash
        ctrl + shift + [+]
        ctrl + [-]
        ```

    2. Runlevel

        init 0 : 종료

        init 6 : 재부팅

        init 2,3 : 텍스트 모드 (2는 nfs 미지원 (Network File System))

        init 5 : 그래픽 모드

    3. 제어 문자

        ctrl + c : 현재 사용중인 프로그램을 인터럽트를 걸어서 종료시킨다

        ctrl + d : 파일의 끝 (EOF(End Of File)), 현재 쉘 종료(Exit)

    4. 현재 위치 확인

        ```bash
        # pwd
        ```

    5. 명령어 위치 확인

        ```bash
        # which man
        # whereis man   -> 명령어 위치, 도움말 위치
        ```

    6. 복사

        드래그 후 휠클릭시 드래그된 문자 복사 후 붙여넣기 된다.

    7. 일정시간마다 자동 갱신해서 명령어 결과 보여주기

        ```bash
        # watch -n 1 [명령어]
        1초마다 갱신하여 명령어 정보를 띄워준다
        ```

    8. 괄호 사용법

        ```bash
        $(..) : 괄호 안 명령어를 명령어로 인식(텍스트로 인식하지 않고)
        ${..} : 괄호 안 변수를 인식
        ```

    9. 하위 디렉토리 트리구조 보기

        ```bash
        # tree
        ```

    10. 한번에 여러 CMD 사용

        ```bash
        ; =  하나의 명령줄에 다수의 명령을 순차적으로 실행할 때
        ```

    11. 현재 설치되어 있는 모든 패키지 출력

        ```bash
        # rpm -qa
        ```

    12. 디스크 사용량 모니터링

        ```bash
        # df -k
        ```

    13. 쉘 종료

        ```bash
        # exit [number]  /* 값을 지정해준다면 0은 정상 종료, 1~255는 비정상 종료 */
        종료하는 경우 뒤에 숫자를 입력하여 $?값을 변경할 수 있다.
        ```

- **보안**

    # 암호 설정

    1. 암호 변경 

        ```bash
        # passwd
        ```

        - 관리자

            모든 사용자의 암호를 변경할 수 있다. 이전 비밀번호를 알 필요 없다. 비밀번호 규칙 무시 가능하다.

        - 일반 사용자

            자신의 암호만을 변경할 수 있다. 이전 비밀번호를 알아야 하며 규칙을 따라야 한다.

        저장 위치

        /etc/passwd 에 저장된다.

        비밀번호를 눈으로 확인하면서 비밀번호 변경하기

        ```bash
        # echo '[설정할 비밀번호]' | passwd --stdin [사용자이름] 
        ※ 비밀번호가 history에 노출되기 때문에 반드시 history를 지울 필요가 있음
        ```

    # 로그인 정보 관련 명령어

    1. last 명령어 : 서버를 이용하는 각 계정 사용자들의 로그인 정보를 보여주는 명령어이다.

        ```bash
        # last
        # last root
        # last -5   /* 5행 결과만 */
        # last -R   /* 호스트(IP 주소) 접속기록을 제외한 결과 출력 */
        # last -a   /* 호스트 정보(IP 주소)를 맨 마지막에 출력 */
        ```

        옵션

        ```bash
        -f : 지정한 파일에서 정보를 불러온다.
        		 log 파일은 시간이 지나게 되면 스케쥴러, 로그 용량 관리에 의하여 백업되고 새로운 파일로 다시 시작하게 된다.
        -R : 호스트(ip주소) 접속기록을 제외한 결과 출력
        -a : 호스트 정보(ip주소)를 맨 마지막에 출력
        ```

        -f 옵션을 사용하는 이유

        ```bash
        wtmp < 시작파일
        시간이 지나서 백업
        wtmp.0 < 기존 파일 백업
        wtmp < 새로운 파일 시작

        이후에 기존의 로그 파일은 wtmp.0를 읽으려해도 새로운 파일인 wtmp파일만 접근을 시도한다

        기존에 존재하던 wtmp.0 (백업파일)을 읽고 확인하기 위해서 필요한 옵션이 -f 옵션이다.
        ```

    2. lastlog 명령어 : 계정 단위로 마지막 접속 기록을 확인하는 명령어

        ```bash
        # lastlog
        # lastlog -u feodra /* 지정한 로그인명의 lastlog 정보만을 보여준다. */
        # lastlog -t 3 /* 지정한 날짜기간 안에 로그인한 정보만을 보여준다 */
        ```

    3. lastb 명령어 : 사용자가 접속에 실패한 로그를 확인하는 명령어로 관리자만 확인 가능하다.

        ```bash
        # lastb
        ```

    4. who 명령어 : 누가 로그인해 있는지, 어떤 장치를 이용하고 있는지 등 정보

        /var/run/utmp 의 내용을 보여준다.

        ```bash
        # who      /* 현재 시스템에 접속 중인 모든 사용자 */
        # who -r   /* 현재 사용자의 Runlevel 확인 */
        # who am i /* 로그인한 사용자 정보 확인 */
        # who -H   /* 헤드라인과 같이 출력 */
        # whoami   /* 현재 사용자명 확인 , 유효사용자를 확인한다*/
        ```

    5. w 명령어 : 시스템에 로그인한 사용자가 어떤 명령어를 실행하고 있는지 알아보는 명령어이다.

        ```bash
        # w
        # w user01
        root     pts/3    :0.0             10:27    7:00   0.02s  0.02s -bash
        -bash 는 명령어 입력을 기다리고 있는 상태를 뜻한다.
        ```

        사용자를 감시할 때 사용하기도 한다.

        ```bash
        # watch -n 1 'w user01'
        또는
        # while true
        > do
        > echo `======$(date)=====`
        > w user01
        > sleep 2
        > done
        ```

    6. 로그인 밴하기

        ```bash
        # kill -9 [pid] ; passwd -l user01
        passwd -l : 비밀번호 잠금
        ```

    # 소유권한/그룹권한

    1. 권한 변경을 위한 사전 검사

        변경하려는 계정이 존재하는지 항상 확인

        계정 : /etc/passwd

        그룹 : /etc/group

    2. 소유자 변경
        - chown 명령어

            유닉스 계릉 시스템에서 사용하는 파일의 소유권을 바꾸기 위해 사용하는 명령어

            root권한만 사용 가능

            ```bash
            # chown user01 file1
            # chown .user01 file1    
            # chown user01.user01 file1
            ```

            옵션

            ```bash
            -c : 바뀌어지는 파일들에 대해서만 자세하게 보여준다.
            -f : 바뀌어 지지 않는 파일들에 대해서 오류 메시지를 보여주지 않는다.
            -v : 작업 상태를 자세히 보여준다.
            -R : 경로와 그 하위 파일들 모두를 바꾼다.
            ```

        - 대량의 파일의 권한 변경시 문제점

            ```bash
            만약에 변경할 파일 및 디렉토리가 200.000개 이상인경우에는 95% 확률로 에러가 난다.
            chown을 비롯한 많은 파일작업에는 sort작업이 들어간다.
            sort 명령어가 입력되며 생기는 문제점 : 
            해결책 :
            1. find 명령어로 모든 파일 및 디렉토리를 절대경로로 검색 > 출력
            2. 출력된 파일을 반복문(for문)으로 작업 
            3. 이렇게 시간이 오래 걸리는 작업의 경우에는 tmux 명령어를 이용하여 해당 터미널을 백그라운드에서 작업하는 것을 권장
            ```

    3. 그룹
        - chgrp 명령어

            파일의 속성정보 중 그룹명을 변경하는 명령어이다.

            일반 사용자도 사용 가능하다.  그룹에 가입 되어있어야 사용 가능

            ```bash
            # chgrp user01 file1
            ```

    # 권한 변경

    1. chmod 명령어

        파일의 소유자나 관리자만이 명령어를 사용할 수 있다.

        파일의 소유자, 파일의 그룹, 다른 사용자 로 나누어 각각의 권한을 설정 할 수 있다.

        ```bash
        # chmod 777 file1
        # chmod u+x file1
        ```

        읽기 권한이 없으면 파일 안에 있는 내용을 볼 수 없다. 따라서 파일을 수정하기 위해서는 반드시 read 권한을 부여해야 한다.

        - 심볼릭 모드(Symbolic mod) : chmod u+x file1

            ```bash
            u : user
            g : group
            o : other
            a : all
            + : 퍼미션 허가
            - : 퍼미션 금지
            = : 퍼미션 지정
            r : 읽기 권한
            w : 쓰기 권한
            x : 실행 권한
            ```

        - 옥탈 모드(Octal mod) : chmod 777 file1

            권한 변경시 문자가 아닌 숫자로 하는 권한 설정

            ```bash
            r w x
            4 2 1

            777 > rwxrwxrwx
            642 > rw-r---w-
            135 > --x-wxr-x
            ```

    2. 파일과 디렉토리 퍼미션의 정확한 의미

        디렉토리의 권한의 차이에 따라 사용 가능한 명령어가 존재하며 권한을 부여받지 못할 시 정상적인 디렉토리 접근, 파일 제어가 불가능하다.

        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e38da8df-4dd9-495d-916a-0f9d559a8307/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e38da8df-4dd9-495d-916a-0f9d559a8307/Untitled.png)

        - 디렉토리

            ```bash
            r : ls 명령어를 사용할 수 있는가
            w : 파일을 복사, 삭제
            x : 디렉토리에 대한 실행 > cd
            ```

    3. umask

        파일과 디렉토리의 권한이 존재하고 (파일:666, 디렉토리:777) 기본권한에서 umask를 뺀 값이 현재 내가 파일, 디렉토리를 생성하는 경우 사용 가능한 디폴트 권한이 된다.

        ```bash
        # umask
        # umask 007
         -> 777 -> umask 007 -> 770
        ```

    # SETUID/SETGID, stickybit

    1. 파일에 대한 권한을 소유한 것 처럼 잠시 소유권을 빌려주는 것. 공유한 디렉토리나 파일에 대해 많이 사용한다.
    2. 기본 정보

        실행권한(x)을 가진 프로그램에 부여한다.

        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fa981a84-241f-4530-b441-ce5ac9a736b6/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fa981a84-241f-4530-b441-ce5ac9a736b6/Untitled.png)

        ```bash
        # chmod 4777
        천자리 수
        setuid setgid sticky-bit
          4      2        1
        ```

    3. setuid

        프로그램의 소유자처럼 권한이 생긴다.

        ```bash
        # chmod 4777
        -rwsrwxrwx
        # chmod 4677
        -rwSrwxrwx
        ```

        일반 사용자가 비밀번호를 변경하는 경우

        /etc/passwd

        /etc/shadow 

    4. setgid

        프로그램의 그룹에 속한 것처럼 권한이 생긴다.

        ```bash
        # chmod 2777
        -rwxrwsrwx
        # chmod 2767
        -rwxrwSrwx
        ```

    5. sticky bit

        파일의 쓰기 권한이 없어도 디렉토리에 쓰기 권한이 있는 경우 디렉토리 권한에 의해 파일이 삭제된다.

        마음대로 삭제 할 수 업도록 sticky 권한을 부여한다. (쓰기 권한 그대로, 삭제 권한 제거)

        파일의 소유자나 그룹, 관리자는 제외된다

        보통 디렉토리가 777권한일 때 사용된다.

        ```bash
        # chmod 1777
        -rwxrwxrwt
        # chmod 1776
        -rwxrwxrwT
        ```

    6. 특수 퍼미션을 가진 파일 찾기

        ```bash
        # find / -perm -4000 -or -perm -2000 -type f 2> /dev/null
        ```

- **명령어**

    # 명령어

    1. 형식

        ```bash
        # [명령어] [옵션] [인자]
        쉘 프롬프트, ls touch tee.. , -l -i -a.. , /var /test...
        ```

        옵션에서 대시바의 개수에 따른 의미

        ```bash
        - : 뒤의 문자를 한 자씩 인식         ex) -all  ->  -a -l -l 과 같음
        -- : 뒤의 문자를 하나의 단어로 인식  ex) --all  ->  all로 인식하여 -a와 같음
        ```

    2. 리눅스에서 명령어를 사용하는 이유
        - GUI 사용시 GUI에 사용되는 리소스 점유율이 높다.
        - 서비스 측면에서 더 많은 사용자를 수용할 수 있다.
        - 네트워크 트래픽의 감소
    3. 내/외장 명령어

        ```bash
        # whatis [명령어]
        bash_built-in command < 이 내용이 나온다면 이 명령어는 bash 내장 명령어이다.
        # man bash
        내장 명령어들 확인
        ```

        - 쉘 내장 명령어 : bash shell에 같이 존재하는 명령어
        - 쉘 외장 명령어 : /usr/bin /usr/sbin,, 특정 디렉토리에 설치되어 있는 명령어
    4. 시작단어

        ```bash
        ch -> 변경
        ls -> 출력, 확인
        rm -> 삭제
        mk -> 생성
        ```

    # 도움말

    1. man 명령어

        명령어에 대한 메뉴얼 제공

        ```bash
        # man [명령어]   ex) # man ls
        ```

        man창에서 단축어

        - / : 검색
        - Shift+n , n: 다음/이전 검색어 위치로 이동
        - q : 빠져나오기
        - enter : 한 라인씩 넘어가기
        - space bar : 한 페이지씩 넘어가기

        옵션

        ```bash
        -k : 명령어가 정확히 기억이 안나는 경우 키워드 검색
        		 ex) # man -k calendar
        ```

    2. help

        ```bash
        # [명령어] --help
        ```

    3. whatis

        ```bash
        # dnf -y install man-db-cron
        # cd /etc/cron.daily
        # ./man-db.cron

        # whatis [명령어]
        	[명령어] (섹션번호)      - 설명
        ```

        섹션번호 의미

        1 - 누구나 실행할 수 있는 명령어

        5 - 파일 포맷

        8 - 시스템 관리자만 실행할 수 있는 관리 명령어

    # 반복문

    1. while

        ```bash
        while true : 반복문을 시작
        do         : 여기서부터 본문
        action     : 반복문에서 실제로 동작하는 부분
        done       : 여기까지가 본문
        ```

- **운영체제**

    # 운영체제 정보

    1. uname 명령어

        ```bash
        # uname [옵션]
        ```

        옵션

        ```bash
        -a : 모든 정보
        -nsr : 호스트이름, 운영체제 종류, 운영체제 릴리즈
        ```

    2. 릴리즈 버전

        ```bash
        # cat /etc/redhat-release
        ```

    3. uname대신 시스템 정보 확인 명령어

        ```bash
        # hostnamectl
        ```

    # 시간

    1. date 명령어

        ```bash
        # date
        ```

        일반사용자는 확인만 가능. 관리자는 변경 가능

        - 포맷

        ```bash
        # date +%m%d_%H%M   /* %m : month, %d : day, %H : hour, %M : Minute, %S : second */
        월 일 시 분 연도 순서
        # date 081613002009
        ```

        - 파일에 시간정보 같이 저장하기

        ```bash
        # touch file_`date +%m%d`.log
        # touch file_$(date +%m%d).log
        역따옴표 안에 date 포맷 입력
        ※ 그냥 date만 줄 시(touch `date`) 월, 일, 연도 등이 전부 따로 각 파일의 이름으로 저장된다
        ```

    2. rdate 명령어

        8버전 이상에서는 없어진 명령어

        UDP 라 위험하다. 네트워크에서 보낸 시간을 포함시키지 않는 문제가 있다.

         (라우터를 거치면서 네트워크 트래픽이 존재할 경우 딜레이가 생겨 서버에 요청하여 받은 시간과 서버의 시간이 차이가 존재할 수 있다)

        ```bash
        # rdate -s time.bora.net
        타임서버의 시간을 운영체제 시간에 적용
        ```

    3. 하드웨어/소프트웨어 시간

        ```bash
        하드웨어 시간   : hwclock --show
        소프트웨어 시간 : date
        ```

        동기화

        ```bash
        # hwclock --systohc   /* system -> hard */
        # hwclock --hctosys   /* hard -> system */
        ```

        하드웨어 시간을 쓰는 경우 : 수은건전지가 다 되어서 시간이 완전 뒤틀려버린 경우 (거의 사용 안함)

    4. touch 명령어 (파일의 수정시간 변경)

        ```bash
        # touch -t 08081230 [파일명]  /* 월, 일, 시, 분 */
        ```

- **유저**

    # 유저, 그룹 관리

    1. su 명령어 (switching user)

        다른 사용자의 권한으로 쉘을 실행한다. 서버에 접속한 상태에서 로그아웃 없이 다른 사용자로 전환할 수 있다.

        관리자 : 비밀번호 없이 접속 가능

        일반 사용자 : 비밀번호 알아야 접속 가능

        ```bash
        # su [유저이름]    /* 환경변수를 재적용 하지 않기 때문에 실제 변경된 유저의 권한이 아닌 이전 사용자의 권한으로 실행되는 문제점이 발생 할 수 있다. */
        # su - [유저이름]  /* 환경변수를 적용하기 때문에 이전 사용자의 권한으로 실행되는 문제가 발생하지 않는다. */
        ```

        su 명령어에 '-' 기호 없이 다른 사용자로 전환하는 경우 지정된 사용자로 전환이 되지만 이전 사용자가 쓰고 있던 export 변수들의 설정이 그대로 따라온다.

    2. sudo

        사용자가 다른 사용자로 치환하여 명령어를 사용할 때 쓰는 명령어

        /etc/sudoers에서 설정

        su, sudo 차이점 > 변경하는 계정의 비밀번호를 알아야 하느냐? 몰라도 되느냐

    3. id 명령어

        사용자의 uid, gid, groups을 보여준다.

        ```bash
        # id
        ```

        옵션

        ```bash
        -g : gid 출력
        -u : uid 출력
        -n : -u나 -g와 함께 사용하여 숫자대신 이름 출력
        ```

    4. groups 명령어

        현재 사용중인 사용자의 그룹을 보여준다.

        ```bash
        # groups
        # gorups [유저이름], ..
        ```

        그룹에 사용자 추가

        ```bash
        # adduser -G [group] [user]
        ```

- **디렉토리**

    # 디렉토리 파일

    1. 구조

        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/20388f74-01a8-4471-850b-278ba853f632/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/20388f74-01a8-4471-850b-278ba853f632/Untitled.png)

    2. **디렉토리는 파일을 저장하는 것이 아니라 파일의 이름만 저장한다.**
    3. 파일, 일반파일 등을 담는 바구니
    4. 기본적으로 `. ..` 이라는 두가지 디렉토리가 존재

    # 디렉토리 위치 관련 명령어

    1. 현재 위치

        ```bash
        # pwd
        ```

    2. 이동 명령어

        ```bash
        # cd [위치]
        .  : 현재 위치
        .. : 상위 위치
        # cd -         /* 바로 이전에 있던 디렉토리로 이동 */
        	$OLDPWD 에 저장되어있다
        ```

        - 절대 경로 : 루트 디렉토리부터 모든 경로를 적어야 한다. `항상 /로 시작`
        - 상대 경로 : 현재 디렉토리부터 경로를 적어야 한다. `. 과 .. 을 사용한다`
    3. 홈 디렉토리

        ```bash
        # cd $HOME
        # cd ~
        # cd ~fedora   /* fedora의 홈 디렉토리 */
        # cd ~/fedora  /* 홈 디렉토리 아래 fedora 폴더로 이동 */
        ```

    # 디렉토리 내용 관련 명령어

    1. ls 명령어

        ```bash
        # ls [옵션] [파일/디렉토리명]   /* 파일 디렉토리 명은 생략가능. 생략시 현 위치의 내용 확인 */

        ```

        옵션

        ```bash
        -l : long. 디렉토리가 지정되는 경우 디렉토리의 내용을 자세히 보여준다. 파일인 경우는 파일의 속성 정보를 자세히 보여준다.
        	-lR: 해당하는 디렉토리명을 출력한 뒤 디렉토리 내부의 파일과 디렉토리를 출력한다.
        	-ld: 현 디렉토리 정보를 자세히 출력
        d|rwxr-xr-x|.|2|root|root|19|11월 26 16:05|dir1
        d             : 파일의 형식을 보여준다.
        		            ls에서 많이 나타나는 파일의 형식
                         - : 일반파일
        			               실행파일, 데이터 파일, 로그, 웬만한 것들은 모두 일반 파일로 분류
                         d : 디렉토리
        				             디렉토리(폴더)
        								 c : 캐릭터 파일
        								 b : 블록 파일
        						    장치파일 : /dev : c 캐릭터 파일 b 블록파일
        rwxr-xr-x     : 파일의 권한
        .             : 보안적인 요소 (ACL 권한이 포함되어 있는지의 유무)
        						    . -> ACL이 설정 되어 있지 않다.
        						    + -> ACL이 설정 되어 있다.
        2             : 링크카운트
        						    디스크에 존재하는 파일에서 몇 개의 접근 지점이 존재하는가?
        root          : 개인 소유자 uid
        root          : 그룹 소유자 gid
        19            : 용량
        11월 26 16:05 : 수정 시간
        dir1          : 파일 이름, 디렉토리 이름
        								접근을 위해서 사용해야 하는 오브젝트
        -------------------------------------------------------------------------------------------------------------------------
        -a : all. 숨김파일(.)도 포함하여 전부 출력
        -i : inode 표시
        -F : 이름 뒤에 / -디렉토리, @ - 링크파일, * - 실행파일
        -h : 사람이 봤을 때 편한 단위로 용량을 보여준다.
        ```

    # 디렉토리 생성/삭제 명령어

    1. mkdir 명령어

        ```bash
        # mkdir [디렉토리명]
        # mkdir dir1              /* 현 디렉토리에 dir1 디렉토리 1개 생성 */
        # mkdir dir1 dir2         /* 현 디렉토리에 dir1, dir2 디렉토리 2개 생성 */
        # mkdir dir{1..10}        /* 1~10까지 디렉토리 한번에 생성 */
        ```

        옵션

        ```bash
        -p : 디렉토리 경로로 생성
        	ex) # mkdir -p dir2/dir3/dir4/dir5/dir6
        ```

    2. rmdir 명령어

        ```bash
        # rmdir [디렉토리명]
        ```

        ❗ 디렉토리가 비어있지 않으면 삭제 불가능

    3. rm -rf 명령어

        삭제 명령어

        디렉토리가 비어있지 않아도 사용 가능

- **파일**

    # 파일 구조

    1. 파일의 구조

        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/041893b1-5184-4b9b-94de-87386a69fbc3/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/041893b1-5184-4b9b-94de-87386a69fbc3/Untitled.png)

    2. 파일의 종류

        일반파일, 디렉토리 파일, 링크 파일, 장치 파일, 소켓 파일, 도어 파일, 파이프 파일

        ```bash
        # ls -l
        - : 일반 파일
        d : 디렉토리 파일
        b : 블록 디바이스 파일
        c : 문자 디바이스 파일
        l : 심볼릭 링크
        ```

    3. 대소문자를 구분한다
    4. 리눅스에서는 모든 것을 파일로 다룬다!
    5. 파일의 이름 

        같은 디렉토리 안에서 유일한 것. 파일을 접근하기 위해 사용한다.

        대소문자를 구별한다.

        사용가능한 특수문자 : `. _ -`

        .으로 시작하는 파일의 이름은 보통 시스템의 환경파일로 일반 파일에서는 잘 사용하지 않는다.

    6. inode

        파일에 대한 정보를 담고 있는 부분이다.

        파일에 대한 속성 정보와 데이터 블록을 가리키고 있는 포인터를 가지고 있다.

        - 갖고 있는 정보

            ```bash
            파일의 종류
            파일의 퍼미션모드
            파일의 소유자, 그룹
            파일의 링크수
            파일의 마지막 접근 시간, 수정 시간
            파일의 크기
            두 가지 형태의 포인터
            ```

    7. Data block

        디스크 공간에 대한 단위로서 데이터를 저장하는 역할

        - 내용

            ```bash
            일반 파일의 경우 파일의 내용이 들어있다.
            디렉토리인 경우 안에 포함된 파일과 디렉토리이름이 들어있다.
            ```

    # 링크 파일 (link file)

    1. 구조

        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b2cca4a-7ce8-4009-9bc7-04282c0d4920/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b2cca4a-7ce8-4009-9bc7-04282c0d4920/Untitled.png)

    2. 하드 링크 (hard link)
        - `원본 파일의 경로를 저장하고 있는 파일`로 실제 경로가 아니라 사용하기 편한 다른 경로로 접근할 수 있도록 지정하는 명령이다.
        - 원본파일과 똑같은 파일 크기로 `원본 파일이 수정될 경우 하드링크된 파일도 동일하게 변경`된다.
        - 자원을 공유하되 데이터를 안전하게 관리하고자 할 때 유용하게 사용할 수 있다.
        - 디렉토리에 생성 불가하며 파일에만 생성 가능하다.
        - 동일한 inode를 갖는다.
        - ln 명령어

            ```bash
            # ln file1 file2
            ```

    3. 소프트 링크 (symbolic link)
        - 일반적인 링크. 윈도우의 바로가기와 같다
        - 여러 디렉토리에서 동일한 라이브러리를 요구할 경우나, 하나의 파일을 여러 사람이 공통으로 사용할 경우도 많이 사용한다.
        - `퍼미션은 모든 유저에게 모든 권한 (chmod 777)을 준다.`
        - 포인트하는 정보만 들어있을 뿐 `원본파일은 아니다.`
        - ln 명령어

            ```bash
            # ln -s file1 file2
            file2에는 file1의 inode가 아니라 file1의 path정보가 저장된다.
            경로에 대하여 절대 경로, 상대 경로 지정하는 상태로 저장되기 때문에 원본파일을 절대경로로 추가하는 것을 추천한다.
            ```

    # 디바이스 파일

    ```bash
    # ls -l /dev | grep disk
    drwxr-xr-x. 6 root root         120 Dec 18 14:50 disk
    crw-rw----. 1 root disk     10, 237 Dec 18 14:50 loop-control
    brw-rw----. 1 root disk      8,   0 Dec 18 14:50 sda
    brw-rw----. 1 root disk      8,   1 Dec 18 14:50 sda1
    brw-rw----. 1 root disk      8,   2 Dec 18 14:50 sda2
    brw-rw----. 1 root disk      8,   3 Dec 18 14:50 sda3
    brw-rw----. 1 root disk      8,   4 Dec 18 14:50 sda4
    brw-rw----. 1 root disk      8,   5 Dec 18 14:50 sda5
    brw-rw----. 1 root disk      8,   6 Dec 18 14:50 sda6
    crw-rw----. 1 root disk     21,   0 Dec 18 14:50 sg0

    =================해석==================
    crw-rw----. > c, b 캐릭터, 블록
    21,   0     > major, minor device 번호
    ```

    1. 블록 디바이스 파일
        - I/O단위의 크기 : 4K 4096 Byte
        - 한번의 입출력이 많아야 하는 장치의 경우 블록 장치로 동작
        - Disk
    2. 캐릭터 디바이스 파일
        - I/O단위의 크기 : 512 Byte
        - 한번의 입출력이 많지 않은 경우 캐릭터로 동작
        - tty, tape, LTO, cdrom
    3. major device 번호

        장치의 종류

    4. minor device 번호

        개별적인 장치의 종류 또는 동작 방법의 차이

    # 파일 생성

    1. touch 명령어

        ```bash
        # touch [파일 이름]
        # touch .[파일 이름]        /* 숨김파일로 생성 */
        # touch [파일이름{1..10}]   /* 1~10번 파일 한번에 생성 */
        ```

    2. cp 명령어

        복사하는 명령어

        ```bash
        # cp file1 file2    /* file1 파일 내용으로 file2 생성 */
        # cp file1 dir1     /* file1 파일 내용으로 dir1폴더 아래 file1이름으로 생성 */
        ```

        옵션

        ```bash
        -f : 복사할 파일이 존재할 때 삭제하고 복사(덮어쓰기)
        -p : 원본 파일의 소유, 그룹, 권한, 허용 시간을 보존한 채로 복사
        -r : 서브 디렉토리 내에 있는 모든 파일까지 통째로 복사
        -v : 복사 상태를 보여준다.
        ```

    3. mv 명령어

        파일의 디렉토리를 이동할 때 사용하는 명령어

        ```bash
        # mv file1 file2  /* file1 파일이 이름이 file2로 변함 */
        # mv file1 dir1   /* file1 파일이 dir1 디렉토리 하위경로로 이동 */
        # mv dir1 dir2    /* dir1 디렉토리가 dir2 디렉토리 하위경로로 이동 */
        # mv file* dir1   /* file로 시작하는 모든 파일을 dir1 디렉토리 하위경로로 이동 */
        ```

        옵션

        ```bash
        -f : 복사할 파일이 존재할 때 삭제하고 복사(덮어쓰기)
        -v : 파일 옮기기 전의 과정을 보여준다.
        ```

    4. cat 명령어

        ```bash
        # cat file1 file2 > file3  /* file1과 file2 내용을 합쳐 file3으로 저장 
        ```

    # 파일 정보

    1. file

        파일의 종류를 알 수 있는 명령어이다.

        ```bash
        # file *
        현 디렉토리의 모든 파일의 형식을 확인한다.
        # file /etc/passwd

        # wget http://mirror.centos.org/centos/8/BaseOS/x86_64/os/Packages/kernel-4.18.0-193.el8.x86_64.rpm
        # ls
        # mv kernel-4.18.0-193.el8.x86_64.rpm install.rpm
        # file *
        # uname -a
        ```

        리눅스에서는 확장자가 큰 의미가 없다.

    2. stat

        ```bash
        # stat [파일명]
        파일의 세부 정보를 볼 수 있다. 접근시간. 수정시간, inode 변경 시간(ls -l 정보가 변경될 때)
        accesstime, modifytime 이 000000으로 되어있다면 누군가 touch로 임의로 시간을 변경했음을 알 수 있다.
        ```

    3. inode

        파일의 속성정보와 데이터 블럭을 포인트하는 정보가 들어있으며 Is 명령어에 -l 옵션을 사용하여 대부분의 정보를 확인 할 수 있다

    4. 파일 정보를 보는 명령어들

        ```bash
        # ls
        # ls -l file1
        # ls -lZ file1
        # lsattr file1
        # getfac1 file1
        ```

    # 파일 내용 확인

    1. cat 명령어

        텍스트 파일을 읽고, 결합하고 표준 출력으로 내보내는 명령어이다.

        ```bash
        # cat file1          /* file1 파일 내용을 출력 */
        # cat file1 file2    /* file1, file2 파일 내용을 출력 */
        ```

        옵션

        ```bash
        -n : 줄 번호 함께 출력
        ```

    2. strings 명령어

        바이너리 파일을 읽을 때 사용하는 명령어이다.

        ```bash
        없는경우 설치 필요
        # dnf -y install binutils
        # strings -f /bin/ls
        ```

        옵션

        ```bash
        -f : 파일 이름 출력
        ```

    3. more 명령어

        큰 파일을 출력할 때 화면 크기 페이지 단위로 출력한다. cat와 달리 모든 출력결과가 한번에 표시되지 않고 한 페이지씩 걸려 확인 가능하다.

        ```bash
        # more file1  /* file1 파일을 출력 */
        mannual 페이지의 단축키와 동일하게 적용됨
        # CMD | more
        ```

    4. head 명령어

        파일의 시작부분의 몇 줄을 출력하고자 할 때 사용한다.

        ```bash
        # CMD | head -10  /* 10줄 출력 */
        # head -n 10 /etc/passwd
        # head -10 /etc/passwd
        ```

        옵션

        ```bash
        -n : 왼쪽 행에서부터 출력할 행 수를 지정
        ```

        헤더 출력

        ```bash
        # ps -ef | head -1 ; ps -ef | grep sshd
        ```

    5. tail 명령어

        파일의 마지막 부분의 몇 줄을 출력하고자 할 때 사용한다.

        ```bash
        # tail -10 /etc/passwd
        # CMD | tail -10
        ```

        옵션

        ```bash
        -f : 파일의 크기가 변할때마다 추가된 정보를 출력한다.
        ```

    6. wc 명령어

        CMD 결과 값의 문자, 단어, 라인 수를 출력한다.

        ```bash
        # CMD | wc -l   /* 라인수 출력 */
        # CMD | wc -w   /* 단어수 출력 */
        # CMD | wc -c   /* 문자수 출력 */
        ```

    7. awk 명령어

        CMD 결과 값의 몇번째 필드만 뽑을 것인지 확인한다.

        ```bash
        # CMD | awk '{print $1}'  /* 첫번째 필드만 뽑아라 */
        ```

    # 삭제

    1. rm 명령어

        삭제시 정말 바로 삭제된다

        때문에 보통 mv로 한 디렉토리로 이동 시키고 일정 시간이 지나면 삭제되도록 한다.

- **로그**

    # 로그

    1. tlog 명령어

        모니터에 입 출력되는 내용을 시간 단위로 저장하고 json format으로 저장한다. 이후에 해당 파일을 재생하여 이전에 작업한 것을 실시간으로 확인 가능하다. tlog 자체로는 명령어가 존재하지 않는다.

        ```bash
        # tlog-rec
        # tlog-play
        # tlog-rec-session
        ```

        ```bash
        # tlog-rec -w file -o /root/tlog1.log
        # exit

        -w : 파일형식
        -o : file-path

        내가 타이핑 한 것들이 모두 영상 틀듯이 저장되어 플레이됨
        # tlog-play -i /root/tlog1.log
        -i : file-path
        ```

    2. script 명령어

        모니터에 출력된 내용을 저장하여 이후에 확인 용도로 사용한다.

        ```bash
        # script -a wlog.script
        # exit
        문제점: 결과로만 나온다 > 개선한 것 tlog
        ```

    3. logger 명령어

        ```bash
        # logger test111
        # cat /var/log/messages | grep test111
        Dec 1 00:48:54 server2 root[34818]: test111
        ```

        날짜를 포함하여 파일에 로그 남기는 방법

        ```bash
        # while true
        > do
        > echo "=====$(date)=====" | tee -a file1
        > w user01 | tee -a file1
        > done
        ```

- **데이터**

    # 메타 데이터

    데이터를 위한 데이터

    어떤 목적을 가지고 만들어진 데이터 → 목적: 이 데이터를 설명하기 위한 데이터

    # 비교

    1. diff 명령어

        버전이 다른 두 파일을 비교해서 어느 파일에 내용이 추가 되었고 어느 파일에 내용이 삭제 되었는지를 찾는 용도

        형식

        ```bash
        # diff file1 file2 /* 파일 두개의 간략한 차이점 */
        ```

        옵션

        ```bash
        -c : 자세히 출력
        -i : 대소문자 구분하지 않음
        -d : 디렉토리 차이 출력
        -r : 두 디렉토리를 비교할 때, 모든 서브디렉토리는 재귀적으로 비교한다.
        ```

        마이그레이션등의 스토리지 이동, 데이터 이동후에는 diff 명령어와 디렉토리 전체 비교 옵션을 사용하여 디렉토리내의 파일들의 자료 무결성을 검사한다.

    # 정렬

    1. sort 명령어

        파일의 정렬, 하나 또는 그 이상의 파일의 텍스트 줄을 스크린상에서 정렬하고자 할 때 사용한다.

        형식

        ```bash
        # sort /etc/passwd
        ```

        옵션

        ```bash
        -t : 필드 구분자를 지정한다. (기본값은 공백이 기준이 된다.)
        -k : 정렬할 필드를 지정한다.
        -r : 내림차순 정렬
        -o : 결과를 파일에 저장한다.
        -n : 숫자로 정렬한다.
        ```

        ```bash
        # sort -t : -k 1 /etc/passwd
        # sort -n -t : -k 3 /etc/passwd | more
        # df | sort -n -k 3 -r | head -1
        # df | sort -n -k 3 -r | head -1 | awk '{print $5" "$6}'
        ```

        저장되어 있는 파일을 정렬하는 경우에는 sort 단독으로 사용되는 경우도 있지만 실시간 정보들의 경우 CMD | sort 형식으로 많이 사용한다.

    2. awk 명령어

        필드에 대한 선택적 출력

        ```bash
        # df | sort -n -k 3 -r | head -1 | awk '{print $5" "$6}'
        ```

- **VI 편집기**

    # 텍스트 편집기

    1. 리눅스의 기본적인 텍스트 편집기 (기본 설치되어 제공되는 프로그램)
    2. gedit

        GUI 상황에서 사용 가능한 텍스트 편집기

    3. VI (visual editor)
        - 유닉스 계열에서 많이 사용되는 편집기. 빌조이가 직접 개발하였다.
        - CLI 상황에서 사용 가능한 텍스트 편집기
        - 편집을 실행하면 메모리에 적재되고 이를 프로세스를 통해 디스플레이에 나타난다.

            ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/72ede520-576a-425f-bc76-8d0528b4a180/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/72ede520-576a-425f-bc76-8d0528b4a180/Untitled.png)

        - 작업을 버퍼에서 하기 때문에 저장하기 전까지 디스크 상의 파일의 내용이 저장되는 것이 아니다.
    4. VIM

        향상된 VI

        연습하기

        ```bash
        # vimtutor
        ```

    # VI 작성

    1. 기본 형식

        ```bash
        # vi file1name
        ```

        옵션

        ```bash
        -R : Readonly로 파일 열기.
        -r : 이전 편집 작업 중 비정상적으로 작업이 끝난 경우 편집하던 파일 복구시에 사용된다.
        -L : 이전 편집 작업 중 비정상적으로 작업이 끝난 경우 복구할 파일들에 대한 전체적인 목록을 볼 수 있다.
        ```

        ```bash
        # vi < vi 실행
        esc
        :q!  < 빠져나가기 
        ```

    2. 입력모드

        명령모드에서 입력모드로 전환, 텍스트를 입력하여 컨텐츠를 생산

        ```bash
        - 방향키
        	h, j, k, l 
        - 삭제
        	x(커서에 있는 문자 한개 삭제), dd(라인 삭제), wd(단어단위 삭제)
        	앞에 숫자 붙일 시 그 숫자만큼 삭제됨
        - 실행 취소
        	u
        - 다시 실행
        	ctrl + r
        - 입력
        	i(현재 커서가 있는 문자를 기준으로 앞에서 부터 입력됨), a(현재 커서 다음부터 입력됨), 
        	I(현재 라인 제일 앞), A(현재 라인 제일 뒤)
        	O(현재 라인 아래부터 적기)
        - 주석 처리
        	#
        - 복사 붙여넣기
        	yy   p
        ```

    3. 명령모드

        VI 실행 후 첫 단계이다.

        키보드 입력이 특정 기능키로 동작한다.

        ```bash
        - 라인 이동
        	:7
        - 제일 마지막 라인 가기
        	shift + g > O
        - 검색
        	/pattern
        - 다음/이전 검색
        	n/shift + n
        - 치환
        	%s/찾을문자열/바꿀문자열/g
        	r(현재 문자를 치환), R(현재 위치부터 insert 기능)
        ```

    4. 최하위행 모드

        파일에 대한 제어

        저장, 나가기, 다른 파일로 저장, 치환

        vi 내에서 쉘 명령어 입력

        ```bash
        - 저장
        	:w , :w! 강제
        - 빠져나가기
        	:q , :q! 강제
        - 저장 후 빠져나가기
        	:wq, :wq! 강제
        - 완전히 빠져나가지 않고 cmd 실행
        	:!cmd
        - 탭 간격 조정
        	:set tapstop=2
        ```

- **통신**

    # mail 명령어

    1. 전자 우편을 사용하기 위한 명령어

        ```bash
        # mail
        설치
        ```

    2. 명령어 형식

        ```bash
        # mail                           /* 메일 확인 */
        # mail user01                    /* 특정 사용자로 메일 보내기 */
        # mail -u user01                 /* 특정 사용자의 mail 확인, 관리자만 사용 가능 */
        # mail -s "Test Mail" user01     /* 제목을 명령어 입력시 포함하여 mail 보내기 */
        ```

    3. 메일 테스트 전 작업

        ```bash
        # vi /etc/hosts
        [수정전]
        127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
        ::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
        [수정후]
        127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
        ::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
        192.168.10.200  server1.example.com     server1
        192.168.10.252  server2.example.com     server2
        # vi /etc/resolv.conf
        search example.com
        nameserver 168.126.63.1
        **# dnf -y install postfix mailx
        # systemctl restart postfix
        # systemctl status postfix**
        ```

    4. 외부 메일 발송

        ```bash
        # mail -s "test mail(EX: linuxXXX)" XXXXXX@gmail.com < /etc/hosts 
        ```

    # wall 명령어

    접속중인 모든 사용자에게 메시지를 전송할 때 사용한다.

    1. 형식

        ```bash
        # wall "test messages"
        ```

- **검색**

    file위주의 검색기능. 검색조차 명령어로 한다.

    # grep 명령어

    (global regular expression print)

    파일의 컨텐츠를 대상으로 검색하는 경우

    하나 이상의 패턴과 일치하는 행을 선택하여 주어진 파일 [및 디렉토리]를 탐색한다.

    1. 형식

        ```bash
        고정된 파일에서 많이 사용 가능
        # grep OPTIONS PATTERN ARG1 [file path]
        실시간 자료, 명령어로 출력 결과를 봐야하는 상태인 경우 사용하는 명령어 검색 형식
        # CMD | grep OPTIONS PATTERN
        ```

    2. 옵션

        ```bash
        -l : list files, 여러 파일 중 검색 문자열 존재 파일 출력 
        -n : number line, 파일에서 root 문자열을 검색하고 라인 번호도 같이 출력 # cat -n /etc/passwd | grep root
        -v : inverse, 파일에서 검색 문자열을 제외하고 나머지 출력 
        -i : ignore case, 파일에서 검색 문자열의 대소문자를 구분하지 않음 
        -w : word , 단어의 일부분이 아닌 단어의 전체가 일치하는 경우 출력 
        -E : egrep과 똑같이 작동한다. 한번에 여러 개의 패턴을 검색하는 경우 사용한다.
        # grep -E 'http|telnet|ssh' file1
        # egrep "fedora|root" /etc/passwd
        ```

    3. 패턴 사용법

        ```bash
        *       # grep 'ro*t' /etc/passwd       모든문자를 포함(영문자,숫자) 한 자 이상 
        .       # grep 'no...y' /etc/passwd     (.에 하나의 영문자나 숫자를 치환)
        ^root   # grep '^root' /etc/passwd      라인의 시작이 root인 라인을 검색
        root$   # grep 'root$' /etc/group       라인의 끝이 root로 끝나는 라인을 검색
        [abc]   # grep 'user0[123]' /etc/passwd user0으로 시작하여 1이나 2나,3으로 끝나는 문자열
        ```

    4. fgrep

        앵커 등 특수문자를 포함하여 검색한다. 특수문자를 같이 사용해서 패턴으로 인식해야 하는 경우에 사용되는 grep

        ```bash
        # fgrep ^ssh file1
        > ssh로 시작하는 라인을 찾는 것이 아니라 ^ssh 그대로 문자열을 찾는다.
        ```

    # find 명령어

    indoe의 정보를 바탕으로 검색을 하는 명령어이다.

    파일명, 각각의 속성을 대상으로 검색하는 경우 사용한다.

    1. 형식

        ```bash
        # find [검색시작위치] [옵션1] [인자값1] [옵션2] [인자값2] ...
        # find /Log_dir2 -name "*.log" -type f -mtime +60 -exec rm –f {} \;
        ```

    2. 옵션

        ```bash
        -name : 파일 이름을 기준으로 검색
        -iname: 대소문자를 구별하지 않고 파일 이름을 기준으로 검색 ex) -iname hello
        -perm : 파일 권한을 기준으로 검색한다. ex) -perm 400
        	n : 퍼미션이 n인 파일 검색
        	-n : 퍼미션이 n 이상인 파일 검색
        	# find / -perm -4000  2> /dev/null
        -type : 파일의 종류를 기준으로 검색
        	b : 블록 파일
        	c : 문자
        	d : 디렉토리
        	f : 파일
        	l : 링크
        	s : 소켓
        -size : 파일의 크기를 기준으로 검색
        	+n : n보다 크다
        	-n : n보다 작다
        	n : n이다
        	b : 512-byte
        	c : Bytes (Character = Byte)
        	k : Kilo Byte
        	M : Mega Bytes
        	G : Giga Bytes
        	w : 2-byte
        	# find . -size -2490c –type f
        -links : 링크의 개수를 기준으로 검색
        -user : 사용자 ID를 기준으로 검색
        -group : 그룹 ID를 기준으로 검색
        -atime : 특정 기간 이상 접근하지 않은 파일을 기준으로 검색
        -mtime : 특정 기간 이상 수정되지 않은 파일을 기준으로 검색
        	+n : 수정한 날짜가 n일이 지난 파일
        	-n : 수정한 날짜가 n일 전인 파일
        	n : 수정한 날짜가 n일 전인 파일
        -inum : number 지정된 inode 번호와 파일을 찾는다.
        -print : 표준출력으로 검색된 파일 출력: GNU는 디펄트, Unix는 필수 입력
        -exec command {} \; :찾은 각 파일에 대해 지정된 명령을 실행
        -ok command {} \; : 실행여부(실행 되어 있는지 아닌지)를 사용자에게 확인 후 명령을 실행
        ```

    3. OR

        ```bash
        And 가 아닌 OR 연산이 필요한 경우
        # find /var -type f -or -type d | wc -l
        ```

    4. 패턴 사용법

        ```bash
        *       # grep 'ro*t' /etc/passwd       모든문자를 포함(영문자,숫자) 한 자 이상 
        .       # grep 'no...y' /etc/passwd     (.에 하나의 영문자나 숫자를 치환)
        ^root   # grep '^root' /etc/passwd      라인의 시작이 root인 라인을 검색
        root$   # grep 'root$' /etc/group       라인의 끝이 root로 끝나는 라인을 검색
        [abc]   # grep 'user0[123]' /etc/passwd user0으로 시작하여 1이나 2나,3으로 끝나는 문자열
        ```

    5. exec 옵션

        ```bash
        find로 검색된 파일, 디렉토리에 대하여 한번에 무언가 작업을 이루기 위해서 사용한다.
        기본 형식
        # find [path] [option] -exec [CMD] {} \;

        cpetc 디렉토리에서 링크 파일만 찾아 삭제
        #find . -type l -exec rm -f {} \;
        cpetc 디렉토리에서 파일만 찾아 /test/dir1으로 이동
        # find . -type f -exec mv -vf {} /test/dir1 \;
        ```

        ```bash
        find 명령어에서 -exec 옵션에서 세미콜론(;)의 역할
        find 명령어를 사용하면서 출력된 결과를 가지고 바로 후처리 실행으로 이어질수 있는 옵션인 exec ok가 존재한다. 해당 문법의마지막에는 세미콜론(;)이 입력된다. 하지만 쉘에서는 세미콜론(;)을 기준으로 앞 명령어와 뒤 명령어를 구분하는 구분자로 사용하기 때문에 그냥 사용할수는 없으며 바로 앞에 역슬래시를 붙여 \; 구조로 만들어줘야 find 명령어에서 정상적으로 해석가능하다.
        {} -> find된 결과 값들
        ```

- **기타** 팁

    # 문자열 형식

    1. plain text

        그래픽, 오브젝트에 대한 표현이 아니라 읽을 수 있는 자료의 문자열.

        String, text, ...

    # null

    1. /dev/null

        ```bash
        > /dev/null
        /dev/null로 들어간 것은 모두 소멸한다.
        ```

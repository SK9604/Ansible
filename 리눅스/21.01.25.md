# 단원목표

---

- HTTP 개요
- 웹서버 개요
- 간단한 웹서버 구축
- 아파치 웹서버
- 웹보안
- http.conf 파일 해석
- http status code

---

## HTTP(Hypertext Transfer Protocol) 개요

■ HTTP (Hypertext Transfer Protocol) ; 하이퍼텍스트 전송 규약

**-> http://www.daum.net:80 (port 80)**

HTTP는 웹 상에서 파일(텍스트, 그래픽 이미지, 사운드, 비디오 그리고 기타 멀티미디어 파일)을 주고받는데 필요한 프로토콜로서 TCP/IP와 관련된 하나의 응용 프로토콜이다.

HTTP의 한 부분을 이루는 중요한 개념들은 - 그 이름에도 내포되어 있듯이 - 모든 파일들이 다른 파일들에 대한 참조 링크를 가질 수 있다는 것이며, 그 링크를 선택하면, 또다른 내용이 추가적으로 전달되는 식의 아이디어로 되어 있다. 웹 서버는 모두 HTTP 데몬을 가지고 있는데, 이 프로그램은 HTTP 요청을 기다리고 있다가 요청이 들어오면 그것을 처리하도록 설계되어 있다. HTTP의 입장에서의 웹 브라우저는 서버에 요구를 전달하는 하나의 클라이언트이다. 사용자가 URL을 입력하거나, 하이퍼텍스트 링크를 클릭 함으로써 파일을 요구하면, 브라우저는 HTTP 요구를 URL에 적혀있는 IP 주소에 전달한다. 지정된 서버상의 HTTP 데몬은 그 요구를 받아서, 필요한 작업이 혹 있다면 처리를 한 뒤에 요구된 파일을 찾아서 보내준다.

- HTTP 프로토콜은 WWW(World Wide Web)에서 사용되는 프로토콜이다.
- HTTP 프로토콜은 간단(Simple)한 비상태기반 프로토콜(Stateless Protocol)이다.
- 클라이언트 측면 요청(Client-Side Request)와 서버측면 응답(Server-Side Response)으로 구성된다.
- 요청과 응답은 3가지 부분으로 구성이 된다.
① 요청 코드(Request Method)/응답 코드(Response Code)
② 헤더(Header)
③ 바디(Body)

■ HTTPS (Secure Hypertext Transfer Protocol)

**-> https://www.daum.net:443 (port 443)**

HTTPS는 넷스케이프에 의해 개발되고 그들의 브라우저에 구현된 웹 프로토콜로서, 사용자의 페이지 요청들과 웹서버에 의해 반환되는 페이지들을 암호화하고 해석한다. HTTPS는 실제로 넷스케이프의 SSL을 정규 HTTP 응용계층 하에서 서브 계층으로서 사용한다 (HTTP가 하부계층인 TCP/IP와의 상호작용을 위해 80번 포트를 사용하는데 비해, HTTPS는 443번 포트를 사용한다). SSL은 RC4 스트림 암호화 알고리즘을 위해 40 비트 크기의 키를 사용하는데, 이는 상업적 데이터의 교환을 위한 암호화 정도에 적합하다고 간주된다.

NetPlaza (http://www.netplaza.com)와 같은 웹사이트에 방문해서 그들의 카탈로그를 보기 위해 넷스케이프 브라우저를 사용한다고 가정하라. 주문할 준비가 되었을 때, 사용자는 URL이 https://로 시작되는 웹페이지 주문서를 받게 될 것이다. 사용자가 그 페이지를 판매자에게 보내기 위하여 "보내기" 단추를 클릭하면, 브라우저의 HTTPS 계층이 그 페이지를 암호화한다. 서버가 받았음을 알리는 회신내용 역시 암호화된 형식으로 도착되지만, 그 내용은 브라우저의 HTTPS 서브 계층에 의해 해석된다.

HTTPS와 SSL은 서버로부터의 X.509 디지털 인증서 사용을 지원하므로, 필요한 경우 사용자는 발신자를 믿을 수 있음을 증명할 수 있다. SSL은 넷스케이프가 W3C에 표준으로 제안한 개방형이며, 비독점적 프로토콜이다. HTTPS를 EIT가 개발하고 표준으로 제안한 HTTP의 보안 강화판인 SHTTP와 혼동하면 안된다.

■ S-HTTP (Secure HTTP)

S-HTTP는 월드와이드웹 상의 파일들이 안전하게 교환될 수 있게 해주는 HTTP의 확장판이다. 각 S-HTTP 파일은 암호화되며, 전자서명을 포함한다. S-HTTP는 잘 알려진 또다른 보안 프로토콜인 SSL의 대안이다. 두 가지의 주요 차이점은, S-HTTP는 틀림없는 사용자라는 것을 입증하기 위한 인증서를 클라이언트에서 보낼 수 있는 반면에, SSL에서는 오직 서버만이 인증할 수 있다는 점이다. S-HTTP는 은행을 대리해 서버가 있는 곳, 또는 사용자ID와 패스워드를 사용하는 것보다 좀더 안전한 사용자로부터 인증이 필요한 상황에서 보다 많이 사용될 것 같다.

S-HTTP는 어떠한 단일 암호화 시스템을 사용하지 않지만, RSA 공개키/개인키 암호화 시스템은 지원한다. SSL은 TCP 계층보다 더 상위의 프로그램 계층에서 동작한다. S-HTTP는 HTTP 응용의 상위 계층에서 동작한다. 두 개의 보안 프로토콜들 모두가 한 사용자에 의해 사용될 수 있지만, 주어진 문서에 대해서는 오직 그중 하나만이 사용될 수 있다. Terisa Systems은 인터넷 보안도구 내에 SSL과 S-HTTP 모두를 포함한다.

AOL, 컴퓨서브, IBM, 넷스케이프, Prodigy, 그리고 Spyglass 등이 S-HTTP를 지원한다. 새로 나오는 브라우저들은 SSL과 S-HTTP를 모두 지원한다. S-HTTP는 IETF에 표준안으로 상정되었다. RFC 2660에 S-HTTP에 대해 자세한 설명이 나와있다.

S-HTTP에 관해 설명하고 있는 IETF의 RFC 2660 초안입니다. (http://www.ietf.org/rfc/rfc2660.txt)

## 웹 서버(Web Server) 개요

(1) 웹서버(Web Server)란?

웹 브라우저를 이용하여 World Wide Web을 사용하는 클라이언트에게 미리 저장된 하이퍼 텍스트를 제공하는 서버를 지칭한다.

```bash
(웹브라우저) <--------------> (웹서버)
Internet explore	Apache(httpd)
Firefox	IIS
Mozilla	.....
Crome
```

(2) 웹서버(Web Server)의 종류

```bash
종류                           설명
NCSA Server                   아파치 서버의 모태.(NCSA httpd 1.3.X)
CERN Server                   스위스에 있는 유럽 핵물리 연구기관으로 World Wide Web 프로젝트가 시작된곳.
Apache Server                 NCSA서버의 개량형, 성능과 기능면에서 우수. 하나의 port(default:80)에서 일반 Web과 Proxy 동시 지원 각 기능의 MoDule화 가장 많이 사용되는 Web Server이다.
Apache-SSL Server             아파치 서버의 보안성을 높혔다. 무료로사용, 128bit 엔크립션사용(암호화)
Netscape Enterprise Server    상업용 서버 인데, 현재 거의 사용 하지 않는다.
IIS                           Internet Information Server, window NT Server용. HTTP(Hypertext Transfer Protocol) 바이트 범위 지원.SQL데이터를 HTML 형식으로 변환. CGI 응용프로그램이 모든 환수 변수를 받음. HTML 페이지와 기타 문서의 내용에 색인 붙이기. SSL 키를 만들기 위한 그래픽 도구
AOL Server                   다양한 플랫폼을 지원.
```

(3) 고성능의 웹서버가 개발되기 위한 요건

```bash
요건                       설명
동시처리(Concurrency)                   서버는 동시에 여러개의 클라이언트 요청을 수행해야만 한다.
효율성(Efficiency)                     서버는 지연(latency)을 최소화해야하고, 대역폭을 최대로 활용해야 하며, 불필요하게 CPU(들)을 동작시키는 것을 피해야 한다.
프로그래밍 단순화(Programming simplicity) 서버의 디자인은 효율적인 동시처리에 대한 운영 전략의 적용을 단순화할 수 있어야 한다.
적응성(Adaptability)                   신규 혹은 개선된 트랜스포트 프로토콜(HTTP 1.1과 같은)을 지원하는데 있어서 최소한의 관리 비용이 들도록 해야한다.
```

(4) 웹서버의 구조

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3972e689-55c9-4970-885e-9e5888962c9a/_2020-03-24__12.32.37.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3972e689-55c9-4970-885e-9e5888962c9a/_2020-03-24__12.32.37.png)

```bash
① Client는 웹브라우저를 통해 HTTP 요청 
② 웹서버는 요청에 대한 내용을 분석
③ 요청된 내용에 맞는 컨텐츠를 찾는다.
④ Client에게 파일을 보낸다.
```

(4-1) 동기(멀티스레드) 웹서버 구조

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3dd27d7c-caa3-43c0-aeae-47e56f40e621/_2020-03-24__12.33.02.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3dd27d7c-caa3-43c0-aeae-47e56f40e621/_2020-03-24__12.33.02.png)

```bash
① 각 쓰레드는 accept()함수실행시 클라이언트 접속요청이 올때까지 동기적으로 블록당한다.
② 클라이언트가 서버에 연결되면, 접속이 accept된다. (블럭이 풀린다)
③ 새로 접속된 클라이언트의 HTTP 요청이 동기적으로 네트워크 연결을 통하여 읽혀진다.
④ 요청에 대한 것을 분석한다.
⑤ 요청된 파일을 동기적으로 읽는다.
⑥ 파일의 내용이 동기적으로 클라이언트에게 전송된다.
```

(4-2) 비동기 웹서버 구조

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f6eedf19-d977-427d-a26c-b3e9a393ecaa/_2020-03-24__12.33.25.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f6eedf19-d977-427d-a26c-b3e9a393ecaa/_2020-03-24__12.33.25.png)

```bash
① 웹서버는 acceptor에게 비동기 accept 처리를 초기화하도록 알려준다.
② acceptor는 운영체계의 기능을 이용하여 비동기 accept 요청을 초기화하고, 그 자신을 완료 핸들러(Completion 
   Handler)와 완료 발송자(Completion Dispatcher)의 참조로써 넘기게 된다. (이것은 비동기 accept의 완료여부
   를 acceptor에게 알려주는데 사용된다.)
③ 웹서버는 완료 발송자의 이벤트 루프를 실행한다.
④ 클라이언트가 웹서버에 접속한다.
⑤ 비동기 accept 명령이 완료하면, 운영체계는 완료 발송자에게 통지한다.
⑥ 완료 발송자는 acceptor에게 통지한다.
⑦ acceptor는 HTTP 핸들러를 생성한다.
⑧ HTTP 핸들러는 클라이언트로 부터 전송되는 요청 데이터를 비동기적으로 읽는 작업을 초기화하고 그 자신을 완
   료 핸들러(Completion Handler)와 완료 발송자(Completion Dispatcher)의 참조로써 넘기게 된다. (이것은 비동
   기 읽기작업의 완료여부를 acceptor에게 알려주는데 사용된다.)
```

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/443d7391-9a62-4ee4-b62e-4151c385e0bf/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/443d7391-9a62-4ee4-b62e-4151c385e0bf/Untitled.png)

[참고] 쓰레드(thread)

```bash
쓰레드(thread)는 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 말한다. 일반적으로 한 프로그램은 하나의 스레드를 가지고 있지만, 프로그램 환경에 따라 둘 이상의 스레드를 동시에 실행할 수 있다. 이러한 실행 방식을 멀티스레드(multithread)라고 한다.

사용자 쓰레드
사용자 스레드는 커널 영역의 상위에서 지원되며 일반적으로 사용자 레벨의 라이브러리를 통해 구현되며, 라이브러리는 스레드의 생성 및 스케줄링 등에 관한 관리 기능을 제공한다. 동일한 메모리 영역에서 스레드가 생성 및 관리되므로 속도가 빠른 장점이 있는 반면, 여러 개의 사용자 스레드 중 하나의 스레드가 시스템 호출 등으로 중단되면 나머지 모든 스레드 역시 중단되는 단점이 있다. 이는 커널이 프로세스 내부의 스레드를 인식하지 못하며 해당 프로세스를 대기 상태로 전환시키기 때문이다.

커널 쓰레드
커널 스레드는 운영체제가 지원하는 스레드 기능으로 구현되며, 커널이 스레드의 생성 및 스케줄링 등을 관리한다. 스레드가 시스템 호출 등으로 중단되더라도, 커널은 프로세스 내의 다른 스레드를 중단시키지 않고 계속 실행시켜준다. 다중처리기 환경에서 커널은 여러 개의 스레드를 각각 다른 처리기에 할당할 수 있다. 다만, 사용자 스레드에 비해 생성 및 관리하는 것이 느리다.
```

## 간단한 웹서버 (Apache Web Server) 구성

아파치는 "open source" 라이선스에 따라 배포되어 마음대로 쓸 수 있는 웹서버이다. 버전 1.3은 리눅스, Solaris, Digital UNIX, AIX와 같은 대부분의 유닉스 기반 운영체계, Rhapsody, BeOS, BS2000/OSD 등과 같이 유닉스/포직스에서 파생된 시스템들, 그리고 AmigaOS 및 윈도우NT/95/98 등에서 실행된다. Netcraft에서 1998년 9월에 실시한 웹서버 실태조사에 따르면, 전세계 인터넷 서버의 50% 이상이 아파치에서 운영되고 있다고 한다. 마이크로소프트에서 나온 윈도우기반의 웹서버, 넷스케이프, 그리고 다른 회사들이 수 적인 면에서 보면 늘어가고 있지만, 아파치는 아마도 유닉스 기반의 시스템이 널리 퍼져 있는 기업이나 대학에서 대중적 인기를 계속 유지할 것으로 보인다.

아파치의 Market share에 대한 부분은 **http://www.netcraft.com/survey** 사이트를 참고한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/84747ca2-6b20-489a-9749-3078e3b8b9ae/_2020-03-27__3.44.50.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/84747ca2-6b20-489a-9749-3078e3b8b9ae/_2020-03-27__3.44.50.png)

아파치는 HTTP의 최신판인 버전 1.1을 따른다. 몇몇 유즈넷 뉴스그룹과 버그 보고시스템을 통한 무료지원이 제공된다. 몇몇 회사들은 비용을 받고 지원해주기도 한다.

- **아피치(Apache) 공식 홈페이지 :** **http://www.apache.org**
- 1995년까지 대부분의 많이 사용하는 웹서는 NCSA httpd 1.3 프로그램을 사용했다.
- NCSA httpd 프로그램에서 아파치(**A** **PA**t**CH**y s**E**rver) 웹서버가 나왔다.
- 현재는 일반적인 웹서버로 광범위하게 사용중이다.(전 세계의 웹서버의 60% 이상)

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7e2d2de7-ebc9-467c-88bc-92d2d1e1a78a/_2020-03-27__3.45.25.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7e2d2de7-ebc9-467c-88bc-92d2d1e1a78a/_2020-03-27__3.45.25.png)

### (1) 간단한 웹서버 구성

INDEX

**------------------------------**

1. 실습준비

2. 관리자를 위한 웹기본 설정

3. 사용자를 위한 웹기본 설정

**------------------------------**

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0ac1a5a9-df56-493f-92f7-dd91c5181db0/_2020-03-27__3.45.58.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0ac1a5a9-df56-493f-92f7-dd91c5181db0/_2020-03-27__3.45.58.png)

### (1-1) 실습준비

```bash
----- DNS Server ---------- WEB Server -----
    (192.168.10.200)      (192.168.10.210)

--------------------------------------------

[그림] 실습 구조(Master/Slave DNS Server)
```

```bash
(DNS 서버쪽) 192.168.10.200 
- /etc/resolv.conf 파일 설정
- Master DNS 서버만 구축
  -> 웹서버 등록

(WEB 서버쪽) 192.168.10.210
- /etc/resolv.conf 파일 설정
- (Optional) /etc/hosts 파일설정
```

> DNS 서버 확인

> /etc/resolv.conf 파일 설정

**[SERVER1]# cat /etc/resolv.conf**

```
# Generated by NetworkManager
search example.com
nameserver 192.168.10.200
nameserver 8.8.8.8
```

**[SERVER1]# cd /var/named/**

**[SERVER1]# cat server.zone**

```
$TTL          4                                                        
@             IN         SOA      ns1.example.com.  root.example.com.  (
0             ;          serial                                        
1D            ;          refresh                                       
1H            ;          retry                                         
1W            ;          expire                                        
3H            )          ;        minimum                              
NS            @                                                        
A             127.0.0.1                                                
AAAA          ::1                                                      
IN            NS         ns1                                           
ns1           IN         A        192.168.10.200                       
www           IN         A        192.168.10.210                       
nfs           IN         A        192.168.10.220                       
ftp           IN         A        192.168.10.220                       
example.com.  IN         MX       10                mail.example.com.  
mail          IN         A        192.168.10.220                       
iscsi         IN         A        192.168.10.220
```

**[SERVER1]# nslookup [www.example.com](http://www.example.com/)**

```
Server:		192.168.10.200
Address:	192.168.10.200#53

Name:	www.example.com
Address: 192.168.10.210
```

(웹 서버쪽) 192.168.10.210

**[SERVER2]# cat /etc/resolv.conf**

```
# Generated by NetworkManager
search example.com
nameserver 192.168.10.200
```

DNS 서버쪽을 지정했기 때문에 DNS 서버쪽에서 도메인을 등록한 경우 정상적으로 동작할 것이다.
만약 DNS 서버가 없는 환경이라면 /etc/hosts 파일을 사용하면 된다.

> 관리자를 위한 웹 기본 설정

```bash
패키지: httpd
------ Web Server ------------ Web Client ------

httpd(80)
- /etc/httpd/conf/httpd.conf            <----  메인 설정 파일
- /var/www/html/index.html              <----  http://www.example.com/
- /home/<사용자>/public_html/index.html   <----  http://www.example.com/~user01/
```

> 패키지 확인

**[SERVER2]# dnf -y install httpd**

**[SERVER2]# rpm -qa | grep httpd**

```
centos-logos-httpd-80.5-2.el8.noarch
httpd-filesystem-2.4.37-21.module_el8.2.0+382+15b0afa8.noarch
**httpd-2.4.37-21.module_el8.2.0+382+15b0afa8.x86_64**
httpd-tools-2.4.37-21.module_el8.2.0+382+15b0afa8.x86_64
```

**[SERVER2]# rpm -ql httpd**

> 데몬 확인 및 포트 확인

**[SERVER2]# httpd -v**

```
Server version: Apache/2.4.37 (centos)
Server built:   Jun  8 2020 20:14:33
```

**[SERVER2]# cat /etc/services | grep ^http**

```
http            80/tcp          www www-http    # WorldWideWeb HTTP
http            80/udp          www www-http    # HyperText Transfer Protocol
http            80/sctp                         # HyperText Transfer Protocol
https           443/tcp                         # http protocol over TLS/SSL
https           443/udp                         # http protocol over TLS/SSL
https           443/sctp                        # http protocol over TLS/SSL
http-mgmt       280/tcp                 # http-mgmt
http-mgmt       280/udp                 # http-mgmt
http-rpc-epmap  593/tcp                 # HTTP RPC Ep Map
http-rpc-epmap  593/udp                 # HTTP RPC Ep Map
httpx           4180/tcp                # HTTPX
httpx           4180/udp                # HTTPX
http-wmap       8990/tcp                # webmail HTTP service
http-wmap       8990/udp                # webmail HTTP service
https-wmap      8991/tcp                # webmail HTTPS service
https-wmap      8991/udp                # webmail HTTPS service
```

> 주 설정 파일 확인

**[SERVER2]# cd /etc/httpd/conf**

**[SERVER2]# ls -l**

```
합계 28
-rw-r--r--. 1 root root 11899  6월  9 05:12 httpd.conf
-rw-r--r--. 1 root root 13064  6월  9 05:15 magic
```

> index.html 파일 생성 및 확인

**[SERVER2]# cd /var/www/html**

**[SERVER2]# ls**

```

```

초기 설치시에는 아무런 파일이 없다. 

**[SERVER2]# echo "SERVER2 TEST web" > /var/www/html/index.html**

**[SERVER2]# ls -l**

```
합계 4
-rw-r--r--. 1 root root 17  8월  3 06:27 index.html
```

**[SERVER2]# systemctl start httpd**

**[SERVER2]# systemctl status httpd**

**[SERVER2]# systemctl enable httpd**

> 웹서비스 확인

■ 웹서비스를 확인하는 여러가지 방법

- GUI 웹브라우저를 사용하는 방법(EX: firefox)
- TUI 웹브라우저를 사용하는 방법(EX: lynx/curl)
- telnet 명령어를 사용하는 방법(EX: telnet <서버 IP> 80)
- netstat 명령어를 사용하는 방법(EX: netstat -an | :80)

■ GUI 웹브라우저를 사용하는 방법

```
# firefox http://www.example.com &
```

**[SERVER2]# curl [www.example.com](http://www.example.com/)**

```
SERVER2 TEST web
```

> lynx [TUI 웹 브라우저 설치]

**[SERVER2]# dnf -y install dnf-plugins-core**

**[SERVER2]# dnf -y install [https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm](https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm)**

**[SERVER2]# dnf config-manager --set-enabled PowerTools**

**[SERVER2]# dnf repolist**

**[SERVER2]# dnf -y install lynx**

**[SERVER2]# lynx [www.example.com](http://www.example.com/)**

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6b640abc-d497-4ca2-869b-7f672b80f3b7/_2020-08-02__10.19.20.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6b640abc-d497-4ca2-869b-7f672b80f3b7/_2020-08-02__10.19.20.png)

**[SERVER2]# lynx -head [http://www.example.com](http://www.example.com/)**

```
HTTP/1.1 200 OK
Date: Sun, 02 Aug 2020 21:42:58 GMT
Server: Apache/2.4.37 (centos)
Last-Modified: Sun, 02 Aug 2020 21:27:16 GMT
ETag: "11-5abebafb1f691"
Accept-Ranges: bytes
Content-Length: 17
Connection: close
Content-Type: text/html; charset=UTF-8

q                                       <----- 'q' 입력
Are you sure you want to quit? (y) y    <----- 'y' 입력
```

**[SERVER1]# dnf -y install dnf-plugins-core ; dnf -y install [https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm](https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm) ; dnf config-manager --set-enabled PowerTools ; dnf repolist ; dnf -y install lynx**

**[SERVER1]# dnf -y install lynx**

> 서버 외부에서 접속하기

**[SERVER1]# nslookup [www.example.com](http://www.example.com/)**

```
Server:		192.168.10.200
Address:	192.168.10.200#53

Name:	www.example.com
Address: 192.168.10.210
```

**[SERVER1]# lynx [www.example.com](http://www.example.com/)**

```
Looking up www.example.com first
Looking up www.example.com
Making HTTP connection to www.example.com
Alert!: Unable to connect to remote host.

lynx: Can't access startfile http://www.example.com/
```

**[SERVER2]# firewall-cmd --list-services**

```
 cockpit dhcpv6-client ssh
```

**[SERVER2]# firewall-cmd --permanent --add-service=http**

**[SERVER2]# firewall-cmd --reload**

**[SERVER1]# lynx [www.example.com](http://www.example.com/)**

■ telnet 명령어를 사용하는 방법

[SERVER1]# dnf -y install telnet

[SERVER1]# telnet [www.example.com](http://www.example.com/) 80

```
Trying 192.168.10.210...
Connected to www.example.com.
Escape character is '^]'.
GET  << 입력

HTTP/1.1 400 Bad Request
Date: Sun, 02 Aug 2020 21:49:18 GMT
Server: Apache/2.4.37 (centos)
Content-Length: 226
Connection: close
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>400 Bad Request</title>
</head><body>
<h1>Bad Request</h1>
<p>Your browser sent a request that this server could not understand.<br />
</p>
</body></html>
Connection closed by foreign host.
```

■ netstat 명령어를 사용하는 방법

**[SERVER2]# netstat -antp**      (-a: all, -n: numeric, -t: tcp, -u: udp, -p: program)

```
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:5355            0.0.0.0:*               LISTEN      993/systemd-resolve 
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      857/sshd            
tcp        0      0 192.168.10.210:22       192.168.10.1:54741      ESTABLISHED 22352/sshd: root [p 
tcp6       0      0 :::5355                 :::*                    LISTEN      993/systemd-resolve 
tcp6       0      0 :::80                   :::*                    LISTEN      22992/httpd         
tcp6       0      0 :::22                   :::*                    LISTEN      857/sshd            
tcp6       0      0 192.168.10.210:80       192.168.10.200:55548    TIME_WAIT   -
```

[참고] netstat -an 명령어의 사용법에 대해서

```bash
# netstat -an      /* 모든 서비스: TCP + UDP + 소켓 */
# netstat -ant     /* TCP 서비스만 */
# netstat -anu     /* UDP 서비스만 */

# netstat -anp     /* 모든 서비스: TCP + UDP + 소켓, 프로그램이름/PID 표시 */
# netstat -antp /* TCP 서비스만, 프로그램 이름/PID 표시 */
# netstat -anup    /* UDP 서비스만, 프로그램 이름/PID 표시 */
```

> 사용자를 위한 웹 기본 설정

[전제조건] user01,user02,fedora 사용자가 존재해야 한다.

**[SERVER2]# useradd user01**

**[SERVER2]# useradd user02**

**[SERVER2]# passwd user01**

**[SERVER2]# passwd user02**

**[SERVER2]# tail -2 /etc/passwd**

```
user01:x:1001:1001::/home/user01:/bin/bash
user02:x:1002:1002::/home/user02:/bin/bash
```

> user01 사용자 홈디렉토리에 public_html 디렉토리와 index.html 파일 생성

**[SERVER2]# su - user01**

**[user01@server2 ~]$ mkdir public_html**

**[user01@server2 ~]$ cd public_html**

**[user01@server2 public_html]$ vi index.html**

```
Web Server(SERVER2 : user01)
```

> 사용자 홈디렉토리 퍼미션 변경

**[user01@server2 public_html]$ cd**

**[user01@server2 ~]$ ls -ld .**

```
drwx------. 3 user01 user01 97 Aug  3 07:10 .
```

**[user01@server2 ~]$ chmod 755 /home/user01**

**[user01@server2 ~]$ ls -ld .**

```
drwxr-xr-x. 3 user01 user01 97 Aug  3 07:10 .
```

**[user01@server2 ~]$ exit**

> /etc/httpd/conf/httpd.conf 파일 수정 및 적용

**[SERVER2]# vi /etc/httpd/conf/httpd.conf**

```
/UserDir          <------ Last Line Mode에서 '/UserDir' 입력

E486: Pattern not found: UserDir
```

**[SERVER2]# cd /etc/httpd/conf.d**

**[SERVER2]# ls**

```
README  autoindex.conf  userdir.conf  welcome.conf
```

**[SERVER2]# vi /etc/httpd/conf.d/userdir.conf**

```
[수정전]
..... (중략) .....
<IfModule mod_userdir.c>
    #
    # UserDir is disabled by default since it can confirm the presence
    # of a username on the system (depending on home directory
    # permissions).
    #
    UserDir disable          

    #
    # To enable requests to /~user/ to serve the user's public_html
    # directory, remove the "UserDir disable" line above, and uncomment
    # the following line instead:
    #
    #UserDir public_html

</IfModule>
..... (중략) .....

[수정후]
..... (중략) .....
<IfModule mod_userdir.c>
    #
    # UserDir is disabled by default since it can confirm the presence
    # of a username on the system (depending on home directory
    # permissions).
    #
**#--->    UserDir disable           <----- '기존 라인 주석처리'**

    #
    # To enable requests to /~user/ to serve the user's public_html
    # directory, remove the "UserDir disable" line above, and uncomment
    # the following line instead:
    #
**#--->    #UserDir public_html      <----- '기존 라인 주석처리'
    UserDir public_html            <----- '새로운 라인 선언'**
```

**[SERVER2]# systemctl restart httpd**

만약 에러메세지가 발생한다면 무시하고 넘어가나. 또는 아래 내용을 참고하여 /etc/hosts 파일에 긴 이름의 호스트 이름을 등록하고 httpd 서비스를 재시작하면 된다.

[참고] httpd 서비스 start 시 에러메세지 제어

```
# systemctl restart httpd
httpd: Could not reliably determine the server's fully qualified domain name, using 127.0.0.1 for ServerName
# vi /etc/hosts 
192.168.10.210  server2.example.com  server2
# systemctl restart httpd
```

**[SERVER2]# lynx [www.example.com/~user01](http://www.example.com/~user01)**

[root@server2 public_html]# getsebool -a | grep httpd_enable_homedir

**[SERVER2]# setsebool -P httpd_enable_homedirs on**

**[SERVER2]# restorecon -R /home**

**[SERVER2]# lynx [www.example.com/~user01](http://www.example.com/~user01)**

(정리) 사용자 웹페이지

```bash
----- Web Client -----                      ----- Web Server -----
http://DAUM/~user01  ---------------------> httpd(80)
																						/home/<사용자>/public_html/index.html 
																						# cat /etc/httpd/conf.d/userdir.conf
																						UserDir public_html
```

(1-4) 사용자를 위한 웹 기본 설정2

```bash
(웹 요청 비교)
http://www.example.com/~user01/
http://www.example.com/user01/     (http://cafe.naver.com/testcafe)
```

사용자 웹 페이지 및 하위 웹페이지의 구성

> /etc/httpd/conf/httpd.conf 파일 설정

**[SERVER2]# vi /etc/httpd/conf/httpd.conf**

```
    #
    # Alias: Maps web paths into filesystem paths and is used to
    # access content that does not live under the DocumentRoot.
    # Example:
    # Alias /webpath /full/filesystem/path
    #
    # If you include a trailing / on /webpath then the server will
    # require it to be present in the URL.  You will also likely
    # need to provide a <Directory> section to allow access to
    # the filesystem path.
Alias /user01/ "/home/user01/public_html/"     <----- 새로운 라인 추가
```

**[SERVER2]# systemctl restart httpd**

**[SERVER2]# lynx [www.example.com/user01](http://www.example.com/user01)**

**[SERVER2]# lynx [www.example.com/user01/](http://www.example.com/user01/)**

**[SERVER2]# vi /etc/httpd/conf/httpd.conf**

```
    #
    # Alias: Maps web paths into filesystem paths and is used to
    # access content that does not live under the DocumentRoot.
    # Example:
    # Alias /webpath /full/filesystem/path
    #
    # If you include a trailing / on /webpath then the server will
    # require it to be present in the URL.  You will also likely
    # need to provide a <Directory> section to allow access to
    # the filesystem path.
Alias /user01/ "/home/user01/public_html/"     
Alias /user01  "/home/user01/public_html/"     <----- 새로운 라인 추가
```

**[SERVER2]# systemctl restart httpd**

**[SERVER2]# lynx [www.example.com/user01](http://www.example.com/user01)**

> Alias 비교

```bash
Alias /user01/ "/home/user01/public_html/"  http://www.example.com/user01/
Alias /user01 "/home/user01/public_html/"   http://www.example.com/user01   << 
```

```bash
(추가적인 실습)
# cat /etc/httpd/conf/httpd.conf
DocumentRoot "/var/www/html"

# mkdir –p /var/www/html/user100
# echo hello > /var/www/html/user100/index.html

# firefox http://www.example.com/user100/
```

# 아파치 웹서버(Apache Web Server)

## 아파치 웹서버에 관련한 파일/디렉토리

```bash
종 류                            설 명
/etc/httpd/conf/httpd.conf      아파치 웹서버 주 설정 파일
/etc/httpd/conf.d/*.conf        아파치 웹서버 주 설정 파일에 포함된 하위 설정 파일
/etc/httpd/logs                 /var/log/httpd/, 아파치 웹서버 로그 디렉토리
/etc/httpd/modules              /usr/lib/httpd/modules/, 아파치 웹서버 모듈 디렉토리
/etc/httpd/run/httpd.pid        /var/run/, 실행 중인 아파치 데몬의 PID 번호를 저장하는 파일
/etc/mime.types                 CUPS을 위한 MIME 타입 설명 파일
/etc/rc.d/init.d/httpd          아파치 데몬을 제어할 수 있는 스크립트
/usr/sbin/httpd                 아파치 웹데몬
/usr/sbin/htpasswd              특정 디렉토리를 제어할 때 사용하는 사용자 패스워드 입력 프로그램
/usr/sbin/apxs                  DSO(Dynamic Shared Object) 기반 아파치 모듈을 컴파일할 때 사용되는 유틸러티
```

### (Alias for Apache Web Server)

```bash
# vi ~/.bashrc
..... (중략) .....
#
# Alias for Web Server
#
alias WEB='cd /etc/httpd/conf'
alias WWW='cd /var/www/html'
alias httpd.conf='vi /etc/httpd/conf/httpd.conf'
alias wlog='tail -f /etc/httpd/logs/access_log'
alias welog='tail -f /etc/httpd/logs/error_log'

# . ~/.bashrc    (# source ~/.bashrc)
```

(1) 기본 설정 상태 확인

```bash
# cd /etc/httpd 
# ls -lR         (# find .)
.:
total 16
drwxr-xr-x 2 root root 4096 Mar 14 20:04 conf
drwxr-xr-x 2 root root 4096 Feb 28 01:49 conf.d
lrwxrwxrwx 1 root root   19 Feb 24 00:50 logs -> ../../var/log/httpd
lrwxrwxrwx 1 root root   27 Feb 24 00:50 modules -> ../../usr/lib/httpd/modules
lrwxrwxrwx 1 root root   13 Feb 24 00:50 run -> ../../var/run

./conf:
total 52
-rw-r--r-- 1 root root 33760 Mar 14 19:38 httpd.conf
-rw-r--r-- 1 root root 13139 Nov 13 08:47 magic

./conf.d:
total 64
-rw-r--r-- 1 root root  295 Nov 13 08:47 manual.conf
-rw-r--r-- 1 root root 1796 Apr 22  2005 perl.conf
-rw-r--r-- 1 root root  560 Jan 14 07:16 php.conf
-rw-r--r-- 1 root root  566 Nov 13 08:47 proxy_ajp.conf
-rw-r--r-- 1 root root 1671 Jan  7  2007 python.conf
-rw-r--r-- 1 root root  392 Nov 13 08:47 README
-rw-r--r-- 1 root root  332 Jan 21  2009 squid.conf
-rw-r--r-- 1 root root 9677 Nov 13 08:47 ssl.conf
-rw-r--r-- 1 root root  352 Jan  9  2007 webalizer.conf
-rw-r--r-- 1 root root  299 Nov 13 08:47 welcome.conf
```

(2) /etc/httpd/conf/httpd.conf 파일 분석

httpd.conf 파일은 3가지 섹션으로 구분한다.

- Section 1 : Global environment
- Section 2 : "Main" server configuration
- Section 3 : Virtual hosts  < conf.d 디렉토리에 따로 정의

### 지시자 파일

**(Section 1)** 중요한 지시자(Directive)

- ServerType
- ServerRoot
- StartServers
MinSpareServers
MaxSpareServers
- MaxClients
- LoadModule

**(Section 2)** 중요한 지시자(Directive)

- Listen
- User/Group
- DocumentRoot
- <Directory "/path/to/somedir"> </Directory>
- AccessFileName
- Log file locations and formats
- Modules specific configuration blocks
- MIME type definitions and handlers: /etc/mime.types

**(Section 3)** 중요한 지시자(Directive)

- NameVirtualHost
- <VirtualHost 10.100.0.50> ... </VirtualHost>
- ServerName
- Documentation

-> "Section 3"의 설정은 "Section 2"에 설정을 덮어 쓰게 된다.

[참고] 이 문서의 마지막 부분은 "Appendix A. httpd.conf 파일 해석" 부분을 참고한다.

(3) Apache Web Server 실행

```bash
		(현재) # systemctl (restart/start/stop) httpd
		(부팅) # systemctl enable httpd
(httpd 명령어 사용법)
# httpd -t                  /* httpd.conf 파일의 문법 점검(Syntax Check) */
# httpd -v                  /* httpd 버전 확인 */
# httpd -f httpd_test.conf  /* httpd_test.conf 파일의 설정대로 데몬을 띄운다. */
```

```bash
② httpd -v 옵션 사용
# httpd -v
Server version: Apache/2.4.37 (centos)
Server built:   Jun  8 2020 20:14:33
-> Apache 2.4.37 버전을 사용하고 있다.

       # man httpd 
       -v     Print the version of httpd, and then exit.
```

```bash
③ httpd -f httpd.conf 옵션 사용
# systemctl stop httpd
-> 만약 이전 실습에서 httpd 데몬이 떠 있었다면 서비스를 종료 한다.

# cd /etc/httpd/conf 
# cp httpd.conf httpd_test.conf 
# httpd -f /etc/httpd/conf/httpd_test.conf 
# pgrep -lf httpd
26344 httpd -f /etc/httpd/conf/httpd_test.conf
26345 httpd -f /etc/httpd/conf/httpd_test.conf
26346 httpd -f /etc/httpd/conf/httpd_test.conf
26347 httpd -f /etc/httpd/conf/httpd_test.conf
26348 httpd -f /etc/httpd/conf/httpd_test.conf
26349 httpd -f /etc/httpd/conf/httpd_test.conf
26350 httpd -f /etc/httpd/conf/httpd_test.conf
26351 httpd -f /etc/httpd/conf/httpd_test.conf
26352 httpd -f /etc/httpd/conf/httpd_test.conf
```

```bash
④ 아파치 서비스 restart(원래 상태의 데몬으로 변경한다.)
# ps -ef | grep httpd
httpd -f /etc/httpd/conf/httpd_test.conf라인으로 검색된 PID를 강제 종료
# kill -9 PID
# systemctl start httpd
# pgrep -lf httpd 
-> 기본 설정 파일을 가지고 데몬이 떠 있는지 확인한다.
```

(4) 아파치 웹서버 설정

(4-1) 아파치 웹서버 기본 설정'

```bash
31 ServerRoot "/etc/httpd"
	이 지시문은 httpd가 상대 경로 이름을 사용하여 구성 파일에서 참조된 파일을 찾는 위치를 지정합 니다.
42 Listen 80
	이 지시문은 httpd에 모든 인터페이스의 포트 80/TCP에서 수신 대기하도록 지시합니다. 선택한 인 터페이스에서만 수신 대기하도록 하려면 IPv4의 경우에는 구문 “Listen 1.2.3.4:80”을, IPv6의 경 우에는 구문 “Listen [2001:db8::1]:80”을 사용할 수 있습니다.
	참고: 여러 listen 지시문이 허용되지만 listen 지시문을 중복해서 사용하면 치명적 오류가 발생하 여 httpd가 시작되지 못할 수도 있습니다.
56 Include conf.modules.d/*.conf
	이 지시문에는 마치 파일이 구성 파일의 Include 문에 삽입된 것과 같이 여러 다른 파일이 포함되어 있습니다. 여러 파일이 지정되면 포함하기 전에 파일 이름의 영숫자순으로 정렬됩니다. 파일 이름은 절대 이름이거나 ServerRoot에 상대적일 수 있으며 *와 같은 와일드카드를 포함할 수 있습니다.
66 User apache
67 Group apache
	이러한 두 개의 지시문은 해당 권한으로 httpd 데몬이 실행되는 사용자 및 그룹을 지정합니다. httpd는 항상 root로 시작되지만 root 권한이 필요한 모든 작업(예: 1024 아래의 포트 번호에 바인 딩)이 수행되면 권한이 삭제되고 권한 없는 사용자로 실행이 계속됩니다. 이것은 보안을 위한 조치 입니다.
86 ServerAdmin root@localhost
	httpd에서 생성하는 일부 오류 페이지는 사용자가 문제를 보고할 수 있는 링크를 포함할 수 있습니 다. 이 지시문을 유효한 이메일 주소로 설정하면 웹 마스터가 사용자에게 보다 쉽게 연락할 수 있습 니다. 이 설정을 기본값인 root@localhost로 두는 것은 권장되지 않습니다.
102 <Directory />
	<Directory> 블록은 지정된 디렉토리 및 모든 하위 디렉토리에 대한 구성 지시문을 설정합니다.
	<Directory> 블록 내의 일반적인 지시문에는 다음이 포함됩니다.
	•AllowOverride None: .htaccess 파일에서 디렉토리별 구성 설정이 확인되지 않습니다. 이 지시
	문을 다른 설정으로 지정하면 성능이 저하될 뿐만 아니라 보안 문제도 발생할 수 있습니다. •Require All Denied: httpd는 이 디렉토리의 콘텐츠를 제공하는 것을 거부하고 클라이언트의
	요청이 있을 때 HTTP/1.1 403 Forbidden 오류를 반환합니다.
	•Require All Granted: 이 디렉토리에 대한 액세스를 허용합니다. 일반 콘텐츠 트리 외부의 디렉
	토리에 대해 이 지시문을 설정하면 보안 문제가 발생할 수 있습니다.
	•Options [[+|-]OPTIONS]...: 디렉토리에 대한 특정 옵션을 설정(또는 해제)합니다. 예를 들어 Indexes 옵션은 디렉토리가 요청되고 해당 디렉토리에 index.html 파일이 없는 경우 디렉토리 목록을 표시합니다.
119 DocumentRoot "/var/www/html"
	이 설정은 httpd가 요청된 파일을 검색할 위치를 결정합니다. 여기에 지정된 디렉토리를 httpd(일 반 사용 권한과 SELinux)에서 읽을 수 있어야 하고 액세스를 허용하기 위해 해당 <Directory> 블록 을 선언해야 합니다.
163 <IfModule dir_module>
	이 블록은 지정된 확장 모듈이 로드되는 경우에만 해당 콘텐츠를 적용합니다. 이 경우 dir_module이 로드되므로 DirectoryIndex 지시문을 사용하여 디렉토리가 요청될 때 사용될 파일 을 지정할 수 있습니다.
171 <Files ".ht*">
	<Files> 블록은 <Directory> 블록처럼 작동하지만 여기서는 개별(와일드카드 적용) 파일에 대한 옵션이 사용됩니다. 이 경우 이 블록은 httpd가 보안에 중요한 파일을 .htaccess 및 .htpasswd처 럼 처리하지 못하게 합니다.
182 ErrorLog "logs/error_log"
	이 설정은 httpd 파일이 발생하는 모든 오류를 로깅할 위치를 지정합니다. 이것은 상대 경로 이름이 므로 앞에 ServerRoot 지시문이 붙습니다. 기본 구성에서 /etc/httpd/logs는 /var/log/httpd/에 대한 심볼릭 링크입니다.
217     CustomLog "logs/access_log" combined
	CustomLog 지시문은 로깅할 파일과 LogFormat 지시문으로 정의되는 로그 형식의 두 매개 변수를 사용합니다. 관리자는 이러한 지시문을 사용하여 필요하거나 원하는 정보를 정확히 로깅할 수 있습 니다. 대부분의 로그 구문 분석 도구는 기본 combined 형식이 사용된다고 간주합니다.
316 AddDefaultCharset UTF-8
	이 설정은 text/plain 및 text/html 리소스의 Content-Type 헤더에 charset 부분을 추가합니다. 이 설정은 AddDefaultCharset Off를 사용하여 비활성화할 수 있습니다
353 IncludeOptional conf.d/*.conf
	이 설정은 일반적인 포함과 동일하게 작동하지만 파일을 찾을 수 없으면 오류가 생성되지 않습니다.
```

```bash
① ServerAdmin/ServerName/UserDir 지시자 설정
# vi /etc/httpd/conf/httpd.conf
..... (중략) .....
#
# ServerAdmin: Your address, where problems with the server should be
# e-mailed.  This address appears on some server-generated pages, such
# as error documents.  e.g. admin@your-domain.com
#
[수정전]
ServerAdmin root@localhost
[수정후]
#---> ServerAdmin root@localhost
ServerAdmin root@linux2XX.example.com         <----- '관리자 이메일 주소 입력'

#
# ServerName gives the name and port that the server uses to identify itself.
# This can often be determined automatically, but we recommend you specify
# it explicitly to prevent problems during startup.
#
# If this is not set to valid DNS name for your host, server-generated
# redirections will not work.  See also the UseCanonicalName directive.
#
# If your host doesn't have a registered DNS name, enter its IP address here.
# You will have to access it by its address anyway, and this will make
# redirections work in a sensible way.
#
[수정전]
#ServerName www.example.com:80
[수정후]
#---> #ServerName www.example.com:80
ServerName www.example.com:80        <----- '서버 이름을 입력'

..... (중략) .....
<IfModule mod_userdir.c>
    #
    # UserDir is disabled by default since it can confirm the presence
    # of a username on the system (depending on home directory
    # permissions).
    #
    [수정전]
    UserDir disable
    [수정후]
#--->    UserDir disable
    #UserDir disable            <----- '주석 처리'
    #
    # To enable requests to /~user/ to serve the user's public_html
    # directory, remove the "UserDir disable" line above, and uncomment
    # the following line instead:
    #
    [수정전]
    #UserDir public_html
    [수정후]
#--->    #UserDir public_html
    UserDir public_html         <----- '주석 제거'

</IfModule>
```

```bash
② 서비스 restart
# service httpd restart
Stopping httpd:                                            [  OK  ]
Starting httpd:                                            [  OK  ]
# chkconfig httpd on 
#

③ 웹 확인
# lynx http://www.example.com 
-> 페이지 확인
-> q
-> y
```

참고사항

```bash
테스트를 진행하지 않음

# /usr/local/apache/conf/extra/httpd-mpm.conf

<IfModule mpm_worker_module>

StartServers 3

MaxClients 150

MinSpareThreads 75

MaxSpareThreads 250

ThreadsPerChild 25

MaxRequestWorkers 400

MaxConnectionsPerChild 0

</IfModule>
```

- .htaccess 파일을 이용한 웹 보안

(4-4) 가상 호스트 설정(Virtual Hosting)

■ Client ----- 작업 요청(**적은 경우**) -----> Machine(WEB1, WEB2, WEB3)

■ Client ----- 작업 요청(많은 경우) -----> WEB(Machine1 Machine2 Machine3)

**Virtual Hosting**

■ 이름 기반 가상 호스트(**Name-based Virtual Hosting**)   <<<< 

■ IP 기반 가상 호스트(**IP-based Virtual Hosting**)

■ 포트 기반 가상 호스트(Port-based Virtual Hosting)

■ 혼합된 형태(Mixed Virtual Hosting)

이름 기반 가상 호스트

DNS에 추가

**[SERVER1]# vi /var/named/server.zone**

```
site1	IN	A	192.168.10.210
```

**[SERVER1]# systemctl restart named-chroot**

**[SERVER2]# nslookup [site1.example.com](http://site1.example.com/)**

```
Server:		192.168.10.200
Address:	192.168.10.200#53

Name:	site1.example.com
Address: 192.168.10.210
```

**[SERVER2]# mkdir -p /srv/site1/www**

**[SERVER2]# cd /etc/httpd/conf.d**

**[SERVER2]# vi /etc/httpd/conf.d/vitual1.conf**

```
<Directory /srv/site1/www>
Require all granted
AllowOverride None
</Directory>

<VirtualHost 192.168.10.210:80>
DocumentRoot /srv/site1/www
ServerName site1.example.com
ServerAdmin webmaster@site1.example.com
ErrorLog "logs/site1_error_log"
CustomLog "logs/site1_access_log" combined
</VirtualHost>
```

**[SERVER2]# echo "site1 web" > /srv/site1/www/index.html**

**[SERVER2]# semanage fcontext -a -t httpd_sys_content_t '/srv/site1/www(/.*)?'**

**[SERVER2]# restorecon -Rv /srv/**

**[SERVER2]# systemctl restart httpd**

**[SERVER1]# lynx [site1.example.com](http://site1.example.com/)**

- 숨김
- Appendix A. httpd.conf 파일의 해석
- Appendix B. HTTP Status Code and Reason Phrase

    [참고] HTTP Status Code and Reason Phrase

    ```bash
    ● (참고) http://www.ietf.org/rfc/rfc2068.txt

       The Status-Code element is a 3-digit integer result code of the
       attempt to understand and satisfy the request. These codes are fully
       defined in section 10. The Reason-Phrase is intended to give a short
       textual description of the Status-Code. The Status-Code is intended
       for use by automata and the Reason-Phrase is intended for the human
       user. The client is not required to examine or display the Reason-
       Phrase.

       The first digit of the Status-Code defines the class of response. The
       last two digits do not have any categorization role. There are 5
       values for the first digit:

         o  1xx: Informational - Request received, continuing process

         o  2xx: Success - The action was successfully received, understood,
            and accepted

         o  3xx: Redirection - Further action must be taken in order to
            complete the request

         o  4xx: Client Error - The request contains bad syntax or cannot be
            fulfilled

         o  5xx: Server Error - The server failed to fulfill an apparently
            valid request

       The individual values of the numeric status codes defined for
       HTTP/1.1, and an example set of corresponding Reason-Phrase's, are
       presented below. The reason phrases listed here are only recommended
       -- they may be replaced by local equivalents without affecting the
       protocol.

              Status-Code    = "100"   ; Continue
                             | "101"   ; Switching Protocols
                             | "200"   ; OK
                             | "201"   ; Created
                             | "202"   ; Accepted
                             | "203"   ; Non-Authoritative Information
                             | "204"   ; No Content
                             | "205"   ; Reset Content
                             | "206"   ; Partial Content
                             | "300"   ; Multiple Choices
                             | "301"   ; Moved Permanently
                             | "302"   ; Moved Temporarily
                             | "303"   ; See Other
                             | "304"   ; Not Modified
                             | "305"   ; Use Proxy
                             | "400"   ; Bad Request
                             | "401"   ; Unauthorized
                             | "402"   ; Payment Required
                             | "403"   ; Forbidden
                             | "404"   ; Not Found
                             | "405"   ; Method Not Allowed
                             | "406"   ; Not Acceptable
                             | "407"   ; Proxy Authentication Required
                             | "408"   ; Request Time-out
                             | "409"   ; Conflict
                             | "410"   ; Gone
                             | "411"   ; Length Required
                             | "412"   ; Precondition Failed
                             | "413"   ; Request Entity Too Large
                             | "414"   ; Request-URI Too Large
                             | "415"   ; Unsupported Media Type
                             | "500"   ; Internal Server Error
                             | "501"   ; Not Implemented
                             | "502"   ; Bad Gateway
                             | "503"   ; Service Unavailable
                             | "504"   ; Gateway Time-out
                             | "505"   ; HTTP Version not supported
                             | extension-code

              extension-code = 3DIGIT

              Reason-Phrase  = *<TEXT, excluding CR, LF>

       HTTP status codes are extensible. HTTP applications are not required
       to understand the meaning of all registered status codes, though such
       understanding is obviously desirable. However, applications MUST
       understand the class of any status code, as indicated by the first
       digit, and treat any unrecognized response as being equivalent to the
       x00 status code of that class, with the exception that an
       unrecognized response MUST NOT be cached. For example, if an
       unrecognized status code of 431 is received by the client, it can
       safely assume that there was something wrong with its request and
       treat the response as if it had received a 400 status code. In such
       cases, user agents SHOULD present to the user the entity returned
       with the response, since that entity is likely to include human-
       readable information which will explain the unusual status.

    10.1 Informational 1xx

       This class of status code indicates a provisional response,
       consisting only of the Status-Line and optional headers, and is
       terminated by an empty line. Since HTTP/1.0 did not define any 1xx
       status codes, servers MUST NOT send a 1xx response to an HTTP/1.0
       client except under experimental conditions.

    10.1.1 100 Continue

       The client may continue with its request. This interim response is
       used to inform the client that the initial part of the request has
       been received and has not yet been rejected by the server. The client
       SHOULD continue by sending the remainder of the request or, if the
       request has already been completed, ignore this response. The server
       MUST send a final response after the request has been completed.

    10.1.2 101 Switching Protocols

       The server understands and is willing to comply with the client's
       request, via the Upgrade message header field (section 14.41), for a
       change in the application protocol being used on this connection. The
       server will switch protocols to those defined by the response's
       Upgrade header field immediately after the empty line which
       terminates the 101 response.

       The protocol should only be switched when it is advantageous to do
       so.  For example, switching to a newer version of HTTP is
       advantageous over older versions, and switching to a real-time,
       synchronous protocol may be advantageous when delivering resources
       that use such features.

    10.2 Successful 2xx

       This class of status code indicates that the client's request was
       successfully received, understood, and accepted.

    10.2.1 200 OK

       The request has succeeded. The information returned with the response
       is dependent on the method used in the request, for example:

       GET  an entity corresponding to the requested resource is sent in the
            response;

       HEAD the entity-header fields corresponding to the requested resource
            are sent in the response without any message-body;

       POST an entity describing or containing the result of the action;

       TRACE an entity containing the request message as received by the end
            server.

    10.2.2 201 Created

       The request has been fulfilled and resulted in a new resource being
       created. The newly created resource can be referenced by the URI(s)
       returned in the entity of the response, with the most specific URL
       for the resource given by a Location header field. The origin server
       MUST create the resource before returning the 201 status code. If the
       action cannot be carried out immediately, the server should respond
       with 202 (Accepted) response instead.

    10.2.3 202 Accepted

       The request has been accepted for processing, but the processing has
       not been completed. The request MAY or MAY NOT eventually be acted
       upon, as it MAY be disallowed when processing actually takes place.
       There is no facility for re-sending a status code from an
       asynchronous operation such as this.

       The 202 response is intentionally non-committal. Its purpose is to
       allow a server to accept a request for some other process (perhaps a
       batch-oriented process that is only run once per day) without
       requiring that the user agent's connection to the server persist
       until the process is completed. The entity returned with this
       response SHOULD include an indication of the request's current status
       and either a pointer to a status monitor or some estimate of when the
       user can expect the request to be fulfilled.

    10.2.4 203 Non-Authoritative Information

       The returned metainformation in the entity-header is not the
       definitive set as available from the origin server, but is gathered
       from a local or a third-party copy. The set presented MAY be a subset
       or superset of the original version. For example, including local
       annotation information about the resource MAY result in a superset of
       the metainformation known by the origin server. Use of this response
       code is not required and is only appropriate when the response would
       otherwise be 200 (OK).

    10.2.5 204 No Content

       The server has fulfilled the request but there is no new information
       to send back. If the client is a user agent, it SHOULD NOT change its
       document view from that which caused the request to be sent. This
       response is primarily intended to allow input for actions to take
       place without causing a change to the user agent's active document
       view. The response MAY include new metainformation in the form of
       entity-headers, which SHOULD apply to the document currently in the
       user agent's active view.

       The 204 response MUST NOT include a message-body, and thus is always
       terminated by the first empty line after the header fields.

    10.2.6 205 Reset Content

       The server has fulfilled the request and the user agent SHOULD reset
       the document view which caused the request to be sent. This response
       is primarily intended to allow input for actions to take place via
       user input, followed by a clearing of the form in which the input is
       given so that the user can easily initiate another input action. The
       response MUST NOT include an entity.

    10.2.7 206 Partial Content

       The server has fulfilled the partial GET request for the resource.
       The request must have included a Range header field (section 14.36)
       indicating the desired range. The response MUST include either a
       Content-Range header field (section 14.17) indicating the range
       included with this response, or a multipart/byteranges Content-Type
       including Content-Range fields for each part. If multipart/byteranges
       is not used, the Content-Length header field in the response MUST
       match the actual number of OCTETs transmitted in the message-body.

       A cache that does not support the Range and Content-Range headers
       MUST NOT cache 206 (Partial) responses.

    10.3 Redirection 3xx

       This class of status code indicates that further action needs to be
       taken by the user agent in order to fulfill the request. The action
       required MAY be carried out by the user agent without interaction
       with the user if and only if the method used in the second request is
       GET or HEAD. A user agent SHOULD NOT automatically redirect a request
       more than 5 times, since such redirections usually indicate an
       infinite loop.

    10.3.1 300 Multiple Choices

       The requested resource corresponds to any one of a set of
       representations, each with its own specific location, and agent-
       driven negotiation information (section 12) is being provided so that
       the user (or user agent) can select a preferred representation and
       redirect its request to that location.

       Unless it was a HEAD request, the response SHOULD include an entity
       containing a list of resource characteristics and location(s) from
       which the user or user agent can choose the one most appropriate. The
       entity format is specified by the media type given in the Content-
       Type header field. Depending upon the format and the capabilities of
       the user agent, selection of the most appropriate choice may be
       performed automatically.  However, this specification does not define
       any standard for such automatic selection.

       If the server has a preferred choice of representation, it SHOULD
       include the specific URL for that representation in the Location
       field; user agents MAY use the Location field value for automatic
       redirection.  This response is cachable unless indicated otherwise.

    10.3.2 301 Moved Permanently

       The requested resource has been assigned a new permanent URI and any
       future references to this resource SHOULD be done using one of the
       returned URIs. Clients with link editing capabilities SHOULD
       automatically re-link references to the Request-URI to one or more of
       the new references returned by the server, where possible. This
       response is cachable unless indicated otherwise.

       If the new URI is a location, its URL SHOULD be given by the Location
       field in the response. Unless the request method was HEAD, the entity
       of the response SHOULD contain a short hypertext note with a
       hyperlink to the new URI(s).

       If the 301 status code is received in response to a request other
       than GET or HEAD, the user agent MUST NOT automatically redirect the
       request unless it can be confirmed by the user, since this might
       change the conditions under which the request was issued.

         Note: When automatically redirecting a POST request after receiving
         a 301 status code, some existing HTTP/1.0 user agents will
         erroneously change it into a GET request.

    10.3.3 302 Moved Temporarily

       The requested resource resides temporarily under a different URI.
       Since the redirection may be altered on occasion, the client SHOULD
       continue to use the Request-URI for future requests. This response is
       only cachable if indicated by a Cache-Control or Expires header
       field.

       If the new URI is a location, its URL SHOULD be given by the Location
       field in the response. Unless the request method was HEAD, the entity
       of the response SHOULD contain a short hypertext note with a
       hyperlink to the new URI(s).

       If the 302 status code is received in response to a request other
       than GET or HEAD, the user agent MUST NOT automatically redirect the
       request unless it can be confirmed by the user, since this might
       change the conditions under which the request was issued.

         Note: When automatically redirecting a POST request after receiving
         a 302 status code, some existing HTTP/1.0 user agents will
         erroneously change it into a GET request.

    10.3.4 303 See Other

       The response to the request can be found under a different URI and
       SHOULD be retrieved using a GET method on that resource. This method
       exists primarily to allow the output of a POST-activated script to
       redirect the user agent to a selected resource. The new URI is not a
       substitute reference for the originally requested resource. The 303
       response is not cachable, but the response to the second (redirected)
       request MAY be cachable.

       If the new URI is a location, its URL SHOULD be given by the Location
       field in the response. Unless the request method was HEAD, the entity
       of the response SHOULD contain a short hypertext note with a
       hyperlink to the new URI(s).

    10.3.5 304 Not Modified

       If the client has performed a conditional GET request and access is
       allowed, but the document has not been modified, the server SHOULD
       respond with this status code. The response MUST NOT contain a
       message-body.
       The response MUST include the following header fields:

      o  Date

      o  ETag and/or Content-Location, if the header would have been sent in
         a 200 response to the same request

      o  Expires, Cache-Control, and/or Vary, if the field-value might
         differ from that sent in any previous response for the same variant

       If the conditional GET used a strong cache validator (see section
       13.3.3), the response SHOULD NOT include other entity-headers.
       Otherwise (i.e., the conditional GET used a weak validator), the
       response MUST NOT include other entity-headers; this prevents
       inconsistencies between cached entity-bodies and updated headers.

       If a 304 response indicates an entity not currently cached, then the
       cache MUST disregard the response and repeat the request without the
       conditional.

       If a cache uses a received 304 response to update a cache entry, the
       cache MUST update the entry to reflect any new field values given in
       the response.

       The 304 response MUST NOT include a message-body, and thus is always
       terminated by the first empty line after the header fields.

    10.3.6 305 Use Proxy

       The requested resource MUST be accessed through the proxy given by
       the Location field. The Location field gives the URL of the proxy.
       The recipient is expected to repeat the request via the proxy.

    10.4 Client Error 4xx

       The 4xx class of status code is intended for cases in which the
       client seems to have erred. Except when responding to a HEAD request,
       the server SHOULD include an entity containing an explanation of the
       error situation, and whether it is a temporary or permanent
       condition. These status codes are applicable to any request method.
       User agents SHOULD display any included entity to the user.

         Note: If the client is sending data, a server implementation using
         TCP should be careful to ensure that the client acknowledges
         receipt of the packet(s) containing the response, before the server
         closes the input connection. If the client continues sending data
         to the server after the close, the server's TCP stack will send a
         reset packet to the client, which may erase the client's
         unacknowledged input buffers before they can be read and
         interpreted by the HTTP application.

    10.4.1 400 Bad Request

       The request could not be understood by the server due to malformed
       syntax. The client SHOULD NOT repeat the request without
       modifications.

    10.4.2 401 Unauthorized

       The request requires user authentication. The response MUST include a
       WWW-Authenticate header field (section 14.46) containing a challenge
       applicable to the requested resource. The client MAY repeat the
       request with a suitable Authorization header field (section 14.8). If
       the request already included Authorization credentials, then the 401
       response indicates that authorization has been refused for those
       credentials. If the 401 response contains the same challenge as the
       prior response, and the user agent has already attempted
       authentication at least once, then the user SHOULD be presented the
       entity that was given in the response, since that entity MAY include
       relevant diagnostic information. HTTP access authentication is
       explained in section 11.

    10.4.3 402 Payment Required

       This code is reserved for future use.

    10.4.4 403 Forbidden

       The server understood the request, but is refusing to fulfill it.
       Authorization will not help and the request SHOULD NOT be repeated.
       If the request method was not HEAD and the server wishes to make
       public why the request has not been fulfilled, it SHOULD describe the
       reason for the refusal in the entity. This status code is commonly
       used when the server does not wish to reveal exactly why the request
       has been refused, or when no other response is applicable.

    10.4.5 404 Not Found

       The server has not found anything matching the Request-URI. No
       indication is given of whether the condition is temporary or
       permanent.

       If the server does not wish to make this information available to the
       client, the status code 403 (Forbidden) can be used instead. The 410
       (Gone) status code SHOULD be used if the server knows, through some
       internally configurable mechanism, that an old resource is
       permanently unavailable and has no forwarding address.

    10.4.6 405 Method Not Allowed

       The method specified in the Request-Line is not allowed for the
       resource identified by the Request-URI. The response MUST include an
       Allow header containing a list of valid methods for the requested
       resource.

    10.4.7 406 Not Acceptable

       The resource identified by the request is only capable of generating
       response entities which have content characteristics not acceptable
       according to the accept headers sent in the request.

       Unless it was a HEAD request, the response SHOULD include an entity
       containing a list of available entity characteristics and location(s)
       from which the user or user agent can choose the one most
       appropriate.  The entity format is specified by the media type given
       in the Content-Type header field. Depending upon the format and the
       capabilities of the user agent, selection of the most appropriate
       choice may be performed automatically. However, this specification
       does not define any standard for such automatic selection.

         Note: HTTP/1.1 servers are allowed to return responses which are
         not acceptable according to the accept headers sent in the request.
         In some cases, this may even be preferable to sending a 406
         response. User agents are encouraged to inspect the headers of an
         incoming response to determine if it is acceptable. If the response
         could be unacceptable, a user agent SHOULD temporarily stop receipt
         of more data and query the user for a decision on further actions.

    10.4.8 407 Proxy Authentication Required

       This code is similar to 401 (Unauthorized), but indicates that the
       client MUST first authenticate itself with the proxy. The proxy MUST
       return a Proxy-Authenticate header field (section 14.33) containing a
       challenge applicable to the proxy for the requested resource. The
       client MAY repeat the request with a suitable Proxy-Authorization
       header field (section 14.34). HTTP access authentication is explained
       in section 11.

    10.4.9 408 Request Timeout

       The client did not produce a request within the time that the server
       was prepared to wait. The client MAY repeat the request without
       modifications at any later time.

    10.4.10 409 Conflict

       The request could not be completed due to a conflict with the current
       state of the resource. This code is only allowed in situations where
       it is expected that the user might be able to resolve the conflict
       and resubmit the request. The response body SHOULD include enough
       information for the user to recognize the source of the conflict.
       Ideally, the response entity would include enough information for the
       user or user agent to fix the problem; however, that may not be
       possible and is not required.

       Conflicts are most likely to occur in response to a PUT request. If
       versioning is being used and the entity being PUT includes changes to
       a resource which conflict with those made by an earlier (third-party)
       request, the server MAY use the 409 response to indicate that it
       can't complete the request. In this case, the response entity SHOULD
       contain a list of the differences between the two versions in a
       format defined by the response Content-Type.

    10.4.11 410 Gone

       The requested resource is no longer available at the server and no
       forwarding address is known. This condition SHOULD be considered
       permanent. Clients with link editing capabilities SHOULD delete
       references to the Request-URI after user approval. If the server does
       not know, or has no facility to determine, whether or not the
       condition is permanent, the status code 404 (Not Found) SHOULD be
       used instead.  This response is cachable unless indicated otherwise.

       The 410 response is primarily intended to assist the task of web
       maintenance by notifying the recipient that the resource is
       intentionally unavailable and that the server owners desire that
       remote links to that resource be removed. Such an event is common for
       limited-time, promotional services and for resources belonging to
       individuals no longer working at the server's site. It is not
       necessary to mark all permanently unavailable resources as "gone" or
       to keep the mark for any length of time -- that is left to the
       discretion of the server owner.

    10.4.12 411 Length Required

       The server refuses to accept the request without a defined Content-
       Length. The client MAY repeat the request if it adds a valid
       Content-Length header field containing the length of the message-body
       in the request message.

    10.4.13 412 Precondition Failed

       The precondition given in one or more of the request-header fields
       evaluated to false when it was tested on the server. This response
       code allows the client to place preconditions on the current resource
       metainformation (header field data) and thus prevent the requested
       method from being applied to a resource other than the one intended.

    10.4.14 413 Request Entity Too Large

       The server is refusing to process a request because the request
       entity is larger than the server is willing or able to process. The
       server may close the connection to prevent the client from continuing
       the request.

       If the condition is temporary, the server SHOULD include a Retry-
       After header field to indicate that it is temporary and after what
       time the client may try again.

    10.4.15 414 Request-URI Too Long

       The server is refusing to service the request because the Request-URI
       is longer than the server is willing to interpret. This rare
       condition is only likely to occur when a client has improperly
       converted a POST request to a GET request with long query
       information, when the client has descended into a URL "black hole" of
       redirection (e.g., a redirected URL prefix that points to a suffix of
       itself), or when the server is under attack by a client attempting to
       exploit security holes present in some servers using fixed-length
       buffers for reading or manipulating the Request-URI.

    10.4.16 415 Unsupported Media Type

       The server is refusing to service the request because the entity of
       the request is in a format not supported by the requested resource
       for the requested method.

    10.5 Server Error 5xx

       Response status codes beginning with the digit "5" indicate cases in
       which the server is aware that it has erred or is incapable of
       performing the request. Except when responding to a HEAD request, the
       server SHOULD include an entity containing an explanation of the
       error situation, and whether it is a temporary or permanent
       condition. User agents SHOULD display any included entity to the
       user. These response codes are applicable to any request method.

    10.5.1 500 Internal Server Error

       The server encountered an unexpected condition which prevented it
       from fulfilling the request.

    10.5.2 501 Not Implemented

       The server does not support the functionality required to fulfill the
       request. This is the appropriate response when the server does not
       recognize the request method and is not capable of supporting it for
       any resource.

    10.5.3 502 Bad Gateway

       The server, while acting as a gateway or proxy, received an invalid
       response from the upstream server it accessed in attempting to
       fulfill the request.

    10.5.4 503 Service Unavailable

       The server is currently unable to handle the request due to a
       temporary overloading or maintenance of the server. The implication
       is that this is a temporary condition which will be alleviated after
       some delay. If known, the length of the delay may be indicated in a
       Retry-After header.  If no Retry-After is given, the client SHOULD
       handle the response as it would for a 500 response.

         Note: The existence of the 503 status code does not imply that a
         server must use it when becoming overloaded. Some servers may wish
         to simply refuse the connection.

    10.5.5 504 Gateway Timeout

       The server, while acting as a gateway or proxy, did not receive a
       timely response from the upstream server it accessed in attempting to
       complete the request.

    10.5.6 505 HTTP Version Not Supported

       The server does not support, or refuses to support, the HTTP protocol
       version that was used in the request message. The server is
       indicating that it is unable or unwilling to complete the request
       using the same major version as the client, as described in section
       3.1, other than with this error message. The response SHOULD contain
       an entity describing why that version is not supported and what other
       protocols are supported by that server.
    ```

SSL 사용

```bash
# vi /etc/httpd/conf.d/vitual1.conf
<Directory /srv/site1/www>
Require all granted
AllowOverride None
</Directory>

<VirtualHost 192.168.10.210:80>
DocumentRoot /srv/site1/www
ServerName site1.example.com
ServerAdmin webmaster@site1.example.com
ErrorLog "logs/site1_error_log"
CustomLog "logs/site1_access_log" combined
</VirtualHost>

<VirtualHost 192.168.10.210:443>
ServerName site1.example.com
**SSLEngine on
SSLCertificateFile /etc/pki/tls/certs/example.com.crt 
SSLCertificateKeyFile /etc/pki/tls/private/example.com.key
SSLCertificateChainFile /etc/pki/tls/private/example.com.csr**
DocumentRoot /srv/site1/www
ServerName site1.example.com
ServerAdmin webmaster@site1.example.com
ErrorLog "logs/site1_error_log"
CustomLog "logs/site1_access_log" combined
</VirtualHost>
```

**[SERVER2]# firewall-cmd --permanent --add-service=https**

**[SERVER2]# firewall-cmd --reload**

**[SERVER2]# systemctl restart httpd**

# SSL

SSL 이란 Secure Socket Layer 의 약자로 인터넷 상에서 정보를 **암호화**하여 송수신하는 프로토콜로 현재 인터넷에서 널리 쓰여지고 있는 HTTP나 FTP 등의 **데이터를 암호화**하여 기업 비밀이나 개인 정보 등을 안전하게 송수신 할 수 있다

SSL 특징

```
공개키 암호나 비밀키 암호, 디지털 증명서, 해쉬함수 등의 보안 기술을 조합하여 데이터 도청이나 변경, 위장을 방지할 수 있으며 OSI 4,5 계층의 경계에서 동작하여 HTTP나 FTP 등 상위 프로토콜을 이용하는 S/W 에서는 특별히 의식하지 않고도 이용할 수 있다
```

# SSL의 이해

HTTPS 설정은 경험이 부족한 사용자에게는 어려울 수 있다. 여러 단계를 거쳐야 하고 암호화와 서버 구성에 관한 지식이 필요하기 때문에 복잡한 작업으로 여겨진다.

여기서는 HTTPS 설정에 필요한 구성 요소와 단계에 대해 설명한다. 호스팅 공급 업체가 HTTPS 인증서를 제공하는 경우는 설정이 더 쉽다(제어판에서 모든 작업을 쉽고 빠르게 수행할 수 있다). 리눅스와 유닉스 아파치 HTTP 서버와 엔진엑스Nginx뿐만 아니라 윈도우 IISInternet Information Server의 관리자나 cPanel 사용자를 위한 지침도 소개한다. 기본적인 내용부터 시작해보자.

## HTTP, HTTPS, HTTP/2, SSL, TLS – 도대체 뭐가 뭔지?

클라이언트와 서버 간 통신 과정을 설명하는 데 사용되는 약어가 많다. 이러한 약어의 개념을 모르는 사람은 혼동해서 사용하기 쉽다.

**HTTP Hypertext Transfer Protocol**는 클라이언트와 서버 양쪽에서 통신할 수 있도록 구현해야 하는 기본 통신 프로토콜로, 

요청과 응답, 세션, 캐싱, 인증 등을 다룬다. 프로토콜과 HTML 관련 작업은 CERN에서 팀 버너스 리Tim Berners-Lee와 그 팀이 1989년에 시작했다. 첫 번째 공식 프로토콜 버전(HTTP 1.0)은 1996년에 발표됐고, 곧이어 1997년에 현재 널리 사용되는 버전(HTTP 1.1)이 나왔다.

HTTP는 브라우저와 서버 사이에서 정보를 평문으로 전송하므로 정보가 전달되는 네트워크에서 전송되는 정보를 엿볼 수 있다. 이런 보안 문제로 인해 클라이언트와 서버가 먼저 암호화 통신 채널을 설정한 다음 평문 HTTP 메시지를 전송함으로써 정보 유출을 막는 **HTTPS HTTP Secure**가 소개되었다.

암호화 채널은 이전에 **SSL Secure Socket Layer**이라고 불렸던 **TLS Transport Layer Security** 프로토콜을 사용해서 만든다. 흔히 SSL과 TLS를 혼용했으나 SSL 3.0은 TLS 1.0으로 대체되었다. SSL은 넷스케이프가 개발한 프로토콜인 반면 TLS는 IETF 표준이다. 현재 SSL(1.0, 2.0, 3.0)의 모든 버전은 여러 가지 보안 문제로 사용되지 않고 대부분의 브라우저에서 경고를 표시한다. 현재 TLS 버전(1.0, 1.1, 1.2)을 사용하고 있으며 1.3 버전은 초안이다.

1996년과 1997년에 현재의 안정적인 인터넷 버전(HTTP 1.1, SSL과 TLS는 선택)이 등장했으며 현재 대부분의 웹사이트가 이 버전에서 운영되고 있다. HTTP는 민감하지 않은 트래픽(예: 뉴스 기사)에 이용되고 HTTPS는 민감한 트래픽(예: 인증, 전자상거래)에 이용된다. 하지만 프라이버시에 관심이 높아지면서 구글 크롬과 같은 웹 브라우저는 이제 HTTP 웹사이트를 ‘안전하지 않음’으로 표시하고 HTTP의 앞날에 경고를 보내고 있다.

HTTP 프로토콜의 다음 업그레이드 버전인 **HTTP/2**는 점점 많은 웹사이트에 적용되고 있으며 지연을 줄이고 성능과 보안 향상을 위해 새 기능(압축, 멀티플렉싱, 우선순위 지정)을 추가했다.

HTTP 버전 1.1에서는 보안 연결이 선택이지만(HTTP와 HTTPS는 서로 독립적) HTTP/2에서는 사실상 필수다. 표준으로는 HTTP/2에서 TLS를 선택적으로 정의했지만 대부분의 브라우저 공급 업체는 HTTP/2와 TLS만 지원한다고 명시했다.

## HTTPS에서 제공하는 것

HTTPS로 전환을 고민하는 이유부터 살펴보자. HTTPS는 다음 세 가지 주요 이유 때문에 사용한다.

- **기밀성** HTTPS는 인터넷과 같은 공공 매체에서 두 참여자 간의 통신을 보호한다. 예를 들어, HTTPS가 없다면 와이파이 액세스 포인트를 운영하는 사람은 액세스 포인트를 사용하는 사람이 온라인에서 무언가를 구입할 때 신용카드와 같은 개인정보를 볼 수도 있다.

    Wi-Fi

    Access Point

- **무결성** HTTPS는 변조되지 않은 정보로 목적지에 도달하게 한다. 예를 들어, 와이파이가 웹사이트에 광고를 추가하거나, 대역폭을 절약하고자 이미지 품질을 저하시키거나, 읽는 기사의 내용을 변조할 수 있지만 HTTPS는 웹사이트를 변조할 수 없도록 한다.
- **인증** HTTPS를 통해 웹사이트의 진위 여부를 확인할 수 있다. 예를 들어, 와이파이 액세스 포인트을 운영하는 사람이 가짜 웹사이트를 브라우저에 보낼 수도 있다. HTTPS는 `example.com`이라는 웹사이트가 실제로 `example.com`인지 확인한다. 일부 인증서는 `yourbank.com`이 YourBank.Inc라는 걸 알리기 위해 해당 웹사이트의 법적 신원을 검사하기도 한다.

## 암호 기술의 핵심

기밀성, 무결성, 인증이 HTTPS에만 한정된 것은 아니다. 이러한 특징은 암호 기술의 핵심 개념이다. 이제부터는 각 특징에 대해서 들여다보자.

### 기밀성

기밀성Confidentiality은 프라이버시다. 즉, 기밀성은 인증되지 않은 **제3자가 정보를 읽지 못하도록 보호**한다. 그 과정은 보통 **평문**plaintext이라고 하는 읽을 수 있는(들을 수 있거나 볼 수 있는) 정보 형식을 **암호문** ciphertext이라고 하는 뒤죽박죽 된 읽을 수 없는 정보 형식으로 변환하는 작업을 거친다. 이 과정을 **암호화**encryption라고 한다. 반대의 과정(암호문을 다시 읽을 수 있는 평문으로 전환)을 **복호화**decryption라고 한다. 정보를 암호화하고 복호화하는 방법(**암호 함수**cipher functions 또는 **알고리즘**)은 많다.

두 명의 당사자가 통신하려면 다음 두 가지에 동의해야 한다.

1. 통신에 사용할 알고리즘(암호 함수)
2. 선택한 방법으로 사용할 매개변수 또는 암호, 규칙(예: 시크릿)

    secret

암호화에는 두 가지 주요 방법이 있다.

- **대칭** 양쪽 당사자가 공통 비밀 키를 공유한다.
- **비대칭** 당사자 중 한쪽이 비밀 키와 공개 키의 쌍, 공개 키 인프라(PKI) 기반을 갖는다.

대칭형 방식은 양쪽 당사자가 공유한 시크릿에 의존하는데, 전송자는 정보를 암호화하는 데 사용하고 수신자는 동일한 방식과 키를 사용해 복호화한다(‘대칭 키 암호화’ 그림 참조). 이 방법의 문제는 양쪽 당사자가 서로 물리적인 만남 없이 시크릿을 협상(교환)하는 방법이라서 일종의 보안 통신 채널이 필요하다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fd8d20bd-6def-46f9-b518-0a532c40e06c/_2020-07-31__12.56.59.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fd8d20bd-6def-46f9-b518-0a532c40e06c/_2020-07-31__12.56.59.png)

공개 키와 개인 키의 개념을 기반으로 하는 비대칭 방식은 대칭 방식의 문제를 해결한다. 두 가지 키 중 하나로 평문을 암호화하면 다른 보완 키를 사용해야만 복호화할 수 있다. 이를테면 서로 안전하게 통신하고 싶은 두 당사자 앨리스와 밥이 있다고 가정하자(앨리스와 밥은 모든 튜토리얼과 보안 매뉴얼에 항상 등장하는 허구의 인물이므로 여기서는 그러한 전통을 따랐다). 앨리스와 밥은 공개 키와 개인 키의 쌍을 가졌다. 개인 키는 각 소유자만 알고 있으며 공개 키는 누구든 사용할 수 있다.

앨리스가 밥에게 메시지를 보내고 싶다면, 앨리스는 밥의 공개 키를 얻어 평문을 암호화하고 암호문을 밥에게 보낸다. 밥은 자신의 개인 키를 사용해 암호문을 복호화한다.

밥이 앨리스에게 회신하고 싶다면, 앨리스의 공개 키를 얻어서 평문을 암호화해 암호문을 보낸다. 엘리스는 자신의 개인 키를 사용해 그 암호문을 복호화한다.

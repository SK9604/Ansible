# 환경 파일(Environment File)

---

- **환경파일의 종류**

    **/etc/profile**

    **~/.bash_profile**

    **~/.bashrc**

- **사용자 환경 파일 개요**
- **사용자 환경파일 읽혀 지는 순서**

    로그인시 읽혀 지는 환경파일

    쉘이 실행 될때 마다 읽혀 지는 환경파일

    로그아웃 할 때 마다 읽혀 지는 환경파일

- **사용자 환경파일 분석**
- **사용자 환경파일 활용**

로그인. 새로운 bash shell을 생성

read file.. 내가 사용하는 환경을 적절하게 변경.

로그인하는 경우마다, 쉘을 새로 실행시키는 경우마다 수동으로 

---

사용자 환경 파일(Bash Initialization)

## [1] 환경 파일이 읽혀 지는 순서

```bash
1. 로그인 
2. 쉘 실행시
```

각각의 쉘마다 쉘 이름이 다르다

```bash
#ls -l .*sh_history 
	로 검색하면 웬만하면 다 나온다 (보통은 bash)
# cat /etc/shells
```

```bash
# cat /etc/passwd | grep nologin$ | tail -1
```

```bash
쉘 바꾸고 싶은 경우 (bash가 아닌 경우)
#chsh
```

## [1-1] 로그인시에 읽혀 지는 환경 파일

```bash
getty는 실행되어있다
getty가 없으면 로그인을 할 수 없다.

로그인
시스템으로 진입 > 쉘을 실행

쉘의 실행
현재 시스템에 존재하면서 또 다른 프로세스 생성

로그아웃
시스템에서 빠져나가기
```

```bash
■ /etc/profile             > 로그인시 읽혀지는 환경파일
	■ /etc/profile.d/*.sh

■ ~/.bash_profile (~/.bash_profile -> 파일이 없으면 -> ~/.bash_login -> 파일이 없으면 -> ~/.profile)
	■ ~/.bashrc
		■ /etc/bashrc
```

## [1-2] 쉘이 실행 될때 마다 읽혀 지는 환경 파일

```bash
■ ~/.bashrc
	■ /etc/bashrc
		■ /etc/profile.d/*.sh
```

## [1-3] 로그아웃 할 때 마다 읽혀 지는 환경 파일

```bash
■ ~/.bash_logout
```

## [2] 사용자 환경 초기값 설정

## [2-1] 관리자가 일반사용자의 환경을 설정 시켜 주는 경우

```bash
■ /etc/profile : 로그인 할 때만 읽혀짐
■ /etc/bashrc  : 쉘이 실행 될때 마다 읽혀짐 (bash run control)
■ /etc/profile.d/*.sh : 쉘이 실행 될때 마다 읽혀짐
```

## [2-2] 일반 사용자가 자신의 환경을 설정 하는 경우

```bash
■ ~/.bash_profile : 로그인 할 때만 읽혀짐
■ ~/.bashrc       : 쉘이 실행 될때 마다 읽혀짐
```

## [3] 환경파일 분석

```bash
# cd /etc/profile.d
# cat bash_completion.sh
자동완성 해주는 기능을 가지고 있다
```

```bash
/etc/profile < 환경 설정 파일 읽으면서
해당 내용이 너무 길어지는 것을 방지하기 위하여 파일 끝에 반복문(for in do done)으로 
특정 디렉토리의 파일들을 실행하도록 명시 

/etc/profile - 로그인시 읽혀지는 파일
```

## [3-1] /etc/profie 파일

```bash
# cat /etc/profile
# /etc/profile

# System wide environment and startup programs, for login setup
# Functions and aliases go in /etc/bashrc

pathmunge () {
        if ! echo $PATH | /bin/egrep -q "(^|:)$1($|:)" ; then /* PATH 변수 내용 순서를 설정 */
           if [ "$2" = "after" ] ; then
              PATH=$PATH:$1
           else
              PATH=$1:$PATH
           fi
        fi
}

# ksh workaround
if [ -z "$EUID" -a -x /usr/bin/id ]; then    /* EUID 없으면 선언 */
        EUID=`id -u`
        UID=`id -ru`
fi

# Path manipulation
if [ "$EUID" = "0" ]; then       /* root 사용자이면 PATH 변수 선언, 위에 존재하는 pathmunge () 사용 */
        pathmunge /sbin
        pathmunge /usr/sbin
        pathmunge /usr/local/sbin
fi

# No core files by default
ulimit -S -c 0 > /dev/null 2>&1  /* -S : Soft 설정, -c : core 파일의 최대 크기 설정 */ 

if [ -x /usr/bin/id ]; then      /* USER, LOGNAME, MAIL 변수 선언 */
        USER="`id -un`"
        LOGNAME=$USER
        MAIL="/var/spool/mail/$USER"
fi

HOSTNAME=`/bin/hostname`         /* HOSTNAME, HISTSIZE 변수 선언 */
HISTSIZE=1000

if [ -z "$INPUTRC" -a ! -f "$HOME/.inputrc" ]; then
    INPUTRC=/etc/inputrc
fi

export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE INPUTRC

# By default, we want umask to get set. This sets it for login shell
# Current threshold for system reserved uid/gids is 200
# You could check uidgid reservation validity in
# /usr/share/doc/setup-*/uidgid file
if [ $UID -gt 99 ] && [ "`id -gn`" = "`id -un`" ]; then
    umask 002
else
    umask 022
fi

for i in /etc/profile.d/*.sh ; do    /* /etc/profile.d/*.sh 스크립트 실행 */
    if [ -r "$i" ]; then
        if [ "${-#*i}" != "$-" ]; then
            . $i
        else
            . $i >/dev/null 2>&1
        fi
    fi
done

unset i                 /* i 변수 unset */
unset pathmunge         /* pathmunge 함수 unset */
```

## [3-2] /etc/profile.d 디렉토리

```bash
# cd /etc/profile.d 
# ls
colorls.csh  gnome-ssh-askpass.csh  lang.csh  vim.csh
colorls.sh   gnome-ssh-askpass.sh   lang.sh   vim.sh
glib2.csh    krb5-workstation.csh   less.csh  which-2.sh
glib2.sh     krb5-workstation.sh    less.sh
		쉘(Shell)
		- sh  style : sh  -> ksh -> zsh -> bash
		- csh style : csh -> tcsh
```

## [3-3] $HOME/.bash_profile 파일

```bash
# cat ~/.bash_profile
# .bash_profile

# Get the aliases and functions    /* ~/.bashrc 파일 실행 */
if [ -f ~/.bashrc ]; then
        . ~/.bashrc                /* 파일이 있다면 실행 */
fi

# User specific environment and startup programs

PATH=$PATH:$HOME/bin               /* PATH 변수에 $HOME/bin 추가 */

export PATH                        /* PATH 변수 export */
unset USERNAME                     /* USERNAME 변수 unset */
```

## [3-4] $HOME/.bashrc 파일

```bash
# cat ~/.bashrc
# .bashrc

# User specific aliases and functions

alias rm='rm -i'                   /* 기본적인 명령어에 대한 alias 선언 */
alias cp='cp -i'
alias mv='mv -i'

# Source global definitions        /* /etc/bashrc 실행 */
if [ -f /etc/bashrc ]; then
        . /etc/bashrc              /* 파일이 있다면 실행 */
fi
```

## [3-5] /etc/bashrc 파일

```bash
# cat /etc/bashrc
# /etc/bashrc

# System wide functions and aliases
# Environment stuff goes in /etc/profile

# are we an interactive shell?
if [ "$PS1" ]; then
  if [ -z "$PROMPT_COMMAND" ]; then
    case $TERM in
        xterm*)
                if [ -e /etc/sysconfig/bash-prompt-xterm ]; then
                        PROMPT_COMMAND=/etc/sysconfig/bash-prompt-xterm
                else
                        PROMPT_COMMAND='printf "\033]0;%s@%s:%s\007" "${USER}" "${HOSTNAME%%.*}" \
                        "${PWD/#$HOME/~}"'
                fi
                ;;
        screen)
                if [ -e /etc/sysconfig/bash-prompt-screen ]; then
                        PROMPT_COMMAND=/etc/sysconfig/bash-prompt-screen
                else
                        PROMPT_COMMAND='printf "\033]0;%s@%s:%s\033\\" "${USER}" "${HOSTNAME%%.*}" \
       "${PWD/#$HOME/~}"'
                fi
                ;;
        *)
                [ -e /etc/sysconfig/bash-prompt-default ] && \
       PROMPT_COMMAND=/etc/sysconfig/bash-prompt-default
            ;;
    esac
  fi
  # Turn on checkwinsize
  shopt -s checkwinsize
  [ "$PS1" = "\\s-\\v\\\$ " ] && PS1="[\u@\h \W]\\$ "
fi

if ! shopt -q login_shell ; then 
    # We're not a login shell
    # Need to redefine pathmunge, it get's undefined at the end of /etc/profile
    pathmunge () {
                if ! echo $PATH | /bin/egrep -q "(^|:)$1($|:)" ; then
                        if [ "$2" = "after" ] ; then
                                PATH=$PATH:$1
                        else
                                PATH=$1:$PATH
                        fi
                fi
        }

    # By default, we want umask to get set. This sets it for non-login shell.
    # You could check uidgid reservation validity in
    # /usr/share/doc/setup-*/uidgid file
    if [ $UID -gt 99 ] && [ "`id -gn`" = "`id -un`" ]; then   /* UMASK 값 설정 */
       umask 002
    else
       umask 022
    fi

    # Only display echos from profile.d scripts if we are no login shell
    # and interactive - otherwise just process them to set envvars
    for i in /etc/profile.d/*.sh; do   /* 쉘이 실행할 때 로그인할 때 읽힐 수 있도록 한번 더 */
        if [ -r "$i" ]; then
            if [ "$PS1" ]; then
                . $i
            else
                . $i >/dev/null 2>&1
            fi
        fi
    done

        unset i
        unset pathmunge
fi
# vim:ts=4:sw=4
```

## [3-6]  $HOME/.bash_logout

```bash
# cat ~/.bash_logout
# ~/.bash_logout

clear        /* 지금은 아무것도 없다 */
```

### [EX1] 사용자 환경 파일이 읽혀 지는 순서에 대한 실습

```bash
① /etc/profile 파일에 테스트 내용 추가

■ /etc/profile -> /etc/profile.d/*.sh 

# cat /etc/profile | head -10
# vi /etc/profile                          대문자 O눌러서 최 상단에서 두번째줄에 라인 추가

# /etc/profile
echo "|---> /etc/profile read"             <----- 새로운 라인 추가
# System wide environment and startup programs, for login setup
# Functions and aliases go in /etc/bashrc

pathmunge () {
        if ! echo $PATH | /bin/egrep -q "(^|:)$1($|:)" ; then
           if [ "$2" = "after" ] ; then
              PATH=$PATH:$1
           else
```

```bash
② /etc/profile.d 디렉토리에 테스트용 스크립트 생성
# cd /etc/profile.d 
# vi test.sh
#!/bin/bash

echo "|---> /etc/profile.d/*.sh test.sh read"
```

```bash
③ ~/.bash_profile 파일에 테스트 내용 추가

■ ~/.bash_profile -> ~/.bashrc -> /etc/bashrc

# vi ~/.bash_profile
echo "|---> ~/.bash_profile read"        <----- 새로운 라인 추가

-----------------------------------------------------------------
# .bash_profile
echo "|---> ~/.bash_profile read"
# Get the aliases and functions
if [ -f ~/.bashrc ]; then
        . ~/.bashrc
fi

# User specific environment and startup programs

PATH=$PATH:$HOME/bin

export PATH
echo "|---> ~/.bash_profile out"
```

```bash
④ ~/.bashrc 파일에 테스트 내용 추가
# vi ~/.bashrc 
echo "|---> ~/.bashrc read"             <----- 새로운 라인 추가

---------------------------------------------------------------
# .bashrc
echo "|---> ~/.bashrc read"
# User specific aliases and functions

alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'

# Source global definitions
if [ -f /etc/bashrc ]; then
        . /etc/bashrc
fi
echo "|---> ~/.bashrc out"
```

```bash
⑤ /etc/bashrc 파일에 테스트 내용 추가
# vi /etc/bashrc
echo "|---> /etc/bashrc read"               <---- 새로운 라인 추가

-------------------------------------------------------------------
# /etc/bashrc
echo "|---> /etc/bashrc read"
# System wide functions and aliases
# Environment stuff goes in /etc/profile

# It's NOT a good idea to change this file unless you know what you
# are doing. It's much better to create a custom.sh shell script in
# /etc/profile.d/ to make custom changes to your environment, as this
# will prevent the need for merging in future updates.

# Prevent doublesourcing
if [ -z "$BASHRCSOURCED" ]; then
  BASHRCSOURCED="Y"

  # are we an interactive shell?
  if [ "$PS1" ]; then
    if [ -z "$PROMPT_COMMAND" ]; then
      case $TERM in
      xterm*|vte*)
        if [ -e /etc/sysconfig/bash-prompt-xterm ]; then
            PROMPT_COMMAND=/etc/sysconfig/bash-prompt-xterm
        elif [ "${VTE_VERSION:-0}" -ge 3405 ]; then
            PROMPT_COMMAND="__vte_prompt_command"
        else
            PROMPT_COMMAND='printf "\033]0;%s@%s:%s\007" "${USER}" "${HOSTNAME%%.*}" "${PWD/#$HOME/\~}"'
        fi
        ;;
      screen*)
        if [ -e /etc/sysconfig/bash-prompt-screen ]; then
            PROMPT_COMMAND=/etc/sysconfig/bash-prompt-screen
        else
            PROMPT_COMMAND='printf "\033k%s@%s:%s\033\\" "${USER}" "${HOSTNAME%%.*}" "${PWD/#$HOME/\~}"'
        fi
        ;;
      *)
        [ -e /etc/sysconfig/bash-prompt-default ] && PROMPT_COMMAND=/etc/sysconfig/bash-prompt-default
        ;;
      esac
    fi
    # Turn on parallel history
    shopt -s histappend
    history -a
    # Turn on checkwinsize
    shopt -s checkwinsize
		[ "$PS1" = "\\s-\\v\\\$ " ] && PS1="[\u@\h \W]\\$ "
    # You might want to have e.g. tty in prompt (e.g. more virtual machines)
    # and console windows
    # If you want to do so, just add e.g.
    # if [ "$PS1" ]; then
    #   PS1="[\u@\h:\l \W]\\$ "
    # fi
    # to your custom modification shell script in /etc/profile.d/ directory
	fi

  if ! shopt -q login_shell ; then # We're not a login shell
    # Need to redefine pathmunge, it gets undefined at the end of /etc/profile
    pathmunge () {
        case ":${PATH}:" in
            *:"$1":*)
                ;;
            *)
                if [ "$2" = "after" ] ; then
                    PATH=$PATH:$1
                else
                    PATH=$1:$PATH
                fi
        esac
    }

    # By default, we want umask to get set. This sets it for non-login shell.
    # Current threshold for system reserved uid/gids is 200
    # You could check uidgid reservation validity in
    # /usr/share/doc/setup-*/uidgid file
    if [ $UID -gt 199 ] && [ "`/usr/bin/id -gn`" = "`/usr/bin/id -un`" ]; then
       umask 002
    else
       umask 022
    fi

    SHELL=/bin/bash
    # Only display echos from profile.d scripts if we are no login shell
    # and interactive - otherwise just process them to set envvars
    for i in /etc/profile.d/*.sh; do
        if [ -r "$i" ]; then
            if [ "$PS1" ]; then
                . "$i"
            else
                . "$i" >/dev/null
            fi
        fi
    done

    unset i
    unset -f pathmunge
  fi

fi
echo "|---> /etc/bashrc out"
# vim:ts=4:sw=4
```

```bash
⑥ ~/.bash_logout 파일에 테스트 내용 추가
# vi ~/.bash_logout
echo "|---> ~/.bash_logout read"           <----- 새로운 라인 추가

# ~/.bash_logout
echo "|---> ~/.bash_logout read" 
```

```bash
⑦ 사용자로 로그인
# telnet localhost
Trying 127.0.0.1...
Connected to localhost.localdomain (127.0.0.1).
Escape character is '^]'.

    linuxXXX.example.com (Linux release 2.6.18-308.el5 #1 SMP Tue Feb 21 20:06:06 EST 2012) (2)

login: root
Password: (centos)
Last login: Thu Aug  1 11:01:49 on :0
You have new mail.
|---> /etc/profile read
|---> /etc/profile.d/*.sh read
|---> ~/.bash_profile read
|---> ~/.bashrc read
|---> /etc/bashrc read
========================================================================================
# ssh root@localhost
root@localhost's password: 
Activate the web console with: systemctl enable --now cockpit.socket

Last login: Thu Dec 10 10:31:34 2020 from ::1
|---> /etc/profile read
|---> /etc/profile.d/*.sh test.sh read
|---> /etc/bashrc read
|---> /etc/bashrc out
|---> ~/.bash_profile read
|---> ~/.bashrc read
|---> /etc/bashrc read
|---> /etc/bashrc out
|---> ~/.bashrc out
|---> ~/.bash_profile out
```

```bash
⑧ 하위 쉘(Sub Shell) 실행
# bash
|---> ~/.bashrc read
|---> /etc/bashrc read
|---> /etc/profile.d/*.sh read
====================================
# bash
|---> ~/.bashrc read
|---> /etc/bashrc read
|---> /etc/profile.d/*.sh test.sh read
|---> /etc/bashrc out
|---> ~/.bashrc out
```

```bash
⑨ 새로운 윈도우(Window) 실행
-> 바탕화면(Work Space)에서 오른쪽 마우스 클릭
-> 터미널 열기
-> 출력 내용 확인
|---> ~/.bashrc read
|---> /etc/bashrc read
|---> /etc/profile.d/*.sh read
# exit
```

```bash
⑩ 이전 명령어 윈도우에서 로그 아웃(Logout)
# exit
echo "|---> ~/.bash_logout read"
```

파일이 읽혀지는 순서

```bash
로그인 이후 쉘 할당 까지
|---> /etc/profile read
|---> /etc/profile.d/*.sh read
|---> /etc/bashrc read
|---> ~/.bash_profile read
|---> ~/.bashrc read
|---> /etc/bashrc read

하위 쉘 생성
|---> ~/.bashrc read
|---> /etc/bashrc read
|---> /etc/profile.d/*.sh read

로그아웃
|---> ~/.bash_logout read
```

## [4] 환경 파일의 활용 예

## [4-1] 사용자 환경 파일에 등록 될수 있는 내용들

```bash
■ 변수 설정
		PATH, PS1, 사용자 정의 변수 설정
■ 엘리어스(Alias) 설정
		alias ls='ls -hF'
■ 쉘 자체의 기능
```

## [4-2] 선언 예

```bash
# cat ~/.bashrc
# .bashrc

# User specific aliases and functions

alias rm='rm -i'             /* 기본적인 명령어에 대한 alias 선언 */
alias cp='cp -i'
alias mv='mv -i'

# Source global definitions  /* /etc/bashrc 실행 */
if [ -f /etc/bashrc ]; then
. /etc/bashrc
fi

---------------------------- ~/.bashrc 파일 하단에 추가 -----------------------------
# (a). 기본적인 alias
alias c='clear'      /* 명령어를 짧게 사용하기 위한 설정 */
alias h='history'
alias t='/usr/kerberos/bin/telnet 172.16.9.252'
alias d='cd /test && rm -rf /test/*'

alias grep='/bin/grep -i --color' /* 명령어 옵션 */
alias cat='/bin/cat -n'
alias df='/bin/df -h -T'
alias ls='ls -h --color=tty'

# (b). 필요한 경우 선언하는 alias
alias lsf='/bin/ls -al | grep ^-'      /* 새로운 명령어를 위한 alias */
alias lsd='/bin/ls -al | grep ^d'
alias pps='/bin/ps -ef | head -1 ; ps -ef | grep $1'
alias ddf='/bin/df -h -F ext3 ; echo ; /bin/df -i'

alias dir='/bin/ls -ailhF | more'   -----> 윈도우즈 명령어 실행 alias
alias ipconfig='ifconfig'           -----> 윈도우즈 명령어 실행 alias
alias topas='top'                   -----> AIX
alias bdf='df -h'                   -----> HP-UX
alias prstat='top'                  -----> Solars

alias nslookup='/usr/local/bin/nslookup' /* 다른 위치의 명령어 실행 */
alias vi='/usr/bin/vim'

# (c). 편리한 기능의 alias
/*
Webserver(Apache)
/etc/httpd/conf/httpd.conf -----> Configuration File
/var/www/html              -----> Source Directory
/etc/httpd/logs            -----> Log Directory
*/

# 설정 파일
alias fconf='vi /etc/vsftpd/vsftpd.conf'
alias wconf='vi /etc/httpd/conf/httpd.conf'
alias vsftpd.conf='vi /etc/vsftpd/vsftpd.conf'
alias httpd.conf='vi /etc/httpd/conf/httpd.conf'
# 소스디렉토리 이동
alias wdir='cd /var/www/html'
# 로그파일 모니터링
alias mlog='tail -f /var/log/messages'
alias wlog='tail -f /etc/httpd/logs/access_log'
alias welog='tail -f /etc/httpd/logs/error_log'
alias slog='tail -f /var/log/secure'
/* 실무에서 많이 사용되는 로그 파일 이름 형식 */ (예) file_1210.log
# tail -f /logs/file_1210.log 
# tail -f /logs/file_`date +%m%d`.log
# alias slog='tail -f /logs/file_`date +%m%d`.log'
# alias slog="view /logs/file_`date --date '1 days ago' +%m%d`.log"
# alias slog="view /logs/file_`date --date '2 days ago' +%m%d`.log"
---------------------------- ~/.bashrc 파일 하단에 추가 -----------------------------
```

- **배운 내용**

    스냅샷

    OVF

    리눅스 실습 환경 구성

    system runlevel

    언어 관련 설정

    제어 문자

    Bash

    운영체제 종료와 재부팅

    리눅스 기본 정보

    도움말

    시스템의 기본적인 정보를 확인하는 명령어

    date

    알고 있어야 할 명령어들

    리눅스 소개 및 정의

    GNU

    오픈 소스 소프트웨어

    리눅스

---

# 내용 정리

## **스냅샷**

---

**현재 상태를 보존**하고 빠른 복구와 이전으로 빠르게 돌아갈수있는 해법을 제시한다.

처음 작업하는 경우에는 많은 실수를 할 수 있기 때문에 원본을 만들어두고 장애가 생겼을시 재설치가 아닌 원복을 통하여 빠르게 재구성할수 있다.

※ 백업 용도는 아니다.

VM→Snapshot→snapshot manager

[원본]  ——  [install]  ——  [현재시점]

  R/O               R/O                  delta

생성한 스냅샷으로 이동 시 현재시점의 delta에 작업했던 내용들은 전부 삭제되고 스냅샷 시점으로 되돌아가 새로운 현재시점을 생성한다.

폴더에 생성된 스냅샷 파일이 존재한다

**스냅샷의 장단점**

장점 : 빠르게 예전 시점으로 돌아갈 수 있다.

단점 :  백업 대용으로 생각하여 사용하다가 머신이 망가지는 경우가 존재하기에 조심해야 하며 여러개의 시점을 생성하는 경우 디스크 I/O 이 많아져 성능이 떨어지는 경험을 할 수도 있다.

## OVF

---

가상 컴퓨터 패키징 및 배포를 위한 크로스 플랫폼 개방형 표준이다.

VMware Workstation에서 File → Export to OVF.. 누른 후 진행 디스크 파일이 가장 중요하다!!

**OVF의 장단점**

장점 : 이기종 플랫폼(window, mac)간의 가상머신 이동, 서버로의 이동 등이 자유롭다. 가상 머신 버전을 초월하여 사용가능하다.

단점 : 시간이 상당히 오래걸린다. (export, import)

**ZIP의 장단점**

장점 : 빠르다.

단점 : 이기종간에 배포 불가능, 파일 자체가 문제가 생길 경우가 존재한다.

결론 : OVF를 사용하자.

## 리눅스 실습 환경 구성

---

기본 화면

목록에 없습니까? → root 입력 후 화면

클래식 선택 후 로그인 할 경우 스탠다드와 약간 다른 화면이 나온다

### **System runrevel**

시스템의 현재 상태를 나타내는 숫자.

```
"init 숫자" 형식
-----------------------------------------------------------------------------
0 - halt                          시스템종료
1 - single user mode              싱글유저모드(시스템복구, 관리자 비밀번호 변경)
2 - multiuser                     멀티유저가능(단 nfs 사용불가)
3 - full multiuser                멀티유저가능(모든 기능 사용 가능)
4 - unused                        이후를 위해 예약된 번호
5 - full multiuser, graphical     그래픽모드를 지원하는 멀티유저 
6 - reboot                        재부팅
```

```
# who -r
            run-level 5  2020-03-11 09:40
            운영레벨=5    운영레벨 전환 시간
# runlevel
N 5
# init 3
login: root
password: redhat
# runrevel
5 3
# init 5
# who -r
run-level 5  2020-03-11 10:23                   last=3
현재 구성 정보   시스템 전환시간                  이전 구성 정보 레벨 확인

# systemctl get-default
graphical.target     => init 5과 동일
```


runlevel3 화면

런레벨은 하나의 물리적인 시스템에서 여러 가지의 운영 환경을 제공하는 것을 의미한다.

리눅스 서버의 경우에는 여러가지 운영 환경에서 전환 운영이 가능하다.

EX) GUI>TUI,CLI

### 언어 관련 설정

```
- 현재 사용중인 언어 확인

     # echo $LANG

     # locale

- 현재 지원되는 언어 종류 확인

     # locale -a

- 임시적인 언어 변경

     # export LANG=C ;  echo $LANG

- 영구적인 언어 변경

     # localectl set-locale LANG='변경할 언어'
```


### 제어 문자

```
Ctrl + C    Terminates the command currently running.
						현재 실행중인 프로그램을 인터럽트(interrupt) 걸어서 종료한다.

Ctrl + D    Indicates end-of-file or exit.
						파일의 끝(EOF) 의미 또는 현재 쉘 종료(exit) 의미를 갖는다.

Ctrl + U    Erases all characters on the current command line.
						명령어 라인 전체를 지워 주는 역할을 갖는다.

Ctrl + W    Erase the last word on the command line.
						명령어 라인상에 마지막 단어를 지워주는 역할을 갖는다.
						단어의 구분은 공백으로 한다.

Ctrl + S    Stops output to the screen
						명령어 출력 결과가 긴 경우 출력 화면을 멈춰 놓는다.(Stop)

Ctrl + Q    Restarts output to the screen after you have pressed Control-S
						명령어 출력 결과가 긴 경우 출력 화면을 계속 진행한다.(Quit)
```

```bash
Ctrl+D 파일의 끝(EOF) 의미

# mkdir –p /test    /* 최상위 디렉토리 아래 test 디렉토리 생성 */
# cd /test	    /* 생성한 test 디렉토리로 이동 */
# pwd               /* 현재 작업 디텍토리 확인*/
/test
# cat > file1	    /* 파일에 내용 입력 */
Hello, Linux <Enter>
<CTRL + D>          /*“파일의 끝”의미 */
# cat file1         /* 입력된 파일 내용 확인 */
Hello, Linux

-------------------------------------------------
Ctrl+D 현재 쉘 종료(exit) 의미

# ps     /* 프로세스 확인*/
# bash   /* 쉘 실행 */
# ps     /* 프로세스 확인 */

PID  TTY          TIME CMD
3290 pts/0    00:00:00 bash
3608 pts/0    00:00:00 bash

# <CTRL + D> /* 쉘 종료 (logout이 되는 것을 확인) */
GUI – 터미널이 종료된다
CLI – login 창으로 돌아간다

# ps\
PID TTY          TIME CMD
3290 pts/0    00:00:00 bash /* 이전에 실행한 bash shell이 종료 */

# init 3
login: root
password: redhat
# ps
# bash
# ps 
^d입력
# ps
^d
login:  
```

### Bash

ls 라는 명령어 하나만의 결과를 보기 위해서도 하드디스크, 키보드, 모니터등 여러 가지 장치를 제어해야 하는데 bash를 통한 명령어가 명령어 해석이 된 다음 커널에서 각종 장치를 제어하여 결과를 출력해준다.

```bash
bash                       bash
----------+--wait------>+----------> 부모쉘은 자식 쉘이 실행되는동안 wait상태로 대기하다가
          |             |            반환(종료)즉시 wait상태를 종료하고 명령어 입력을 받는다
          | bash        |
          +------------>+ 자식 쉘이 실행된다

# <CTRL + D>/* 쉘 종료 (logout이 되는 것을 확인) */ 

bash
----------+            +--------->
          |            |
          | bash       |
          +------------+
```

### 운영체제 종료와 재부팅

시스템을 종료하는 경우(halt)

```bash
이 명령어들은 시스템을 바로 종료한다.
# shutdown -h now      /* -h : halt */ /* 만약 시간을 지정하지 않는다면 기본 60초 이후 종료된다 */
# halt 
# poweroff
# init 0
```

시스템을 재부팅(reboot)

```bash
# shutdown -r now      /* -r : reboot */
# reboot
# init 6
```

예약 종료

```bash
# shutdown -h +5        /* -h : halt, +5 : 5분의 유예기간 */

Shutdown scheduled for 수 2018-02-28 20:01:27 KST, use 'shutdown -c' to cancel.

Broadcast message from root@server1 (Wed 2018-02-28 19:56:27 KST):

The system is going down for power-off at Wed 2018-02-28 20:01:27 KST!
 /* 현재 상태에서 5분간 대기후 종료 */

# shutdown -c      /* 종료 취소 */

Broadcast message from root@server1 (Wed 2018-02-28 19:57:20 KST):

The system shutdown has been cancelled at Wed 2018-02-28 19:58:20 KST!
/* 시스템 종료를 취소 */
이전버전에서는 제어문자 <CTRL + C>를사용하여 취소를 했지만 centos7에서는 shutdown -c 명령어를 사용하여 취소해야한다.
```

예약 종료 취소

```bash
# shutdown -c       /* -c: cancel, 관리자 및 다른 관리자가 예약종료를 취소시 사용 */

Broadcast message from root@server1 (Wed 2018-02-28 20:00:10 KST):

The system shutdown has been cancelled at Wed 2018-02-28 20:01:10 KST!
```

시스템을 종료하거나 재부팅 하는 경우

```bash
1. 정기 PM
2. 하드웨어 업그레이드
3. 대규모 업데이트
4. * 해킹의 경우 *
```

## **리눅스 기본정보**

---

### 리눅스 명령어 형식

```bash
# Command [options] [Arguments]
```


#까지 항상 자동 입력되어있음 (bash), 명령어 부분 부터  사용자가 입력하는 부분

**Linux CMD Format**

리눅스에서는 GUI모드 보다는 TEXT모드(CLI)를 위주로 지향(명령어 입력으로 수행)하여 작업을 하기 때문에 명령어 사용법에 대해 익혀야 한다. 이때 명령어를 입력하게 되면 쉘에서 이 명령어를 해석(전달)하여 작업을 하게 된다. 리눅스는 명령어 이름 외에도 옵션(Options)과 인자(Arguments)가 있다. 옵션은 명령어의 동작을 달리 할 때 사용하고 인자는 명령어의 인자나 혹은 옵션의 인자로서 사용이 될 수 있다.

**리눅스에서 명령어를 지향하여 시스템을 사용하는 이유**

서버 : 사용자를 위한 리소스를 많이 확보[우선목표]

GUI 사용하게 되면 : GUI에 사용되는 리소스 점유율이 높다.

CLI로 사용하게 되면 : 서비스 측면에서 더 많은 사용자를  수용할 수 있다.

장점 : 네트워크 트래픽의 감소.

원격 화면 공유 : 4K<<2K<FHD<HD<음성<text

**명령어를 사용하는 다양한 형식**

```bash
- "# Command" 사용하는 경우
[EX] # ls
- "# Command Options" 사용하는 경우
[EX] # ls -l
- "# Command Arguments" 사용하는 경우
[EX] # ls /var
- "# Command options Arguments" 사용하는 경우
[EX] # ls –l /var
- 한 개의 명령어 라인에 여러 명령어 사용 하는 경우
[EX] # cd /test ; ls –l

명령어의 옵션은 자리를 바꾸거나 혹은 합쳐서 사용해도 같은 의미로 동작한다.
# ls -a -l -F
# ls -al -F
# ls -alF
# ls -Fla

명령어의 옵션을 약자 형태로 쓰지 않기 위해서는 "--(double dash)"을 붙인다.
# ls --all    (# ls -a)

**※옵션의 인자가 존재하는 경우※**
예) # find / -name core -type f

# cmd -i -f arg1(0)
# cmd -f arg1 -i(0)
# cmd -if arg1(0)
# cmd -fi arg1(X) 

특정 값이 인자에 포함되어야 하는 경우는 인자 뒤에 값이 들어가야 한다.
옵션의 순서는 변경이 가능하지만 옵션과 같이 지정되는 인자의 경우는 옵션뒤에 와야하는 것을 주의한다.
```

**도움말**

```bash
man 명령어

# man ls
# man –k calendar
# whatis passwd
# man –s 5 passwd
# man ls | col –b > ls.txt
# info ls
# which ls
# whatis ls

간략하게 정보 확인 # ls --help  (# CMD --help)
자세하게 정보 확인 # man ls     (# man CMD)

# man ls 
빠져나오는 경우 q 

man 페이지 내에서 페이지 제어

<Enter> 하나의 라인씩 밀리면서 출력한다.
<Space> <--> <CTRL + B> 한 페이지씩 밀리면서 출력한다.
      CTRL + B로 이전 페이지로 돌아간다.
/-a     <--> n, N    (n: next) 특정 단어를 검색하여 찾는다. 두 개 이상 존재할경우는 n으로 다음 단
    어를 찾는다 
: 자주 사용되는 기능
/OPTIONS 
/EXAMPLES 
/Examplesls
q 
h
```

```bash
# man passwd
# man -s 1 passwd
# man -s 5 passwd

매뉴얼 페이지 각 섹션별 정보

  1     누구나 실행할 수 있는 사용자 명령 (User Commands)
  2     시스템 호출 (System Calls), 즉 커널에서 제공하는 함수
  3     C 라이브러리 함수 (C Library functions)
  4     디바이스와 네트워크 인터페이스 (Devices and Network Interfaces), 즉 /dev 디렉토리에 있는 특별한 파일들
  5     파일 포맷 (File Formats), 예를 들어 /etc/passwd
  6     게임과 데모 (Games and Demos)
  7     환경, 테이블, 매크로 (Environments, Tables, and Macros) 등의 잡다한 여러 가지들
  8     시스템 관리자만 실행할 수 있는 시스템 관리용 명령들 (Maintenance Commands)
  9     커널 루틴에 관련된 문서들의 리눅스만의 독자적인 저장소
  n     새로운 문서들의 저장소. 보다 적당한 장소로 이동된다.
  o     오래된 문서들의 저장소. 유예 기간으로 보관되고 있는 것들이다.
  l     특정 시스템에 대한 로컬 문서들
```

```bash
추가적인 정보 확인 명령어

# info ls 
man 페이지에서 간략하게 나오고 info에서 확인하라는 메시지가 하단에 나타나는 경우에 info 명령어를 확인한다.
# pinfo ls 
map 형식으로 나타내주며 색깔표시가 보기좋게 되어있다.
info로 확인해야 할 일이 있다면 pinfo를 사용하기 바란다.

# apropos ls     (# man -k calendar) 
# man -k ls

# whatis ls    명령어의 메뉴얼 파일 섹션 확인
ls (1)               - list directory contents
ls (1p)              - list directory contents    
# whereis ls   명령어의 바이너리 파일 경로, 메뉴얼 파일 실제 경로
ls: /usr/bin/ls /usr/share/man/man1/ls.1.gz /usr/share/man/man1p/ls.1p.gz
# which ls     명령어 실제 경로
alias ls='ls --color=auto'
        /usr/bin/ls 
# ls —-help
```

```bash
# whatis ls 명령어의 모든 섹션 확인
ls (1)               - 경로의 내용을 나...
ls (1p)              - list directory contents
# whereis ls 메뉴얼 페이지의 경로 확인
ls: /usr/bin/ls /usr/share/man/man1/ls.1.gz /usr/share/man/man1p/ls.1p.gz
# which ls 명령어의 실제 경로 확인
alias ls='ls --color=auto'
	/usr/bin/ls
# ls --help 명령어의 간단한 사용 형식 확인
```

- 알고 있어야 할 기본 명령어들
- 구글 엔지니어가 선정한 best 50 명령어

**시스템의 기본적인 정보를 확인하는 명령어**

```bash
- uname 명령어
     # uname –a
     # cat /etc/redhat-release

- date 명령어
     # date
     # date +%m%d

- cal 명령어
     # cal
     # cal 2002
     # cal 6 2002

uname 옵션
옵션 : 설  명
-a : 모든 정보
-s : 운영체제 종류 (예: Linux) 
-r : 운영체제 릴리즈 (예: 2.6.18-164.11.1.el5) 
-n : 호스트 이름 (예: linux200) 
-i : 머신아키텍쳐 (예: i386) 
-p : 프로세스 종류 (예: athlon)

# uname -a
Linux server1.example.com 4.18.0-147.el8.x86_64 #1 SMP Wed Dec 4 21:51:45 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux

해석
Linux                              (-s) 커널 이름(kernel name)
server1.example.com                (-n) 호스트 이름(Hostname)
4.18.0-147.el8.x86_64             (-r) 커널 릴리즈
커널 버전 : 주버전.부버전.fix버전-몇개의업데이트가있었는가
#1 SMP Wed Aug 7 18:08:02 UTC 2019 (-v) 커널 버전
x86_64                             (-m) 머신 하드웨어 이름
x86_64                             (-p) CPU 종류
x86_64                             (-i) 하드웨어 구현 플랫폼
GNU/Linux                          (-o) 운영체제 종류

# uname -s  /* 커널 이름 */
# uname -n  /* 호스트 이름 */
# uname -r  /* 커널 릴리즈 */
# uname -sr /* 커널 이름과 릴리즈 */
# uname -v  /* 커널 버전 */
# uname -m  /* 머신 하드웨어 이름 */
# uname -p  /* CPU 종류 */
# uname -i  /* 하드웨어 구현 플랫폼 */
# uname –o  /* 운영체제 종류 */
# uname -nsr

uname 대신에 시스템 정보를 확인하는 명령어
# hostnamectl
   Static hostname: server1.example.com
         Icon name: computer-vm
           Chassis: vm
        Machine ID: 420d15311a3b4313bea1a9d8e4ea12c3
           Boot ID: 7665e4e3ad6145a38f236367d6a98fe9
    Virtualization: vmware
  Operating System: CentOS Linux 8 (Core)
       CPE OS Name: cpe:/o:centos:centos:8
            Kernel: Linux 4.18.0-193.el8.x86_64
      Architecture: x86-64**
```

**date**

```bash
# date /* 시스템 시간 출력 */
# date 07241300/* 시스템 시간 변경 */
# date +%m%d /* 시간 출력 형태 변경 */

테스트를 위하여 터미널을 하나 더 실행
[TERM1]# watch -n 1 date

아래 작업들은 [TERM2]에서 작업한다.
# date 08161300     /* 8월 16일 13:00 로 설정 년도는 생략가능하다 */
       월.일.시.분 단위로 작성
# date 081613002009 /* 2009년 8월 16일 13:00 */
       월.일.시.분.연도

시간 포맷 형식
# date +%m%d        /* %m : month, %d : day */
# date +%m%d_%H%M   /* %H : hour, %M : Minute */

시간정보 포맷 변경하여 파일 저장
# cd /test
# rm -rf /test/*
# touch file_`date +%m%d`.log
# ls -l
# ls -l
total 0
-rw-r--r--. 1 root root 0 Mar 11 15:18 file_0311.log

date 명령어에서 시간형식 포맷 변경시 자주 사용되는 옵션
%m 월
%d 일
%H 시
%M 분
%S 정수 초
%s 1970.01.01 기준으로 흐른 초시간
[참고]
역 따옴표를 표현하기 위한 또 다른 방법
# touch file_$(date +%m%d).lo
```

## 리눅스 소개 및 정의

---

**UNIX**

IBM - AIX

HP - HP_UX

sun micro systems>oracle - solaris

- **GNU ( GNU's Not Unix )**

    GNU 시스템을 개발하기 위해 1984년에 시작

- **GPL (General Public License)**

    자신이 만들 소프트웨어에 GPL 라이선스를 가지는 코드가 한 줄 이라도 들어가면 소유권을 포기라하는 뜻이다.
    완전한 평등과 완전한 공유 정신을 뜻한다. 
    오픈소스의 대명사격인 리눅스가 GPL을 대표한다고 할수 있다.

- **Open Source**

    오픈소스 소프트웨어는 사용자가 소프트웨어를 실행하고 복제하고 배포하고 학습하고 개작하고 향상시킬수 있는 소프트웨어이다.

### GNU란?

GNU는 운영 체제의 하나이자 컴퓨터 소프트웨어의 모음집이다. GNU는 온전히 자유 소프트웨어로 이루어져 있으며그 중 대부분이 GNU 프로젝트의 GPL로 라이선스된다.

GNU는 "GNU's Not Unix!"(GNU는 유닉스가 아니다!)의 재귀 약자이며 이렇게 선정된 이유는 GNU의 디자인이 유닉스 계열이지만 자유 소프트웨어인 점과 유닉스 코드를 포함하지 않는다는 점에서 차별을 두려는 것이다.

GNU 프로젝트는운영 체제 커널, GNU HURD를 포함하고 있으며 이는 자유 소프트웨어 재단(FSF)에서 본래 초점을 두고 있었던 것이다. 그러나 GNU가 아닌 커널(가장 유명한 것으로 리눅스)은 GNU 소프트웨어와 함께 사용할 수도 있다. 즉, 허드(Hurd) 커널은 아직 운영용으로 준비되지는 않았는데, 이는 어떻게 GNU 시스템이 일반적으로 사용되고 있는지를 설명한다.GNU 소프트웨어와 리눅스 커널의 결합은 리눅스(또는 GNU/리눅스)로 알려져 있다.

### 오픈 소스 소프트웨어의 장점

1. **프로그램을 원하는 어떠한 목적으로도 실행할 수 있는 자유.**
2. 프로그램이 어떻게 동작하는지 학습하고, 자신의 필요에 맞게 개작할 수 있는 자유. 이것을 위해서는 소스 코드에 대한 접근이 전제되어야 합니다.
3. 이웃을 도울 수 있도록 복제물을 재배포할 수 있는 자유.
4. **프로그램을 개선시킬 수 있는 자유와 개선된 이점을 공동체 전체가 누릴 수 있게 그것을 발표할 자유. 이를 위해서는 역시 소스 코드에 대한 접근이 전제되어야 합니다.**
5. **코드상의 오류들이 많은 사람들의 눈에 의해 보다 쉽게 감지되고 빠르게 수정된다.**
6. GPL시스템하에서는 프로그래머들이 소송에 대한 두려움 없이 마음껏 코드를 배포할 수 있다.

### **리눅스란?**

- **리눅스는 유닉스 계열의 운영체제**

    POSIX 호환

- **리눅스는 합성어**

    리누스 토발즈와 UNIX의 합성어

- **리눅스 커널코드**

    자유 소프트웨어 재단 라이선스 정책인 GNU GPL을 따른다.

---

**리눅스(Linux)는 컴퓨터 운영 체제(서버 운영체제)**이며, 그 커널을 뜻하기도 한다. 리눅스는 자유 소프트웨어와 오픈 소스 개발의 가장 유명한 표본으로 들 수 있다. 리눅스는 다중 사용자, 다중 작업(멀티태스킹), 다중 스레드를 지원하는 네트워크 운영 체제(NOS)이다.

엄밀하게 따지면 이‘리눅스’라는 용어는 리눅스 커널만을 뜻하지만, 리눅스 커널과 GNU 프로젝트의 라이브러리와 도구들이 포함된, 전체 운영 체제(GNU/리눅스라고도 알려진)를 나타내는 말로 흔히 쓰인다. 리눅스 배포판은 핵심 시스템 외에 대다수 소프트웨어를 포함한다. 현재 200여 종류가 넘는 배포판이 존재한다.

초기에 리눅스는 개개인의 애호자들이 광범위하게 개발하였다. 이후 리눅스는 IBM, HP와 같은 거대 IT 기업의 후원을 받으며, **서버 분야에서 Unix와 Microsoft Windows 운영 체제의 대안으로 자리 잡았다**.

리눅스는 데스크톱 컴퓨터를 위한 운영 체제로서도 인기가 늘어가고 있다. 지지자와 분석자들은 이와 같은 성공을 벤더 독립성과 적은 개발비, 보안성과 안전성에서 기인한다고 분석한다.

리눅스는 처음에 인텔 386 마이크로프로세서를 위해 개발되었으나 현재는 다양한 컴퓨터 아키텍처를 지원한다. 리눅스는 개인용 컴퓨터에서부터 슈퍼 컴퓨터는 물론 휴대 전화, 개인용 비디오 레코더와 같은 임베디드 시스템까지 광범위하게 이용되고 있다.

리누스 토발즈가 커널을 개발하고 GNU에서 개발된 나머지 명령어 프로그램들을 도입하여 현재의 리눅스로 발전해왔다.

현재는 각 국가들의 국가 운영체제로 리눅스를 채택하고 있다.

한국의 경우에는 일본, 중국, 미국의 영향을 받아 아직은 50:50정도로 가져가고 있으며 원천기술 개발이 부족한 시점이다.

---

**리눅스 특징**

- 리눅스는 누구가 자유롭게 사용할 수 있는 운영체제
- 리눅스는 다중 유저, 다중 작업을 지원하는 시스템
- 리눅스는 강력하고 안정적인 네트워크를 지원하는 운영체제
- 리눅스는 가격대 성능비가 강력한 운영체제
- 리눅스는 이식성이 강력한 운영체제

---

**리눅스 장점**

- **누구나 자유롭게 사용할 수 있는 운영체제이다.**

    오픈 소스로 인해 소스를 가공 & 변형 & 재배포 할 수 있는 GPL라이센스가 적용된다. 리눅스는 오픈소스나 배포에 치명적인 오류가 발생하더라도 여러 사람이 공동으로 소스를 수정 할 수 있도록 오픈되어 있기 때문에 MS와 같은 비오픈소스에 비해 정확하고 빠른 패치의 사용이 가능하다.

- **여러 사용자(Multi-user)가 동시에 사용할 수 있는 환경을 제공한다.**

    많은 사용자가 동시에 리눅스 시스템에 접속하더라도 다른 운영체제에 비해 안정적이고 탁월한 성능을 유지한다.

- **다중 작업(Multi Tasking) 및 가상 터미널(Virtual Terminal)환경을 지원한다.**

    윈도우는 한 화면에서 여러개의 창을 열어 다중작업을 하는 반면, 리눅스는 가상터미널 환경에서 작업 할 수 있는 멀티캐스팅을 지원한다. 리눅스는 윈도우에서 도스창과 창은 콘솔화면 창을 6개까지 띄워 작업하는 것을 말하는데, 이는 도스와 같은 환경의 컴퓨터를 6대 사용하는 것과 같다.

- **GUI방식의 X Window 를 지원한다.**

    리눅스에서는 2가지 형태의 작업 환경을 제공해준다. 첫 번째는 콘솔형태와 같은 TUI(Text User Interface)방식이고, 두 번째는 윈도우와 같은 GUI(Graphic User Interface)방식이다.

- **CPU 구애가 없는 운영체계이다.**

    리눅스는 x86을 기반으로 하는 인텔계열의 모든 CPU를 완벽히 지원하며, 인텔 486 CPU 이상의 기종에서도 무리 없이 작동 할 수 있도록 설계되어 다른 운영체제에 비해 적은 시스템 자원을 가진 시스템에서도 리눅스를 사용 할 수 있다.

- **강력하면서 안정적인 네트워크를 지원하는 운영체계이다.**

    하나의 어플리케이션에 오류가 발생하여도 전체 시스템이 중지되지 않다. 각 어플리케이션은 메모리에서 고유한 개별 위치를 차지하며 사용자 프로세스는 운영 체제 프로세스와 완전히 분리되어 있어, 어플리케이션에서 오류가 발생하더라도 운영 체제는 전혀 영향을 받지 않다.

- **리눅스에서의 하드웨어 드라이버 설정 및 하드웨어 사용이 매우 쉽다.**

    리눅스는 드라이버를 커널에서 모듈의 형태로 지원하고 있어, 제조업체의 드라이버 없이도 동일한 칩셋을 사용한 하드웨어에 대해서는 범용적으로 지원한다.

- **이식성이 강한 운영체계이다.**

    리눅스는 Unix의 프로그램과 소스를 쉽게 이식하고 컴파일 할 수 있다.

---

**리눅스의 역사**

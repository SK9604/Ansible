## 🙋🏻‍♀️ 열두째 비대면 수업

- **배운 내용**

변수

지역 변수

환경 변수

특수 변수

PATH 변수

HISTTIMEFORMAT 변수

메타캐릭터

히스토리

history 명령어

alias

문제

---

# 내용 정리

---

# 변수(Variable)

---

하나의 메모리 값에 들어갈 수 있는 데이터

- **변수의 종류**

    지역 변수(**Local Variable**)

    환경 변수(**Environment Variable**)

    특수 변수(**Special Variable**)

- **변수 선언 방법**

    ```bash
    변수명=값
    # VAR=5 ; export VAR
    # echo $VAR
    # unset VAR
    ```

- **변수 export란?**

---

## 변수

변수의 종류

지역변수(Local Variable) : **`# VAR=5`, `LANG=C`**

환경변수(Environment Variable) : **`# export VAR=5`, `export LANG=C`**

특수변수(Special Variable) : **$$, $?, $!, $0, $1, $#, $*, ....**

### [1] 지역변수 선언

```bash
변수 선언 방법(EX: bash)
	# VAR=5        (# export VAR=5)
	# export VAR 
	# echo $VAR    (# print $VAR)
	# unset VAR
```

지역 변수는 **현재 사용하고 있는 쉘에만 적용되는 변수 값으로 선언 하는 것이다.** 서브 쉘에서 지역 변수 값을 확인하려고 할 경우 값이 나타나지 않는다.

현재 쉘에서 간단하게 사용하기 위한 변수

해당 쉘을 빠져나가거나 하위쉘을 생성하는경우 생성된 변수를 사용할 수 없다는 단점이 있다.

echo → 인수<변수>로 지정된 문자열 출력. 라인, 문자열 출력

```bash
var=5                      echo $var (0)
----------+               +----------
          |               |
          | echo $var (X) |
          +---------------+
```

```bash
# var=5      /*붙여쓰지 않으면 씬텍스 에러*/
# echo $var
5
# var=hello 
# echo $var
hello
# bash      /*현재 var변수가 지역변수이기때문에 쉘을 벗어날 시 사용할 수 없다(bash=하위쉘 실행*/
# echo $var 
#

# exit 
# echo $var
```

### [2] 환경변수 선언

환경변수는 **현재 쉘과 서브쉘에 변수를 모두 적용되는 변수 값으로 선언해 주는 것이다.** 환경변수를 사용하는 이유는 이전쉘에서 선언한 변수 값을 서브쉘에서도 동일하게 적용하기 위한 것이다.

서브 쉘에도 동일하게 적용되는 변수값

몇 개의 서브 쉘을 실행 하더라도 사용자가 변경하기 전까지는 기존의 변수값을 그대로 상속받는다. 

```bash
export var=hello    echo $var (0)
----------+               +----------
          |               |
          | echo $var (0) |
          +---------------+
```

```bash
# var=hello 
# export var 
# echo $var
hello
# bash 
# echo $var
hello
# exit 

# echo $var
hello
export var=hello                            echo $var     hello 출력
----------+                               +----------
          |                               |
          | export var=centos             |
          +---------------+               |
                          |               |
                          | echo $var     |   centos 출력
                          +---------------+
하위쉘에서 적용된다
```

```bash
# var=hello     (# export var=hello)
# export var 
# echo $var
hello
# bash 
# echo $var
hello
# export var=centos 
# echo $var
centos
# bash 
# echo $var
centos
# ps
PID TTY          TIME CMD
14072 pts/2    00:00:00 bash
14075 pts/2    00:00:00 bash
14078 pts/2    00:00:00 bash
# exit 
# exit 
# echo $var
hello
```

(결론) 환경 변수는 자신이 선언한 쉘의 서브쉘에서 적용되는 것이다. 상위의 쉘에는 적용되지 않는다.

[참고] **env와** set의 차이점 (선언된 변수를 확인하는 명령어)

```bash
■ set : 모든 변수에 대해 출력 (지역변수 + 환경변수)
■ env : 환경변수만 출력 

[EX] set/env 명령어 실습
# var1=CentOS 
# export var2=Linux 

# set | grep var1
var1=CentOS
# set | grep var2
# bash
# env | grep var1 
#
-> 출력되는 정보가 없다.

# env | grep var2
var2=Linux
```

변수 해제시

```bash
# unset var
# set | grep var  /*확인*/
```

정리

```bash
# var=hello 
	hello라는 문자열을 var변수에 입력
# unset var 
	var변수를 해제하는 과정
```

```bash
# vi test.sh
# ./test.sh
bash: ./test.sh: 허가 거부
# chmod 777 test.sh
# ./test.sh
linux1
# env | grep ^TEST
# set | grep ^TEST
# cat test.sh
	#!/bin/bash

	TEST1=linux1

	echo $TEST1

	unset TEST1
```

디버그 모드

```bash
# bash -x test.sh
+ TEST1=linux1
+ echo linux1
linux1
+ unset TEST1

또는

# sh -x ./test.sh
+ TEST1=linux1
+ echo linux1
linux1
+ unset TEST1
```

### [3-1] 시스템 지역변수

```bash
# vi .bashrc

# .bashrc

# User specific aliases and functions

alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'

# Source global definitions
if [ -f /etc/bashrc ]; then
        . /etc/bashrc
fi

export PS1='# '                                /*추가*/
function cd { builtin cd $* && pwd ; }         /*추가*/
```

```bash
$*           : 인자를 모두 포함
CMD1 && CMD2 : 명령어를 연결해서 사용할 때 CMD1의 값이 참인 경우 CMD2 실행
							 CDM1의 $? 값이 0인 경우에 CMD2 실행
```

**주의!**

```bash
특정 디렉토리를 자주 삭제해야한다 → 귀찮음.. → alias로 작업을 해야겠다

내부 컨텐츠를 삭제할 디렉토리로 이동, 내부 컨텐츠를 삭제

# alias tt=‘ cd /testy ; rm -rf *’

문제점 : 만약 test 디렉토리 내에서 tt 실행 했을 때 /testy라는 폴더가 존재하지 않을 시 앞의 명령어 실패하고 뒤에 명령어를 실행해버린다. test 디렉토리 내에 모든 파일이 날아가버린다..
```

💡**&&와 ;와 ||의 차이 (민감한 명령어 작업시 주의)**

```bash
# cd /nodir && echo "OK"   /*앞의 내용 실패시 뒷 내용은 실행하지 않는다*/
bash: cd: /nodir: 그런 파일이나 디렉터리가 없습니다
# cd /nodir ; echo "OK"    /*앞의 내용 실패해도 뒷 내용을 실행힌다*/
bash: cd: /nodir: 그런 파일이나 디렉터리가 없습니다
OK
# cd /nodir || echo "OK"    /*앞의 내용 실패해야 뒷 내용을 실행힌다*/
bash: cd: /nodir: 그런 파일이나 디렉터리가 없습니다
OK
---------------------------------------------------------------
CMD1 && CMD2 : 1번 성공일 경우 2번 실행
CMD1 || CMD2 : 1번 실패일 경우 2번 실행
CMD1 ;  CMD2 : 1번이 성공이든 실패든 2번 실행
```

[3-1-1] PS1 **명령어 프롬프트에 나타내는 시스템 환경 변수**

```bash
# <- 현재 표시되는 이 문자에 대한 시스템 환경 변수를 표시한다.
```

```bash
[root@server1 ~]# echo $PS1
[\u@\h \W]\$

		PS1='[\u@\h \W]\$ ' 
		-----------------------------------------------------------
		\u   : username
		\h   : hostname
		\W   : working directory (예: /home/user01 -> user01)
		\w   : working directory (예: /home/user01 -> /home/user01)
		\$   : root(#), user01($)
		-----------------------------------------------------------
	현재 경로만 표시
# PS1='\w> ' /* 윈도우 처럼 절대 경로가 출력 '[절대경로]> ' */
/root>
		# PS1='$PWD> '
		# PS1='\w> '
# set | grep PS1
$PWD>
# env | grep PS1 
#

/root> bash
[root@linux200 ~]#
# PS1='[$PWD]# '
[/root]#
		# PS1='[$PWD]# '
		# PS1='[\w]# '
[/root]# bash
[root@linux200 ~]#
# export PS1='[\u@$PWD]# '
[root@/root]#
		# export PS1='[\u@$PWD]# '
		# export PS1='[\u@\w]\$ '
# bash
[root@/root]#
# export PS1='[\u@\h \w]\$ '
[root@linux200 ~]#
# exit 
# exit 
# exit 
#
```

(실무 예) PS1='[\u@\h \w]\$ '

```bash
# vi ~/.bashrc 
-------------------------------
.....
#
# Variable Definition
#
export PS1='[\u@\h \w]\$ '
-------------------------------

# .  ~/.bashrc   (# source ~/.bashrc)
```

[참고] 디렉토리 이동시 경로 표시하기

```bash
# vi .bashrc
function cd { builtin cd $* && pwd ; }  디렉토리 이동후 경로 표시

저장후 쉘을 새로 오픈한다.
```

[참고] PS1 시스템 환경 변수 설정하는 방법

```bash
쉘프롬프트에 보여지는 항목을 설정하는 것으로 아래와 같은 것들을 사용할 수 있다.
ex) [로그인한 계정@호스트네임 현재경로] #         /* 현재 상태 $ : 프롬프트($, root일 경우 #) */
---------------------------------------
\t     현재 시간을 HH:MM:SS 형식으로 표시
\d     날자를 "요일 월 일" 형식으로 표시 (예, "Tue May 26")
\n     개행문자
\s     쉘의 이름, $0 의 베이스 이름 (마지막 슬래쉬 뒷 부분)
\w     현재 작업 디렉토리
\W     현재 작업 디렉토리의 베이스 이름
\u     현재 사용자의 사용자명
\h     호스트 이름
\#     이 명령의 명령 번호
\!     이 명령의 히스토리 번호
\$     유효 UID가 0 이면 if the effective UID is 0, a #, 그렇지 않으면 $
\nnn   팔진수 nnn에 해당하는 문자
\\     백슬래쉬
\[     비출력 문자의 시퀀스를 시작한다. 프롬프트에 터미널 제어시퀀스를 넣을때 사용한다.
\]     비출력 문자의 시퀀스를 마친다.
```

[3-1-2] PS2 **명령어가 아직 끝나지 않았음을 나타낼 때** 사용

```bash
PS2='> '
# echo $PS2 
>
# ls -a -l 
# ls -a \ 
> -l

# echo "hello linux 
> "

# while true 
> do
> CMD
> sleep 5
> done
```

```bash
# echo $PS2
>

```

### [3-2] 시스템 환경변수

```bash
# echo $HOME
/root
# cd $HOME 
# pwd
/root
# echo $PWD
/root
# echo $LOGNAME
root
# echo $TERM
xterm
# echo $LANG
ko_KR.UTF-8
# echo $USER
root
# echo $UID
0
```

### [4] 알아두면 좋은 특수 변수 ⭐⭐⭐⭐

① $ : 현재쉘의 PID를 저장하고 있다. 쉘 스크립트내에서 임시 파일의 이름을 지정할 때 보통 사용이 된다.

```bash
# echo $$
11991

# ps
PID TTY          TIME CMD
11991 pts/1    00:00:00 bash
```

② ? : 바로 이전 명령어의 정상 실행 여부에 대한 결과값이 들어 있다. 쉘 스크립트내에서 이전 명령어의 정상 수행 여부를 확인할 때 주로 사용된다. 0이면 정상. 0이 아니면 비정상

```bash
# ls /nodir
ls: /nodir: No such file or directory
# echo $?
2
# cd /nodir
-bash: cd: /nodir: No such file or directory
# echo $?
1
# no
-bash: no: command not found
# echo $?
127
# ls
Desktop          hash.tar.gz         mbox              top.seceret.mail.gpg
anaconda-ks.cfg  install.log         serv.pub
hash.md5         install.log.syslog  top.seceret.mail
# echo $?
0
```

(실무 예) 백업 스크립트 작성시

```bash
# vi backup.sh 
-------------------------------------------------------
#!/usr/bin/bash
tar cvzf /backup/backup.tar.gz /home
	if [ $? -eq 0 ] ; then           /* -eq : equal */
	echo "success"
	else
	echo "error"
	fi
-------------------------------------------------------
```

[참고] /root/bin/script.sh 편하게 실행하기

관리자가 생성한 쉘 스크립트(쉘 프로그램)들을 모아 놓은 디렉토리

```bash
/root/bin or /root/shell
```

```bash
# echo $PATH
/usr/lib/qt-3.3/bin:/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
		PATH : 명령어들이 위치한 디렉토리를 선언할 때 사용하는 변수
		# ls -al 
		(절대경로) # /bin/ls -al
		(상대경로) # cd /bin
		           # ./ls -al

# mkdir -p /backup 
# mkdir -p /root/bin 
# vi /root/bin/backup.sh
-------------------------------------------------------
#!/bin/bash

tar cvzf /backup/back-`date +%m%d`.tar.gz --absolute-name /test
-------------------------------------------------------
# chmod 755 /root/bin/backup.sh 

# export PATH=$PATH:/root/bin 
# backup.sh 
# cd /backup ; ls
back-0520.tar.gz
```

[참고] 백업 스크립트 실패 유무 확인

```bash
# cd /test 
# vi script.sh
-------------------------------------------------------
#!/bin/bash

/root/bin/backup.sh  
		if [ $? -eq 0 ] ; then               /* -eq : equal */
		echo "Backup Success"
		else
		echo "Backup Fail"
		fi
-------------------------------------------------------
# chmod 755 /test/script.sh 
# ./script.sh
-------------------------------------------------------
		/test/
		/test/script.sh
		Backup Success
-------------------------------------------------------
# vi /root/bin/backup.sh
-------------------------------------------------------
#!/bin/bash

		tar cpvfz /backup/back-`date +'%m%d'`.tar.gz --absolute-name /nodir
-------------------------------------------------------
# ./script.sh
		tar: /nodir: Cannot stat: 그런 파일이나 디렉토리가 없음
		tar: Error exit delayed from previous errors
		Backup Fail
# ./script.sh > backup.log 2>&1 
# cat backup.log
		tar: /nodir: Cannot stat: 그런 파일이나 디렉토리가 없음
		tar: Error exit delayed from previous errors
		Backup Fail
```

③ ! : 바로 이전에 백그라운드로 실행한 프로세스의 PID번호가 저장 된다.

```bash
# sleep 300 &
[1] 25192
		[1]   : Job ID
		25192 : PID
# echo $!
25192
# ps
PID TTY          TIME CMD
24868 pts/1    00:00:00 bash
25101 pts/1    00:00:00 bash
25192 pts/1    00:00:00 sleep
25219 pts/1    00:00:00 ps
# sleep 400 &
[2] 25233
# ps
PID TTY          TIME CMD
24868 pts/1    00:00:00 bash
25101 pts/1    00:00:00 bash
25192 pts/1    00:00:00 sleep
25233 pts/1    00:00:00 sleep
25234 pts/1    00:00:00 ps
# echo $!
25233
```

④ 인자변수(Argument Variable)

```bash
$로 표시하여 인자변수의 값이 몇 번째인지 나타낼 수 있다.   인자변수1 | 인자변수2 | 인자변수3
		# ls -a 
		# vi ls 
		----------------------------------
		..... (중략) .....
		echo "$1"
		..... (중략) .....
		----------------------------------
```

```bash
# cd /test 
# vi test.sh
--------------------------------------
		#!/usr/bin/bash
		
		echo $1                     /* 첫번째 인자 */
		echo $2                     /* 두번째 인자 */
		echo $3                     /* 세번째 인자 */
--------------------------------------
# chmod 755 test.sh 
# ls -l test.sh
-rwxr-xr-x 1 root root    38 Aug 19 14:22 test.sh
# ./test.sh test1 test2 test3
test1
test2
test3
# date
Thu Aug 19 14:24:33 KST 2010
# set $(date) 
# echo $1
Thu
# echo $2
Aug
# echo $3
19
# echo $4
14:24:47
# echo $5
KST
# echo $6
2010
```

```bash
set을 이용하여 def를 통해 root디렉토리의 메모리 사용률 보기
# set $(df / | tail -1)
```

### [5] PATH 변수

명령어를 검색할 디렉토리를 선언할 때 사용하여 절대 경로를 쓰지 않고 실행파일명만을 이용해서 사용할 수 있게 한다. which라는 명령도 PATH에 설정되어 있는 디렉토리의 파일의 경로만을 알려준다.

```bash
# gedit & 
# which gedit
/usr/bin/gedit
# echo $PATH
/usr/lib/qt-3.3/bin:/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin:/root/bin
# cd 
# ls -l /test/script.sh
-rwxrwxrwx 1 root root 109  5월 20 15:26 /test/script.sh
```

(필요하면 아래와 같이 /test/script.sh 스크립트를 생성한다.)

```bash
# vi /test/script.sh 
------------------------------
#!/bin/bash

echo "script.sh Excution"
------------------------------
# chmod 755 /test/script.sh
```

```bash
# script.sh
-bash: script.sh: command not found
		(절대경로)# /test/script.sh 
		(상대경로) # cd /test 
		# ./script.sh 
		# script.sh
```

```bash
# vi ~/.bash_profile
# .bash_profile

# Get the aliases and functions
if [ -f ~/.bashrc ]; then
        . ~/.bashrc
fi

# User specific environment and startup programs

PATH=$PATH:$HOME/bin
PATH=$PATH:/test                  <----- 라인 추가  ★
사내에서 사용하는 특정 명령어들이 존재하고 디렉토리에 추가가 되어있고

export PATH
unset USERNAME

# .  ~/.bash_profile 
# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/root/bin:/custom
# script.sh
script.sh Excution
```

### [6] HISTTIMEFORMAT 변수

```bash
# export LANG=C 
# man bash
------------------------------
/HISTTIMEFORMAT
       HISTTIMEFORMAT
              If this variable is set and not null,  its  value
              is  used  as  a  format string for strftime(3) to
              print the time stamp associated with each history
              entry  displayed by the history builtin.  If this
              variable is set, time stamps are written  to  the
              history  file  so  they  may  be preserved across
              shell sessions.
------------------------------
# man 3 strftime
------------------------------
/%F
       %F     Equivalent  to  %Y-%m-%d  (the ISO 8601 date for-
              mat). (C99)
/%T
       %T     The time in 24-hour notation (%H:%M:%S). (SU)
# vi /etc/profile
..... (중략) .....
for i in /etc/profile.d/*.sh ; do
    if [ -r "$i" ]; then
        if [ "${-#*i}" != "$-" ]; then
            . $i
        else
            . $i >/dev/null 2>&1
        fi
    fi
done

#
# (1) Sfecific Configuration
#
export HISTTIMEFORMAT="%F %T     "

unset i
unset pathmunge
------------------------------
# telnet localhost 
root 사용자로 로그인

# history
..... (중략) ....
  776  10:07:00     clear
  777  10:07:11     clear
  778  10:10:42     clear
  779  10:12:43     export LANG=C
  780  10:13:12     man bash
  781  10:15:13     clear
  782  10:15:16     man 3 strftime
  783  10:17:49     vi /etc/profile
  784  10:20:15     history
# exit 
#
```

```bash
# history
# ![NUM]
# !cmd
(reverse-i-search)`': ctrl+r
```

### [7] 메타캐릭터(Metacharacter)

- ''(작은 따옴표(single quotation))
- ""(큰 따옴표(Double quotation))
- ``(역 따옴표(Back quotation))
- \ (역 슬래쉬(Back slash))
- ; (세미콜론(Semicolon))

쉘에서 특별한 의미를 가지는 문자

■ ''(작은 따옴표(single quotation))

쉘이 해석 할 수 없도록 막아 준다.

```bash
# echo $HOME
/root
# echo '$HOME'
$HOME
```

■ ""(큰 따옴표(Double quotation))

쉘이 해석 할 수 없도록 막아 준다. 단 인식되는 문자**($, ``, \)**들도 있다.

```bash
# echo $HOME 
/root
# echo "$HOME" 
/root
# echo "$HOME is my    directory."
/root is my    directory.
```

■ ``(역 따옴표(Back quotation))

쉘이 해석할 때 명령어로 인식한다. 따라서 역 따옴표 안의 내용을 실행한다.

```bash
# date 
# echo `date`     (# echo $(date))
# echo `hostname` (# echo $(hostname))
# echo "`hostname` is my hostname."

# touch server_`date +%m%d`.log
# tar cvzf /backup/home_`date +%m%d`.tar.gz /home
# while true
> do
> echo "------------`date`---------"
......
> sleep 2
> done
```

■ \ (역 슬래쉬(Back slash))

바로 이후에 있는 문자을 쉘이 해석 할 수 없도록 막아 준다.

```bash
# echo $HOME
# echo \$HOME    (# echo '$HOME')

# find / -name core -type f -exec rm -f {} \;
# find / \( -perm -4000 -o -perm -2000 \) -type f

		[참고] \(역 슬래쉬)
		# \CMD
		# CMD\
		
		# ./configure --prefix=/usr/local/apache2 --options2=.... --options3=.... .....
		# ./configure —prefix=/usr/local/apache2 \
		> --options2=.... \
		> --options3=.... \
		> --options4=....
```

■ ; (세미콜론(Semicolon))

한개의 라인에 여러개 명령어 수행할 때 사용한다.

```bash
# ls 
# date 
# cal 

# ls ; date ; cal 

# alias pps='ps -ef | head -1 ; ps -ef | grep $1'
# EDITOR=/usr/bin/vim ; export EDITOR    (# export EDITOR=/usr/bin/vim)
```

```bash
# echo $HOME
/root
# echo \$HOME /* \뒤에 오는 $를 해석하지 않고 문자그대로 출력한다 */
$HOME
# echo \\     /* \를 일반 출력하기 위해서 두번 동시에 입력 */
\
# echo "my directory $HOME"
my directory /root
# echo "my directory \$HOME"
my directory $HOME
# echo 'my directory \$HOME'
my directory \$HOME
```

# 히스토리(HISTORY)

---

- **History 관련 명령어**

    ```bash
    # history
    # history -5
    # cat ~/.bash_history
    # ![history_number]
    ```

- **History 관련 변수**

    **HISTSIZE**

    **HISEFILE**

    **HISTFILESIZE**

---

## history 명령어

파일로 저장되어 있는 히스토리 파일이 존재

터미널에서 메모리상에 있는 히스토리

터미널을 종료하기 전까지는 현재 작업중인 히스토리에 대하여 저장이 되지 않는다.

빠져나가야만 저장되고 이후에 새로 로그인을 해야 적용된다.

사용자가 로그인 하게 되면 사용자의 명령어를 저장하기 위해서 Stack 공간이 할당된다. Stack 공간은 ksh 쉘을 사용하고 있다면, 기본값은 1000개의 명령어를 저장할 수 있는 공간이 할당된다. bash 쉘은 1000개의 명령어를 저장 할 수 있다. 또한 sh 쉘은 히스토리 기능이 없다.

```bash
|        |        -----
|        |          A
|        |          |  1000
|        |          V
+--------+       ------
        ~/.bash_history
```

```bash
HISTSIZE              /* 히스토리를 기록하는 스택의 크기를 지정 */
HISTFILE              /* 히스토리 내용을 지속적으로 저장하는 파일 이름 지정 */
                      /* 기본값: ~/.bash_history */
HISTFILESIZE          /* 히스토리파일의 크기 지정 */
```

```bash
# grep -i histsize /etc/profile
HISTSIZE=1000
# history | less /* 현재까지 사용한 스택에 들어간 명령이 출력 */
1  ifconfig
    2  ping 163.126.63.1
    3  ping 168.126.63.1
    4  vi /etc/sysconfig/network-scripts/ifcfg-eth0
    5  vi /etc/sysconfig/network-scripts/ifcfg-eth1
    6  vi /etc/hosts
    7  vi /etc/resolv.conf
....
# history -c /* (clear) 현재까지 사용한 명령을 삭제 */
# history
```

history -c

```bash
비밀번호등을 설정한 후
# history -c /*지금까지 사용한 명령어 히스토리를 삭제*/
쉘 껐다 키기
# history    /*방금 쉘에서 삭제했던 기록은 빼고 나머지 history만 존재한다*/
```

## alias

별칭(Alias)

사용이유: 명령어를 편리하게 사용하기 위해서

명령어 체계에서 alias가 제일 먼저 검색된다.

```bash
# alias cp='cp –i'
# alias   (# alias cp)
# unalias cp     < cp로 등록되어 있는 alias 해제 

# alias cp='cp –i'
# alias mv='mv –i'
# alias rm='rm –i'

# alias vi='/usr/bin/vim'
# alias pps='ps –ef | head –1 ; ps –ef | grep $1'

[EX1] 별칭 테스트
# alias a='cd /test && rm –rf /test/*'
# alias b='cp /etc/passwd file1 ; cp file1 file2 ; cp file1 file3'
# a
# b
# ls

```

```bash
PATH
명령어를 순차적으로 검사하다가 처음 나온 명령어를 선택, 실행

명령어 실행 단계
alias
PATH -> PATH에 등록된 순서대로 실행되며 나머지는 무시한다.

현재 디렉토리
```

문제

```bash
1. /test 디렉토리의 파일과 디렉토리 개수 확인하기
# find /test -type f | wc -l
397600
# find /test -type d | wc -l
201501

2. /test 디렉토리 내의 파일중에 용량이 1G이상으로서 team01 계정의 권한으로 설정되어 있는 
파일을 검색하여 자동 삭제하기
# find /test -size +1G -user team01 -exec rm -fv {} \;

3. /test 디렉토리의 파일에서 system 문자가 들어있는 모든 파일을 찾고 해당 파일들의 목록을 
/training 디렉토리에 exam1로 저장한다.
# mkdir /training
# grep -lr system /test > /training/exam1
/test/030/51/27/file27
/test/100/23/file23

4. /test 디렉토리에서 setUID가 설정되어 있는 파일 찾기
# find /test -perm -4000
/test/046/47/37/file37

5. /test 디렉토리의 모든 디렉토리의 소유자를 team33 그룹소유자를 team50으로 변경
> 해당 작업을 하면서 출력 로그를 확인하면서 바로 저장한다. + 에러결과를 따로 저장한다.
# find /test -type d -exec chown team33.team50 {} \; > num05.log

6./test 디렉토리의 모든 파일을 소유자 team02 그룹소유자를 team50으로 변경
> 해당 작업을 하면서 출력 로그를 확인하면서 바로 저장한다. + 에러 결과를 같이 저장한다.
# find /test -type f -exec chown team02.team50 {} \; &> num06.log

7. /goott 디렉토리에 team001계정이 접근하여 읽기 쓰기가 가능하도록 소유자 정보가 아닌 
권한정보를 변경하기
# chmod 777 /goott

8. 쓸데없이 용량을 사용중인 디렉토리 찾기

```

문제풀이

```bash
1. /test 디렉토리의 파일과 디렉토리 개수 확인하기
# find /test -type f | wc -l
397600
# find /test -type d | wc -l
201501
# find /test -type f -or -type d | wc -l
599101

2. /test 디렉토리 내의 파일중에 용량이 1G이상으로서 team01 계정의 권한으로 설정되어 있는 
파일을 검색하여 자동 삭제하기
# find /test -size +1G -user team01 -exec rm -fv {} \;
removed '/test/004/28/26/file26'
removed '/test/084/32/22/file22'

3. /test 디렉토리의 파일에서 system 문자가 들어있는 모든 파일을 찾고 해당 파일들의 목록을 
/training 디렉토리에 exam1로 저장한다.
# mkdir /training
# grep -lr system /test > /training/exam1
/test/030/51/27/file27
/test/100/23/file23
# find /test -type f -exec grep -l system {} \; > /training/exam1

4. /test 디렉토리에서 setUID가 설정되어 있는 파일 찾기
# find /test -perm -4000 -exec ls -l {} \;
-rwsr-xr-x. 1 root root 0 Jul  7 22:24 /test/046/47/37/file37

5. /test 디렉토리의 모든 디렉토리의 소유자를 team33 그룹소유자를 team50으로 변경
> 해당 작업을 하면서 출력 로그를 확인하면서 바로 저장한다. + 에러결과를 따로 저장한다.
# cat /etc/passwd | grep team33
# cat /etc/gorup | grep team50
# find /test -type d -exec chown -v team33.team50 {} \; 2>> /root/error.log | tee -a /root/chowncheck.log

6./test 디렉토리의 모든 파일을 소유자 team02 그룹소유자를 team50으로 변경
> 해당 작업을 하면서 출력 로그를 확인하면서 바로 저장한다. + 에러 결과를 같이 저장한다.
# cat /etc/passwd | grep team02
# cat /etc/gorup | grep team50
# find /test -type f -exec chown -v team02.team50 {} \; 2>&1 | tee -a /rrot/filechown.log

7. /goott 디렉토리에 team001계정이 접근하여 읽기 쓰기가 가능하도록 소유자 정보가 아닌 
권한정보를 변경하기
# mkdir /goott
# cat /etc/passwd | grep team001
# user add team001
# echo team001 | passwd --stdin team001
# history -c
# chmod 777 /goott

8. 쓸데없이 용량을 사용중인 디렉토리 찾기
# du -sh /* 2> /dev/null
0	/bin
119M	/boot
0	/dev
28M	/etc
0	/goott
632K	/home
0	/lib
0	/lib64
0	/media
0	/mnt
0	/opt
0	/proc
1.1G	/root
9.3M	/run
0	/sbin
0	/srv
0	/sys
22M	/test
4.0K	/tmp
4.0K	/training
3.7G	/usr
163M	/var
# du -sh /* 2> /dev/null
# cd 
# du .
4	./.cache/dconf
4	./.cache
4	./.dbus/session-bus
4	./.dbus
0	./.config/ibus/bus
0	./.config/ibus
60	./.config/pulse
60	./.config
4	./bin
1082392	./.hidden
1082504	.
# cd .hidden/
# ls -l | wc -l
# rm -rf *
```

## rich-rule

## 게이트웨이 구성하기

> 사전구성

게이트웨이로 사용될 서버의 전원을 종료

NIC 추가 장착

```
VMware > VM > Settings > Add > Network Adapter > NAT 방식
```

기존의 IP 정보를 먼저 삭제

**[SERVER3]# nmcli con show**

```
NAME                UUID                                  TYPE      DEVICE 
**~~Wired connection 1  599d677d-5d43-34e5-9d43-91079ba2522b  ethernet  ens37   이전버전~~**
ens33               c611c1f2-ea20-41a0-a5b1-4c98ce0e789a  ethernet  ens33
```

**[SERVER3]# nmcli con delete "Wired connection 1"**

```
연결 'Wired connection 1'(599d677d-5d43-34e5-9d43-91079ba2522b)이(가) 성공적으로 삭제되었습니다.
```

**[SERVER3]# nmcli dev status**

```
DEVICE  TYPE      STATE          CONNECTION 
ens33   ethernet  연결됨           ens33      
**ens37   ethernet  연결 끊겼음       --**         
lo      loopback  관리되지 않음      --
```

**[SERVER3]# nmcli con add con-name ens37 ifname ens37 type ethernet ipv4.method manual autoconnect yes ipv4.addresses 192.168.20.220/24**

```
연결 'ens37' (6570c608-ade4-46d2-bda2-03b60b404329)이 성공적으로 추가되었습니다.
```

**[SERVER3]# nmcli con show**

```
NAME   UUID                                  TYPE      DEVICE 
ens33  c611c1f2-ea20-41a0-a5b1-4c98ce0e789a  ethernet  ens33  
ens37  6570c608-ade4-46d2-bda2-03b60b404329  ethernet  ens37
```

**[SERVER3]# nmcli con up ens37**

```
연결이 성공적으로 활성화되었습니다 (D-Bus 활성 경로: /org/freedesktop/NetworkManager/ActiveConnection/6)
```

**[SERVER3]# ifconfig**

**[SERVER3]# nmcli con show ens37 | egrep -i '(ipv4.address|ipv4.dns|ipv4.gateway)'**

```
ipv4.dns:                               --
ipv4.dns-search:                        --
ipv4.dns-options:                       --
ipv4.dns-priority:                      0
ipv4.addresses:                         192.168.20.220/24
ipv4.gateway:                           --
```

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/59b87009-4129-4c98-b588-3e58338bad8c/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/59b87009-4129-4c98-b588-3e58338bad8c/Untitled.png)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/609945bb-5e47-48af-8796-470d05dd9512/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/609945bb-5e47-48af-8796-470d05dd9512/Untitled.png)

SERVER4 Network Adapter를 Host-only로 바꾼다. (반드시 SERVER3과 동일한것)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c1fb24ab-44a7-4918-ab75-965adfd40ad1/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c1fb24ab-44a7-4918-ab75-965adfd40ad1/Untitled.png)

SERVER3 Network Adapter를 Host-only로 바꾼다.

> 클라이언트 서버의 IP 변경

[SERVER4]# nmcli con mod ens33 ipv4.addresses 192.168.20.230/24 ipv4.gateway 192.168.20.220

[SERVER4]# ifconfig

```
ens33:
inet 192.168**.20.230**  netmask 255.255.255.0  broadcast 192.168.20.255
```

[SERVER4]# nmcli con down ens33 ; nmcli con up ens33

현재 SERVER4는 SERVER3의 게이트웨이 까지는 통신이 정상적으로 이후어 지지만 그외 외부로 나가는 통신에 대해서는 불가능하다. 

[SERVER4]# ping 192.168.20.220 > 간다.

[SERVER4]# ping 192.168.10.2

[SERVER4]# ping 8.8.8.8 > 안간다.

[SERVER4]# ping 192.168.10.220 > 간다.

현재 되면 안되는 통신까지 이루어지는 상태이다. 이것을 차단하고 실습을 재개하자.

SERVER3에서 NAT기능을 활성화 하여 SERVER4의 192.168.20.0 네트워크가 정상적으로 외부 통신을 할 수 있도록 구성해주자.

## 마스커레이딩 설정 = 방화벽 NAT설정

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/543e1c3b-8f29-48da-8be9-d6cd050e27f1/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/543e1c3b-8f29-48da-8be9-d6cd050e27f1/Untitled.png)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/06f048b6-31ce-48dc-81f5-e6ea4f08a002/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/06f048b6-31ce-48dc-81f5-e6ea4f08a002/Untitled.png)

### IP Forwarding 기능 ON = ip를 넘겨주는 기능 NAT기능 추가

/etc/sysctl.conf : 커널 패러미터(Kernel Parameter)가 들어 있다.

[참고] /etc/sysctl.conf 파일을 설정 하고 적용

```
# vi /etc/sysctl.conf ★★★★★
(커널이 읽는 파일 설정주의)
# sysctl -p 
or
# sysctl -w net.ipv4.ip_forward=1
# sysctl -p
-p 적용옵션

**> 이것은 이전 방식이기 때문에 현재는 이렇게 사용하지 않습니다.**
```

### NAT 설정하기

방화벽 구성

커널파라미터를 수정하여 패킷 포워딩 기능을 활성화

[SERVER3]# sysctl -a | grep -i ipv4.ip

**[SERVER3]# echo "net.ipv4.ip_forward = 1" > /etc/sysctl.d/ip_forward.conf**

**[SERVER3]# sysctl -p /etc/sysctl.d/ip_forward.conf**

```
net.ipv4.ip_forward = 1
```

**[SERVER3]# cat /proc/sys/net/ipv4/ip_forward**

```
1
```

```bash
영역 이름 기본 구성
trusted
			들어오는 모든 트래픽을 허용합니다.
home 
			나가는 트래픽과 관련이 없거나 사전 정의 서비스인 ssh, mdns, ipp-client, samba-client 또는 dhcpv6-client와 일치하지 않을 경우 들어오는 트래픽을 거부합니다.
internal 
			나가는 트래픽과 관련이 없거나 사전 정의 서비스( home(집) 영역으로 시작하는 것은 동일)인 ssh, mdns, ipp-client, samba-client 또는 dhcpv6-client 와 일치하지 않을 경우 들어오는 트래픽을 거부합니다
work 
			나가는 트래픽과 관련이 없거나 사전 정의 서비스인 ssh, ipp-client 또는 dhcpv6-client와 일치하지 않을 경우 들어오는 트래픽을 거부합니다.
public 
			나가는 트래픽과 관련이 없거나 사전 정의 서비스인 ssh 또는 dhcpv6-client와 일치하지 않을 경우 들어오는 트래픽을 거부합니다. 새로 추가된 네트워크 인터페이스의 기본 영역입니다.
external 
			나가는 트래픽과 일치하지 않거나 사전 정의 서비스인 ssh와 일치하지 않을 경우 들어오는 트래픽을 거부합니다. 이 영역을 통해 전달되어 나가는 IPv4 트래픽은 나가는 네트워크 인터페이스의 IPv4 주소에서 시작된 것처럼 마스커레이드됩니다.
dmz 
			나가는 트래픽과 일치하지 않거나 사전 정의 서비스인 ssh와 일치하지 않을 경우 들어오는 트래픽을 거부합니다.
block 
			나가는 트래픽과 관련되지 않은 경우 들어오는 모든 트래픽을 거부합니다.
drop 
			나가는 트래픽과 관련되지 않은 경우(ICMP 오류에도 대응하지 않음) 들어오 는 모든 트래픽을 거부합니다.
```

방화벽을 사용하여 외부와 내부 존을 변경하고 각 **존을 연결시켜 주는 작업** 을 진행

[SERVER3]# firewall-cmd --get-active-zones 

```bash
libvirt
  interfaces: virbr0
public
  interfaces: ens33 ens37
```

**[SERVER3]# nmcli con mod ens33 connection.zone external**

**[SERVER3]# nmcli con mod ens37 connection.zone internal**

**[SERVER3]# firewall-cmd --get-active-zones**

```
external
  interfaces: ens33
internal
  interfaces: ens37
libvirt
  interfaces: virbr0
```

[SERVER3]# nmcli con show ens33 | grep zone

```bash
connection.zone: external
```

**[SERVER3]# firewall-cmd --zone=external --add-masquerade --permanent**

```
Warning: ALREADY_ENABLED: masquerade
success
```

[SERVER3]# firewall-cmd --reload

```
success
```

다른 장애 사항이 없다면 SERVER4이 SERVER3의 게이트웨이를 통하여 정상적으로 통신할 수 있다.

[SERVER3]# firewall-cmd --get-zones

```bash
block dmz drop external home internal libvirt nm-shared public trusted work
```

[SERVER3]# firewall-cmd --get-active-zones

```bash
external
  interfaces: ens33
internal
  interfaces: ens37
```

[SERVER3]# firewall-cmd --zone=internal --list-all

```bash
internal (active)
  target: default
  icmp-block-inversion: no
  interfaces: ens37
  sources: 
  services: cockpit dhcpv6-client mdns samba-client ssh
  ports: 
  protocols: 
  masquerade: no
  forward-ports: 
  source-ports: 
  icmp-blocks: 
  rich rules:
```

[SERVER3]# firewall-cmd --zone=external --list-all

```bash
external (active)
  target: default
  icmp-block-inversion: no
  interfaces: ens33
  sources: 
  services: ssh
  ports: 
  protocols: 
  masquerade: yes
  forward-ports: 
  source-ports: 
  icmp-blocks: 
  rich rules:
```

[SERVER4]# ping www.google.com

정상적으로 작동함을 확인

# DHCP

# 단원목표

---

- DHCP 개요
- DHCP 서버
- DHCP 클라이언트
- DHCP 서버 실습

---

공유기 안의 스위치 기능, 라우팅 기능, UTM 기능, 연결만 하면 자동으로 IP를 받아오는 기능(DHCP)을 한다.

# DHCP(Dynmic Host Configuration Protocol) 개요

(1) DHCP 관련 용어

■ DHCP(**D**ynamic **H**ost **C**onfiguration **P**rotocol)

- **http://www.ietf.org/rfc/rfc1541.txt**

DHCP[디에이치씨피]는 네트웍 관리자들이 조직 내의 네트웍 상에서 **IP 주소를 중앙에서 관리하고 할당해줄 수 있도록 해주는 프로토콜**이다. 

인터넷의 TCP/IP 프로토콜에서는, 각 컴퓨터들이 고유한 IP 주소를 가져야만 인터넷에 접속할 수 있다. 조직에서 컴퓨터 사용자들이 인터넷에 접속할 때, IP 주소는 각 컴퓨터에 반드시 할당되어야만 한다. DHCP를 사용하지 않는 경우에는, 각 컴퓨터마다 IP 주소가 수작업으로 입력되어야만 하며, 만약 컴퓨터가 네트웍의 다른 부분에 속한 장소로 이동되면 IP 주소를 새로이 입력해야 한다. DHCP는 네트웍 관리자가 중앙에서 IP 주소를 관리하고 할당하며, 컴퓨터가 네트웍의 다른 장소에 접속되었을 때 자동으로 새로운 IP 주소를 보내줄 수 있게 해준다.

DHCP는 주어진 IP 주소가 일정한 시간동안만 그 컴퓨터에 유효하도록 하는 "임대" 개념을 사용한다. 임대시간은 사용자가 특정한 장소에서 얼마나 오랫동안 인터넷 접속이 필요할 것인지에 따라 달라질 수 있다. DHCP는 사용자들이 자주 바뀌는 학교와 같은 환경에서 특히 유용하다. DHCP는 사용 가능한 IP 주소의 개수보다 더 많은 컴퓨터가 있는 경우에도 IP 주소의 임대시간을 짧게 함으로써 네트웍을 동적으로 재구성할 수 있다.

DHCP는 영구적인 IP 주소를 필요로 하는 웹서버에 대해서는 정적인 주소를 제공한다.

DHCP는 네트웍 IP 관리 프로토콜인 BOOTP의 대안으로 사용된다. DHCP가 더욱 진보된 프로토콜이지만, 두 개의 프로토콜 모두 일반적으로 사용된다. 어떤 조직에서는 두 개의 프로토콜 모두를 사용하지만, 동일한 조직에서 그것을 언제, 어떻게 사용할지를 이해하는 것이 무엇보다 중요하다. 윈도우NT와 같은 몇몇 운영체계에는 DHCP 서버가 딸려 나온다. DHCP 또는 BOOTP 클라이언트는 네트웍이 구성될 수 있도록 각 컴퓨터에 위치하는 프로그램이다.

■ BOOTP (Bootstrap Protocol) ; 초기 적재 통신 규약

- **http://www.ietf.org/rfc/rfc951.txt**

BOOTP는 네트웍 사용자가 자동으로 구성되고(IP 주소를 받게), 사용자의 관여 없이도 부트되는 운영체계를 가지고 있게 해주는 프로토콜이다. X 터미널 등과 같이 하드디스크를 갖지 않은 장치의 설정 정보를 자동적으로 할당, 관리하기 위해서 개발되었다. 네트웍 관리자에 의해 관리되는 BOOTP 서버는, 일정 시간동안 IP 주소를 자동으로 할당한다.

BOOTP는 좀더 진보된 네트웍 관리 프로토콜인 DHCP의 기반이 된다.

■ Static IP address / Dynamic IP address ; 고정 IP 주소와 유동 IP 주소

■ 고정 IP(Static IP) : IP를 직접 설정한 IP

■ 유동 IP(Dynamic IP) : DHCP 서버로 부터 IP를 부여 받은 경우의 IP

■ 사설 IP(Private IP) : 라우팅이 안되는 IP(EX: 172.16.X.X, 192.168.X.X) + **NAT**

■ 공인 IP(Public IP) : 라우팅이 되는 IP(EX: 203.1.1.5)

고정 IP 주소는 ISP에 의해 해당 사용자 전용으로 부여되는 인터넷 주소로서, 특별한 사유가 없는 한 늘 변하지 않고 사용되는 주소를 가리킨다. 인터넷 상에서 컴퓨터를 찾거나 서로간에 데이터를 주고받기 위해서는 IP 주소를 사용하는데, 이것은 사람들이 서로를 찾고 통화하는데 전화번호를 사용하는 것과 매우 비슷한 원리이다. 만약 누군가가 terms.co.kr을 방문하려면, 그의 컴퓨터가 DNS 서버에 terms.co.kr에 할당된 정확한 IP 주소를 물어 알아낸 다음, 이를 terms.co.kr 서버에 접속하기 위한 주소로 사용한다.

인터넷에 연결되는 모든 컴퓨터가 자신만의 고유한 고정 IP 주소를 가질 수 있다면 문제는 비교적 간단할 것이다. 그러나 처음 인터넷을 착상해 낼 당시에는, 지금처럼 엄청나게 많은 개수의 IP 주소가 필요할 것이라는 것을 미처 예상하지 못했다. 그 결과 우리가 현재 사용하고 있는 체계의 IP 주소는 이 세상의 모든 사람들에게 부여할 만큼 충분한 량이 아니라는 것이 드러나게 되었고, 이러한 주소 부족 문제를 타결하기 위해 많은 ISP들은 고정 IP 주소를 부여하는 것을 제한하고, DHCP 서버를 이용 필요할 때마다 임시적으로 IP 주소를 부여하였다가, 사용 후에는 회수하는 정책으로 선회하게 되었다. 이때 임시로 부여되는 IP 주소가 바로 유동 IP 주소인 것이다.

DHCP 서버에 요청하면 특정 인터넷 세션 또는 정해진 시간 동안만 임시로 쓸 수 있는 IP 주소를 받게 된다. 그러나, 그 사용자가 인터넷으로부터 접속을 끊으면, 유동 IP 주소는 IP 주소 저장소로 회수되어, 필요한 경우 다른 사용자에게 할당할 수 있는 상태가 된다. 만약 조금 전의 그 사용자가 인터넷에 즉시 다시 연결을 할지라도, 아까 사용했던 IP 주소를 다시 할당받을 확률은 낮다. 이것을 기존의 전화 시스템에 비유한다면, 유동 IP 주소를 사용하는 것은 마치 공중전화를 이용해 전화를 하는 것과 비슷하다. 전화하는 사람의 입장에서는, 전화를 받아야 하는 경우를 제외하고는 어떤 전화번호를 이용하여 전화를 하게 되든지 결과적으로는 별 다른 점이 없기 때문이다.

그러나 때로 유동 IP 주소를 사용하여 인터넷에 접속하는 사용자를 다른 컴퓨터들이 찾아야 할 경우가 있을 수 있다. 또는 반드시 고정 IP 주소가 필요한 CU-SeeMe를 쓰거나 또는 VoIP를 이용한 인터넷 전화를 쓰려는 경우도 있을 수 있다. 이러한 사용자들에게는 대개 두 가지 선택방안이 있는데, ISP에게 연락하여 고정 IP 주소를 달라고 요청하거나, 또는 동적 DNS 서비스를 사용하거나 둘 중 하나이다. 아마도 둘 중 어떤 것을 선택하든지 부가적인 월 사용료를 지불해야만 할 것이다.

(2) DHCP 동작 원리

■ DHCP Server/Client IP 할당 과정

```bash
  ----+------------------------------+----
	    |                              |
	 dhcpd(67)                    dhclient(68)
	DHCP Server                   DHCP Client
	 
	 
	<DHCP Server>                 <DHCP Client>
	  dhcpd(67)                    dhclient(68)
	     |       DHCP Discover        	|
	     |   <-----------------------  	|
	     |       DHCP Offer           	|
	     |   -----------------------> 	|
	     |       DHCP Request         	|
	     |   <----------------------- 	|
	     |       DHCP Acknowledge 	    |
	     |   -----------------------> 	|
	     |                             	|
```

```bash
DHCP Discover [client]
	DHCP를 찾기 위해 DHCP서버를 찾는 메시지를 브로드캐스트로 전송
DHCP Offer [server]
	DHCP 서버가 아닌 컴퓨터들은 클라이언트 보낸 DHCP Discover 메시지를 무시
	DHCP 서버의 경우에는 DHCP 서비스의 정보가 담긴 내용을 같이 클라이언트에게 전송 메시지 -> DHCP Offer
DHCP Request [client]
	Client는 IP주소, 서비스 정보를 이용하여 네트워크 설정을 하고 DHCP 서버에 사용을 위한 DHCP Request 메시지를 전송한다.
	L3
DHCP Acknowledge [server]
	사용허가. DHCP 클라이언트는 DHCP 서버에서 보내준 정보(IP, DNS, Gateway, 임대정보) 설정
```

DHCP 클라이언트가 부팅할때 DHCP 서버와 연동하는 동작과정을 살펴보면 다음과 같다.

- DHCP 클라이언트는 부팅하면서 현재 네트워크 안에 DHCP 서버가 있는지를 찾기 위해 "DHCP Discover"메시지를 같은 서브넷에 있는 모든 시스템으로 브로드캐스트한다.
- DHCP 클라이언트로 부터 메시지를 받은 DHCP 서버에서는 네트워크 서비스 정보를 담은 "DHCP Offer" 메시지를 DHCP 클라언트에게 전송한다.
- DHCP 서버로 부터 "DHCP Offer" 메시지를 받은 클라이언트는 메시지에 포함되어 있는 IP 주소와 서비스 정보를 이용하여 네트워크 설정을 한 후, DHCP 서버에 사용 의사를 알리는 "DHCP Request" 메시지를 DHCP 서버로 보내게 된다.
- "DHCP Request" 메시지를 수신한 DHCP 서버는 "DHCP Acknowledge" 메시지를 통해 사용 허가를 해주게 되고, DHCP 클라이언트는 DHCP 서버에서 보내준 정보(IP, DNS, Gateway, ...) 정보를 받아서 설정하게 된다.

■ DHCP Server & BOOTP Relay & DHCP Client

DHCP 서버에 BOOT Relay 서버가 존재하는 경우에 동작 방식도 없는 경우와 흡사하게 동작한다. 중간에 BOOT Relay(DHCP Relay Agent) 서버가 DHCP 서버의 역할을 중계하게 된다. 이 문서에서는 DHCP Relay Agent에 관련에 관련한 내용은 다루지 않는다.

```bash
<DHCP Server> ----Router----+-----------------+----- 
                            |    	     	  |
                            |         	  |
                          BOOTP Relay     <DHCP Client>
                          Server 
 
<DHCP Server>       <BOOTP Relay>        <DHCP Client>
     |                    	|   DHCP Discover	  |
     |                    	| <--------------	  |
     |    DHCP Discover   	|               	  |
     | <------------------	|                	  |
     |    DHCP Offer      	|                	  |
     | ------------------>	| -------------->	  |
     |                    	|    DHCP Request	  |
     | <------------------	| <--------------	  |
     |    DHCP ACK        	|                	  |
     | ------------------>	| -------------->	  |
     |                    	|                	  |
```

- 기본적으로 DHCP 서버는 DHCP 클라이언트와 같은 네트워크 대역에 존재해야 한다. 이유는 클라이언트가 IP가 없기 때문에 TCP/IP 통신을 할 수는 없어서, 네트워크를 넘을 수 없기 때문이다.
- 하지만, 일반 가정집 마다 DHCP 서버가 존재하는 것은 아니다. 이것은 BOOT Relay 기능을 Cable Modem등이 포함하고 있기 때문이다.
- DHCP 서버가 한개의 네트워크 안에는 한대 존재해야 네트워크를 관리할 수 있다. 만약, 한개의 네트워크 안에 여러개의 DHCP 서버가 존재한다면, DHCP 클라이언트를 부팅시에 DHCP 서버중 한대의 서버로 부터 설정 정보(IP 관련 정보 + 부가적인 정보)를 받는다.
- 그럼, 한개의 네트워크의 IP 관리를 하기 어렵다. (여러대의 DHCP 서버로 관리 하기 어려움)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f77c6116-5e1b-431a-a139-6e4f28af269c/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f77c6116-5e1b-431a-a139-6e4f28af269c/Untitled.png)

[SERVER1] NAT 네트워크 DHCP 체크 해제 후 Apply → OK

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d481720e-d632-44a2-92d4-ca2f3f0c87e4/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d481720e-d632-44a2-92d4-ca2f3f0c87e4/Untitled.png)

모두 Auto로 설정

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7b9f179a-8927-4741-b3e0-67e57d21b237/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7b9f179a-8927-4741-b3e0-67e57d21b237/Untitled.png)

ens33 down up이 안되는 모습

SERVER1,2,3,4 → snapshot 돌리기

[SERVER1]# dnf list

# DHCP(Dynmic Host Configuration Protocol) 서버

DHCP 사용 이유: 과거에는 IP 부족 현상을 보상하기 위해서. 현재는 효율적인 IP 관리를 위해서.

■ DHCP 서버가 제공하는 기능

- IP와 관련된 값(EX: IP/Netmask)

- 부가적인 정보(EX: Router IP, DNS Server IP, boot server IP, 벤더 정보 등)

■ DHCP 서버 용도

- (예전) IP 부족 현상을 보상하기 위해서

(EX) DHCP, 사설 IP, IPv6

- (현재) 효율적인 IP 관리**(보안)**, 노트북/핸드폰(무선 AP**(관리)**)

```bash
패키지: dhcp                                 패키지: dhcp-client
	----- DHCP Server -----			             ----- DHCP Client -----

	    dhcpd(67)				                           dhclient(68)
	 /etc/dhcpd.conf                           /etc/dhclient.conf
	-----------------------			              -----------------------

[그림] DHCP 서버/DHCP 클라이언트 구조
```

(1) DHCP 서버 기본적인 정보 확인

```bash
① DHCP 패키지 확인
# rpm -qa | grep dhcp 
dhcp-libs-4.2.5-77.el7.centos.x86_64
dhcp-common-4.2.5-77.el7.centos.x86_64

-> dhcp 서버 패키지가 설치되어 있지 않다.

# dnf search dhcp
# dnf info dhcp-server
② DHCP 서버용 설치 패키지 목록 확인 
	(주의) 필요하면 설정
	# vi /etc/resolv.conf 
	nameserver 168.126.63.1

[SERVER4]# dnf list | grep dhcp
dhcp-client.x86_64                                   12:4.3.6-40.el8                                  @BaseOS   
dhcp-common.noarch                                   12:4.3.6-40.el8                                  @BaseOS   
dhcp-libs.x86_64                                     12:4.3.6-40.el8                                  @BaseOS   
dhcp-libs.i686                                       12:4.3.6-40.el8                                  BaseOS    
dhcp-relay.x86_64                                    12:4.3.6-40.el8                                  BaseOS    
**dhcp-server.x86_64**                                   12:4.3.6-40.el8                                  BaseOS    
dhcpd-pools.x86_64                                   3.0-3.el8                                        epel      
dhcping.x86_64                                       1.2-23.el8                                       epel      
nagios-plugins-dhcp.x86_64                           2.3.3-4.el8                                      epel

③ DHCP 서버 패키지 설치
[SERVER4]# dnf -y install dhcp-server
마지막 메타 데이터 만료 확인 : 0:08:00 전에 2020년 07월 20일 (월) 오후 08시 15분 19초.
Dependencies resolved.
==============================================================================================================================
 Package                        Architecture              Version                             Repository                 Size
==============================================================================================================================
Installing:
 dhcp-server                    x86_64                    12:4.3.6-40.el8                     BaseOS                    529 k

Transaction Summary
==============================================================================================================================
설치  1 Package

Total download size: 529 k
Installed size: 1.2 M
패키지 다운로드중:
dhcp-server-4.3.6-40.el8.x86_64.rpm                                                           6.9 MB/s | 529 kB     00:00    
------------------------------------------------------------------------------------------------------------------------------
합계                                                                                          833 kB/s | 529 kB     00:00     
트랜잭션 점검 실행 중
트랜잭션 검사가 성공했습니다.
트랜잭션 테스트 실행 중
트랜잭션 테스트가 완료되었습니다.
거래 실행 중
  준비 중입니다  :                                                                                                        1/1 
  스크립틀릿 실행: dhcp-server-12:4.3.6-40.el8.x86_64                                                                     1/1 
  Installing     : dhcp-server-12:4.3.6-40.el8.x86_64                                                                     1/1 
  스크립틀릿 실행: dhcp-server-12:4.3.6-40.el8.x86_64                                                                     1/1 
  확인 중        : dhcp-server-12:4.3.6-40.el8.x86_64                                                                     1/1 

설치됨:
  dhcp-server-12:4.3.6-40.el8.x86_64                                                                                          

완료되었습니다!

④ 설치된 패키지의 파일 목록 확인 
# rpm -ql dhcp-server           (# rpm -qli dhcp)
/etc/NetworkManager
/etc/NetworkManager/dispatcher.d
/etc/NetworkManager/dispatcher.d/12-dhcpd
/etc/dhcp
/etc/dhcp/dhcpd.conf
/etc/dhcp/dhcpd6.conf
/etc/openldap/schema
/etc/openldap/schema/dhcp.schema
/etc/sysconfig/dhcpd
/usr/bin/omshell
/usr/lib/.build-id
/usr/lib/.build-id/2e
/usr/lib/.build-id/2e/845f6462d86bc7c4b4dd0c3b39d5d4840b7ab0
/usr/lib/.build-id/9e
/usr/lib/.build-id/9e/1000a64e25ee00f7f2a1f6577204ee4ec1fcce
/usr/lib/systemd/system/dhcpd.service
/usr/lib/systemd/system/dhcpd6.service
/usr/sbin/dhcpd
/usr/share/doc/dhcp-server
/usr/share/doc/dhcp-server/dhcp-lease-list.pl
/usr/share/doc/dhcp-server/dhcpd.conf.example
/usr/share/doc/dhcp-server/dhcpd6.conf.example
/usr/share/doc/dhcp-server/ldap
/usr/share/doc/dhcp-server/ldap/README.ldap
/usr/share/doc/dhcp-server/ldap/dhcp.schema
/usr/share/doc/dhcp-server/ldap/dhcpd-conf-to-ldap
/usr/share/man/man1/omshell.1.gz
/usr/share/man/man5/dhcpd.conf.5.gz
/usr/share/man/man5/dhcpd.leases.5.gz
/usr/share/man/man8/dhcpd.8.gz
/var/lib/dhcpd
/var/lib/dhcpd/dhcpd.leases
/var/lib/dhcpd/dhcpd6.leases

⑤ DHCP 서비스 포트 확인
# grep bootp /etc/services 
bootps          67/tcp                          # BOOTP server
bootps          67/udp
bootpc          68/tcp          dhcpc           # BOOTP client
bootpc          68/udp          dhcpc
nuts_bootp      4133/tcp                        # NUTS Bootp Server
nuts_bootp      4133/udp                        # NUTS Bootp Server

# grep dhcp /etc/services 
bootpc          68/tcp          dhcpc           # BOOTP client
bootpc          68/udp          dhcpc
dhcpv6-client   546/tcp
dhcpv6-client   546/udp
dhcpv6-server   547/tcp
dhcpv6-server   547/udp
dhcp-failover   647/tcp                         # DHCP Failover
dhcp-failover   647/udp                         # DHCP Failover
dhcp-failover2  847/tcp                         # dhcp-failover 2
dhcp-failover2  847/udp                         # dhcp-failover 2
qip-qdhcp       2490/tcp                        # qip_qdhcp
qip-qdhcp       2490/udp                        # qip_qdhcp
```

(2) /etc/dhcpd.conf 파일 분석

```bash
# rpm -ql dhcp | grep conf
/etc/dhcp/dhcpd.conf
/etc/dhcp/dhcpd6.conf
/etc/sysconfig/dhcpd
/usr/share/doc/dhcp-4.2.5/dhcpd.conf.example
/usr/share/doc/dhcp-4.2.5/dhcpd6.conf.example
/usr/share/doc/dhcp-4.2.5/ldap/dhcpd-conf-to-ldap
/usr/share/man/man5/dhcpd.conf.5.gz

# cat /etc/dhcp/dhcpd.conf
#
# DHCP Server Configuration file.
#   see /usr/share/doc/dhcp*/dhcpd.conf.example
#   see dhcpd.conf(5) man page
#
#

# cp /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example /etc/dhcp/dhcpd.conf
cp: overwrite /etc/dhcp/dhcpd.conf? y

# vi /etc/dhcp/dhcpd.conf

# cat /etc/dhcpd.conf 
# dhcpd.conf
#
# Sample configuration file for ISC dhcpd
#

# option definitions common to all supported networks...
option domain-name "example.org";
option domain-name-servers ns1.example.org, ns2.example.org;

default-lease-time 600;
max-lease-time 7200;

# Use this to enble / disable dynamic dns updates globally.
#ddns-update-style none;

# If this DHCP server is the official DHCP server for the local
# network, the authoritative directive should be uncommented.
#authoritative;

# Use this to send dhcp log messages to a different log file (you also
# have to hack syslog.conf to complete the redirection).
log-facility local7;

# No service will be given on this subnet, but declaring it helps the 
# DHCP server to understand the network topology.

subnet 10.152.187.0 netmask 255.255.255.0 {
}

# This is a very basic subnet declaration.

subnet 10.254.239.0 netmask 255.255.255.224 {
  range 10.254.239.10 10.254.239.20;
  option routers rtr-239-0-1.example.org, rtr-239-0-2.example.org;
}

# This declaration allows BOOTP clients to get dynamic addresses,
# which we don't really recommend.

subnet 10.254.239.32 netmask 255.255.255.224 {
  range dynamic-bootp 10.254.239.40 10.254.239.60;
  option broadcast-address 10.254.239.31;
  option routers rtr-239-32-1.example.org;
}

# A slightly different configuration for an internal subnet.
subnet 10.5.5.0 netmask 255.255.255.224 {
  range 10.5.5.26 10.5.5.30;
  option domain-name-servers ns1.internal.example.org;
  option domain-name "internal.example.org";
  option routers 10.5.5.1;
  option broadcast-address 10.5.5.31;
  default-lease-time 600;
  max-lease-time 7200;
}

# Hosts which require special configuration options can be listed in
# host statements.   If no address is specified, the address will be
# allocated dynamically (if possible), but the host-specific information
# will still come from the host declaration.

host passacaglia {
  hardware ethernet 0:0:c0:5d:bd:95;
  filename "vmunix.passacaglia";
  server-name "toccata.fugue.com";
}

# Fixed IP addresses can also be specified for hosts.   These addresses
# should not also be listed as being available for dynamic assignment.
# Hosts for which fixed IP addresses have been specified can boot using
# BOOTP or DHCP.   Hosts for which no fixed address is specified can only
# be booted with DHCP, unless there is an address range on the subnet
# to which a BOOTP client is connected which has the dynamic-bootp flag
# set.
host fantasia {
  hardware ethernet 08:00:07:26:c0:a5;
  fixed-address fantasia.fugue.com;
}

# You can declare a class of clients and then do address allocation
# based on that.   The example below shows a case where all clients
# in a certain class get addresses on the 10.17.224/24 subnet, and all
# other clients get addresses on the 10.0.29/24 subnet.

class "foo" {
  match if substring (option vendor-class-identifier, 0, 4) = "SUNW";
}

shared-network 224-29 {
  subnet 10.17.224.0 netmask 255.255.255.0 {
    option routers rtr-224.example.org;
  }
  subnet 10.0.29.0 netmask 255.255.255.0 {
    option routers rtr-29.example.org;
  }
  pool {
    allow members of "foo";
    range 10.17.224.10 10.17.224.250;
  }
  pool {
    deny members of "foo";
    range 10.0.29.10 10.0.29.230;
  }
}

	ddns-update-style interim;
	동적 업데이트(Dynamic Update, Dynmic DNS) 기능을 사용할 수 있도록 지정하는 기능이다. 동적 업데이트 기능을 사용하지 않는다면 "ddns-update-style none;" 지정하면 된다. 
	ignore client-updates;
	
	subnet 192.168.0.0 netmask 255.255.255.0 {
	정보를 제공하는 네트워크 범위 지정: 192.168.0.0/255.255.255.0
	# --- default gateway
	        option routers                  192.168.0.1;    /* Default Router IP */
	        option subnet-mask              255.255.255.0;  /* Subnet Mask */
	
	        option nis-domain               "domain.org";   /* NIS Domain Name */
	        option domain-name              "domain.org";   /* DNS Domain Name */
	        DNS 서버는 필요하다면 여러대를 지정할 수도 있다.
	        options domain-name ns1.example.com ns2.example.com
	        option domain-name-servers      192.168.1.1;    /* DNS Server IP */
	
	        option time-offset              -18000; # Eastern Standard Time
	        "미국/동부"   타임 오프셋 (GMT - 5시간, -18000초 = -300분 = -5시간)
	        "아시아/서울" 타임 오프셋 (GMT + 9시간, 9시간 = 540분 = 32400초)
	#       option ntp-servers              192.168.1.1;
	#       option netbios-name-servers     192.168.1.1;
	# --- Selects point-to-point node (default is hybrid). Don't change this unless
	# -- you understand Netbios very well
	#       option netbios-node-type 2;
	
	        range dynamic-bootp 192.168.0.128 192.168.0.254; /* DHCP 서버 IP보유 영역 */
	        default-lease-time 21600;                        /* 21600초 = 360분 = 6시간 */
	        max-lease-time 43200;                            /* 43200초 = 720분 = 12시간 */
	
	        # we want the nameserver to appear at a fixed address
	        고정 IP 할당 지정
	        host ns {
	                next-server marvin.redhat.com;
	                hardware ethernet 12:34:56:78:AB:CD;
	                fixed-address 207.175.42.254;
	        }
	        host linux140 {
	                hardware ethernet 00:0C:29:EC:17:09;
	                fixed-address 10.100.0.2;
	        }
	}
```

```bash
subnet - 네트워크 할당 구역
netmask - IP를 얼마나 사용할 것인가
range 실제 할당할 IP의 구역
```

(2-1) /etc/dhcpd.conf 파일의 참고 패러미터/키워드

```bash
■ The ddns-update-style parameter

          ddns-update-style style;

          The style parameter must be one of ad-hoc, interim or none.  The ddns-update-
          style statement is only meaningful in the outer scope - it is evaluated  once
          after reading the dhcpd.conf file, rather than each time a client is assigned
          an IP address, so there is no way to use different DNS update styles for dif-
          ferent clients.

■ The ignore client-updates statement

       The first point to understand about this style of DNS update is that unlike  the
       ad-hoc  style, the DHCP server does not necessarily always update both the A and
       the PTR records.   The FQDN option includes a  flag  which,  when  sent  by  the
       client,  indicates  that the client wishes to update its own A record.   In that
       case, the server can be configured either to honor the  client’s  intentions  or
       ignore  them.    This  is  done  with the statement allow client-updates; or the
       statement ignore client-updates;.   By default, client updates are allowed.

■ The range statement

       range [ dynamic-bootp ] low-address [ high-address];

       For any subnet on which addresses will be assigned dynamically, there must be at
       least one range statement.   The range statement gives the lowest and highest IP
       addresses in a range.   All IP addresses in the range should be in the subnet in
       which the range statement is declared.   The dynamic-bootp flag may be specified
       if addresses in the specified range may be dynamically assigned to BOOTP clients
       as well as DHCP clients.   When specifying a single address, high-address can be
       omitted.

■ The default-lease-time statement

          default-lease-time time;

          Time should be the length in seconds that will be assigned to a lease if  the
          client requesting the lease does not ask for a specific expiration time.

■ The max-lease-time statement

          max-lease-time time;

          Time  should  be  the  maximum  length  in seconds that will be assigned to a
          lease.   The only exception to this is  that  Dynamic  BOOTP  lease  lengths,
          which are not specified by the client, are not limited by this maximum.

 ■ The next-server statement

          next-server server-name;

          The next-server statement is used to specify the host address of  the  server
          from  which the initial boot file (specified in the filename statement) is to
          be loaded.   Server-name should be a numeric IP address or a domain name.
```

(2-2) /etc/dhcpd.conf 파일안의 다른 내용 예

```bash
■ 서브넷 선언(Subnet Declaration)
subnet 192.168.1.0 netmask 255.255.255.0 {
	option routers 192.168.1.254;
	option subnet-mask 255.255.255.0;

	option domain-name "example.com";
	option domain-name-servers 192.168.1.1;

	option time-offset -18000; # Eastern Standard Time

	range 192.168.1.10 192.168.1.100;
}

■ 공유 네트워크 선언(Shared-network Declaration)

shared-network name {
	option domain-name "test.redhat.com";
	option domain-name-servers ns1.redhat.com, ns2.redhat.com;
	option routers 192.168.0.254;
	... more parameters for EXAMPLE shared-network ...
	subnet 192.168.1.0 netmask 255.255.252.0  {
		...parameters for subnet...
		range 192.168.1.1 192.168.1.254;
	}
	subnet 192.168.2.0 netmask 255.255.252.0  {
		...parameters for subnet....
		range 192.168.2.1 192.168.2.254;
	}
}

■ DHCP 서버를 통한 고정 IP 설정(Static IP Address using DHCP)

host linux140  {
	option host-name "linux140.example.com";
	hardware ethernet 00:A0:78:8E:9E:AA;
	fixed-address 192.168.1.4;
}
```

(2-3) /etc/dhcpd.conf 파일의 다른 예

```bash
# cat /etc/dhcpd.conf (동적 IP만 할당하는 DHCP 서버)
ddns-update-style none;
subnet 192.168.10.0 netmask 255.255.255.0 {
	range dynmic-bootp 192.168.10.100 192.168.10.199;
	option routers 192.168.10.2;
	option subnet-mask 255.255.255.0;
	option domain-name "linuxXXX.example.com";
	option domain-name-server 192.168.0.XXX;
	default-lease-time 21600;
}

# cat /etc/dhcpd.conf (고정 IP만 할당하는 DHCP 서버)
ddns-update-style none;
subnet 192.168.10.0 netmask 255.255.255.0 {
	option routers 192.168.10.2;
	option subnet-mask 255.255.255.0;
	option domain-name "linuxXXX.example.com";
	option domain-name-server 192.168.0.XXX;
	default-lease-time 21600;
	use-host-decl-names on;
}
host linux140 {
	hardware ethernet 00:a0:cc:37:38:88;
	fixed-address 192.168.10.100;
}
host linux144 {
	hardware ethernet 00:a0:cc:37:38:81;
	fixed-address 192.168.10.101;
}

[참고] DHCP 서버는 고정 IP(Static) + 동적 IP(Dynamic) 둘 다 할당이 가능하다.
```

(3) DHCP 서버 서비스 enable/disable

```bash
(현재)
# systemctl start dhcpd
# systemctl stop dhcpd
# systemctl restart dhcpd

(부팅)
# systemctl enable dhcpd

[EX] DHCP 서비스 enable
# systemctl start dhcpd

-> /etc/dhcp/dhcpd.conf 파일의 설정이 잘못 되어 있으면 FAIL 난다.

# pgrep -lf dhcpd 

# systemctl enable dhcpd
# systemctl is-enabled dhcpd
enable
```

# DHCP(Dynmic Host Configuration Protocol) 클라이언트

- DHCP 클라이언트는 dhclient 툴에 의해 /etc/dhclient.conf 파일을 참조하여 DHCP 서버로 부터 정보(IP 관련된 값과 부가적인 네트워크 정보)를 얻어 온다. /etc/dhclient.conf 파일은 기본적으로 존재하는 파일이 아니므로 /usr/share/doc/dhclient*/dhclient.conf.sample 파일을 복사해서 /etc/dhclient.conf 파일로 사용하면 된다. 그리고 /etc/dhclient.conf 파일이 존재하지 않는다고 해서 DHCP 클라이언트가 정상적으로 동작을 못하는 것은 아니다.
- DHCP 클라이언트는 DHCP 서버로 부터 lease 시간을 가지고 와서 /var/lib/dhclient/dhclient-eth#.leases 파일에 저장한다. (**dhcpd**(**/var/lib/dhcpd/dhcpd.leases**) -> **dhclient**(**/var/lib/dhclient/chclient-eth#.leases**)
- DHCP 클라이언트를 구성하기 위해서는 /etc/sysconfig/network-scripts/ifcfg-eth# 파일의 내용이 변경 되어야 한다. (예: BOOTPROTO=dhcp)
- **(주의)** 한개의 네트워크안에 DHCP 서버는 하나만 존재해야 한다. 따라서 Linux DHCP 서버와 VMWare DHCP 서버가 같은 네트워크에 존재하면 안된다. (**VMWare DHCP 반드시 !!!! 꺼두어야 한다.**)
- (참고) **http://isc.org/products/DHCP/**

■ DHCP 클라이언트 구성시 점검사항

```bash
(ㄱ) VMware NAT를 사용하는 경우 DHCP 서비스를 정지해야 한다.
```

# DHCP 서버 실습

```bash
(DHCP 서버)                                     (DHCP 클라이언트)
	-----------------+--------------------------+--------------
	                 |                        	|
	                 | SERVER4                	| SERVER3      
	         +-----eth0------+        	+--------eth0-----+
	         |192.168.10.230 |        	|           	    |
	         |               |        	|             	  |
	         |               |        	|               	|
	         |               |        	|               	|
	         |192.168.10.230 |       	  |DHCP Pool IP   	|
	         +---------------+        	+-----------------+
	 

[그림] DHCP 실습 구조
```

### [EX1] (DHCP 서버) DHCP 서버 구성(동적 IP 할당 방식, 유동 IP 할당 방식)

```bash
① 패키지 확인
[SERVER4]# rpm -qa | grep dhcp
dhcp-client-4.3.6-40.el8.x86_64
dhcp-common-4.3.6-40.el8.noarch
dhcp-libs-4.3.6-40.el8.x86_64
**dhcp-server-4.3.6-40.el8.x86_64**

② IP 설정 및 확인

[SERVER4]# ifconfig ens33 
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.10.230  netmask 255.255.255.0  broadcast 192.168.10.255
        inet6 fe80::89f1:7ac4:1a4a:7840  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:19:b1:27  txqueuelen 1000  (Ethernet)
        RX packets 14140  bytes 17637117 (16.8 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 7790  bytes 713245 (696.5 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

-> VMWare DHCP 서버가 자동으로 할당한 IP를 받았을 것이다.[ 아니면 수동 설정]
-> 혹시나 DHCP를 통하여 IP를 할당 받았다면 192.168.10.230으로 수동 설정 하기 바란다.

③ /etc/dhcp/dhcpd.conf 파일 편집
# vi /etc/dhcp/dhcpd.conf
# dhcpd.conf
#
# Sample configuration file for ISC dhcpd
#

# option definitions common to all supported networks...
#option domain-name "example.org";
#option domain-name-servers ns1.example.org, ns2.example.org;

default-lease-time 600;
max-lease-time 7200;

# Use this to enble / disable dynamic dns updates globally.
#ddns-update-style none;

# If this DHCP server is the official DHCP server for the local
# network, the authoritative directive should be uncommented.
#authoritative;

# Use this to send dhcp log messages to a different log file (you also
# have to hack syslog.conf to complete the redirection).
#log-facility local7;

# No service will be given on this subnet, but declaring it helps the 
# DHCP server to understand the network topology.

#subnet 10.152.187.0 netmask 255.255.255.0 {
#}

# This is a very basic subnet declaration.

#subnet 10.254.239.0 netmask 255.255.255.224 {
#  range 10.254.239.10 10.254.239.20;
#  option routers rtr-239-0-1.example.org, rtr-239-0-2.example.org;
#}

# This declaration allows BOOTP clients to get dynamic addresses,
# which we don't really recommend.

#subnet 10.254.239.32 netmask 255.255.255.224 {
#  range dynamic-bootp 10.254.239.40 10.254.239.60;
#  option broadcast-address 10.254.239.31;
#  option routers rtr-239-32-1.example.org;
#}
#
# A slightly different configuration for an internal subnet.
subnet 192.168.10.0 netmask 255.255.255.0 {
  range 192.168.10.50 192.168.10.90;
  option domain-name-servers ns1.example.com;
  option domain-name "example.com";
  option routers 192.168.10.2;
  option broadcast-address 192.168.10.255;
  default-lease-time 600;
  max-lease-time 7200;
}

# Hosts which require special configuration options can be listed in
# host statements.   If no address is specified, the address will be
# allocated dynamically (if possible), but the host-specific information
# will still come from the host declaration.

# host passacaglia {
#  hardware ethernet 0:0:c0:5d:bd:95;
#  filename "vmunix.passacaglia";
#  server-name "toccata.fugue.com";
#}

# Fixed IP addresses can also be specified for hosts.   These addresses
# should not also be listed as being available for dynamic assignment.
# Hosts for which fixed IP addresses have been specified can boot using
# BOOTP or DHCP.   Hosts for which no fixed address is specified can only
# be booted with DHCP, unless there is an address range on the subnet
# to which a BOOTP client is connected which has the dynamic-bootp flag
# set.
#host fantasia {
#  hardware ethernet 08:00:07:26:c0:a5;
#  fixed-address fantasia.fugue.com;
#}

# You can declare a class of clients and then do address allocation
# based on that.   The example below shows a case where all clients
# in a certain class get addresses on the 10.17.224/24 subnet, and all
# other clients get addresses on the 10.0.29/24 subnet.

#class "foo" {
#  match if substring (option vendor-class-identifier, 0, 4) = "SUNW";
#}

#shared-network 224-29 {
#  subnet 10.17.224.0 netmask 255.255.255.0 {
#    option routers rtr-224.example.org;
#  }
#  subnet 10.0.29.0 netmask 255.255.255.0 {
#    option routers rtr-29.example.org;
#  }
#  pool {
#    allow members of "foo";
#    range 10.17.224.10 10.17.224.250;
#  }
#  pool {
#    deny members of "foo";
#    range 10.0.29.10 10.0.29.230;
#  }
#}

# systemctl start dhcpd
# systemctl enable dhcpd
# firewall-cmd --permanent --add-service=dhcp
# firewall-cmd --reload

# pgrep -lf dhcpd 
11860 dhcpd

# tail -20 /var/log/messages    (# tail -20 /var/log/messages | grep dhcpd)
Jul 20 21:01:48 server4 systemd[1]: Stopping DHCPv4 Server Daemon...
Jul 20 21:01:48 server4 systemd[1]: Stopped DHCPv4 Server Daemon.
Jul 20 21:01:48 server4 systemd[1]: Starting DHCPv4 Server Daemon...
Jul 20 21:01:48 server4 dhcpd[1835]: Internet Systems Consortium DHCP Server 4.3.6
Jul 20 21:01:48 server4 dhcpd[1835]: Copyright 2004-2017 Internet Systems Consortium.
Jul 20 21:01:48 server4 dhcpd[1835]: All rights reserved.
Jul 20 21:01:48 server4 dhcpd[1835]: For info, please visit https://www.isc.org/software/dhcp/
Jul 20 21:01:48 server4 dhcpd[1835]: ldap_gssapi_principal is not set,GSSAPI Authentication for LDAP will not be used
Jul 20 21:01:48 server4 dhcpd[1835]: Not searching LDAP since ldap-server, ldap-port and ldap-base-dn were not specified in the config file
Jul 20 21:01:48 server4 dhcpd[1835]: Config file: /etc/dhcp/dhcpd.conf
Jul 20 21:01:48 server4 dhcpd[1835]: Database file: /var/lib/dhcpd/dhcpd.leases
Jul 20 21:01:48 server4 dhcpd[1835]: PID file: /var/run/dhcpd.pid
Jul 20 21:01:48 server4 dhcpd[1835]: Source compiled to use binary-leases
Jul 20 21:01:48 server4 dhcpd[1835]: Wrote 0 leases to leases file.
Jul 20 21:01:48 server4 dhcpd[1835]: Listening on LPF/ens33/00:0c:29:19:b1:27/192.168.10.0/24
Jul 20 21:01:48 server4 dhcpd[1835]: Sending on   LPF/ens33/00:0c:29:19:b1:27/192.168.10.0/24
Jul 20 21:01:48 server4 dhcpd[1835]: Sending on   Socket/fallback/fallback-net
Jul 20 21:01:48 server4 dhcpd[1835]: Server starting service.
Jul 20 21:01:48 server4 systemd[1]: Started DHCPv4 Server Daemon.

-> dhcpd 데몬이 restart 되면 그 기록이 /var/log/messages 파일에 남겨진다.

[참고]
두개이상의 인터페이스를 사용하는 경우 하나를 DHCP 배포 전용으로 사용하고 싶을때
 /etc/sysconfig/dhcpd 파일 편집
# vi /etc/sysconfig/dhcpd 
		# Command line options here
	DHCPDARGS=ens37         
	
	-> 만약 한개의 인터페이스쪽으로만 DHCP 서비스를 제공하기 위해서는 /etc/sysconfig/dhcpd 파일에 dhcpd 데몬이 
	   실행될 당시의 옵션으로 지정한다. 
	-> 여러개의 NIC 가지고 DHCP 제공하는 경우
	   # vi /etc/sysconfig/dhcpd
	   DHCPDARGS="ens33 ens37 ens38"
```

### [EX2] (DHCP Client) DHCP client 구성

```bash
SERVER3에서 작업한다.

[SERVER3]# ifconfig 
ens33      Link encap:Ethernet  HWaddr 00:0C:29:2C:B5:C7  
          inet addr:192.168.10.220  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::20c:29ff:fe2c:b5c7/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:295 errors:0 dropped:0 overruns:0 frame:0
          TX packets:377 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:34793 (33.9 KiB)  TX bytes:32599 (31.8 KiB)
          Interrupt:67 Base address:0x2000 

기존의 정보는 삭제하고 작업한다.
# nmtui

# nmcli con mod ens33 ipv4.method auto
# nmcli con down ens33
# nmcli con up ens33

# ping -c 1 192.168.10.200  (-c : count)

<------------------- (DHCP Server : /var/log/messages) ----------------------->

# cat /var/log/messages 
..... (중략) .....
Mar 24 08:28:20 linux250 dhcpd: DHCPDISCOVER from 00:0c:29:2c:b5:c7 via eth1
Mar 24 08:28:21 linux250 dhcpd: DHCPOFFER on 192.168.10.199 to 00:0c:29:2c:b5:c7 via eth1
Mar 24 08:28:21 linux250 dhcpd: DHCPREQUEST for 192.168.10.199 (192.168.10.250) from 00:0c:29:2c:b5:c7 via eth1
Mar 24 08:28:21 linux250 dhcpd: DHCPACK on 192.168.10.199 to 00:0c:29:2c:b5:c7 via eth1
..... (중략) .....

# ls -l /var/lib/dhcpd 
-rw-r--r-- 1 root root 650 Mar 24 08:28 dhcpd.leases
-rw-r--r-- 1 root root 473 Mar 24 08:28 dhcpd.leases~

# cat /var/lib/dhcpd/dhcpd.leases 

# All times in this file are in UTC (GMT), not your local timezone.   This is
# not a bug, so please don't ask about it.   There is no portable way to
# store leases in the local timezone, so please don't request this as a
# feature.   If this is inconvenient or confusing to you, we sincerely
# apologize.   Seriously, though - don't ask.
# The format of this file is documented in the dhcpd.leases(5) manual page.
# This lease file was written by isc-dhcp-V3.0.5-RedHat

lease 192.168.10.199 {
  starts 2 2010/03/23 23:28:21;
  ends 3 2010/03/24 05:28:21;
  binding state active;
  next binding state free;
  hardware ethernet 00:0c:29:2c:b5:c7;
}
```

### [EX3] (DHCP 서버) DHCP 서버 구성(동적 IP 할당 방식, 고정 IP 할당 방식)

```bash
① /etc/dhcpd.conf 파일 편집
# vi /etc/dhcpd.conf 
# dhcpd.conf
#
# Sample configuration file for ISC dhcpd
#

# option definitions common to all supported networks...
#option domain-name "example.org";
#option domain-name-servers ns1.example.org, ns2.example.org;

default-lease-time 600;
max-lease-time 7200;

# Use this to enble / disable dynamic dns updates globally.
#ddns-update-style none;

# If this DHCP server is the official DHCP server for the local
# network, the authoritative directive should be uncommented.
#authoritative;

# Use this to send dhcp log messages to a different log file (you also
# have to hack syslog.conf to complete the redirection).
#log-facility local7;

# No service will be given on this subnet, but declaring it helps the 
# DHCP server to understand the network topology.

#subnet 10.152.187.0 netmask 255.255.255.0 {
#}

# This is a very basic subnet declaration.

#subnet 10.254.239.0 netmask 255.255.255.224 {
#  range 10.254.239.10 10.254.239.20;
#  option routers rtr-239-0-1.example.org, rtr-239-0-2.example.org;
#}

# This declaration allows BOOTP clients to get dynamic addresses,
# which we don't really recommend.

#subnet 10.254.239.32 netmask 255.255.255.224 {
#  range dynamic-bootp 10.254.239.40 10.254.239.60;
#  option broadcast-address 10.254.239.31;
#  option routers rtr-239-32-1.example.org;
#}

# A slightly different configuration for an internal subnet.
subnet 192.168.10.0 netmask 255.255.255.0 {
  range 192.168.10.50 192.168.10.90;
  option domain-name-servers www.example.com;   //또는 192.168.10.200
  option domain-name "example.com";
  option routers 192.168.10.2;
  option broadcast-address 192.168.10.255;
  default-lease-time 600;
  max-lease-time 7200;
}

# Hosts which require special configuration options can be listed in
# host statements.   If no address is specified, the address will be
# allocated dynamically (if possible), but the host-specific information
# will still come from the host declaration.

#host passacaglia {
#  hardware ethernet 0:0:c0:5d:bd:95;
#  filename "vmunix.passacaglia";
#  server-name "toccata.fugue.com";
#}

# Fixed IP addresses can also be specified for hosts.   These addresses
# should not also be listed as being available for dynamic assignment.
# Hosts for which fixed IP addresses have been specified can boot using
# BOOTP or DHCP.   Hosts for which no fixed address is specified can only
# be booted with DHCP, unless there is an address range on the subnet
# to which a BOOTP client is connected which has the dynamic-bootp flag
# set.
#host fantasia {
#  hardware ethernet 08:00:07:26:c0:a5;
#  fixed-address fantasia.fugue.com;
#}

host server2.example.com {
  hardware ethernet 00:0c:29:5c:83:f4;       //mac address
  fixed-address 192.168.10.88;
}
#
# You can declare a class of clients and then do address allocation
# based on that.   The example below shows a case where all clients
# in a certain class get addresses on the 10.17.224/24 subnet, and all
# other clients get addresses on the 10.0.29/24 subnet.

#class "foo" {
#  match if substring (option vendor-class-identifier, 0, 4) = "SUNW";
#}

#shared-network 224-29 {
#  subnet 10.17.224.0 netmask 255.255.255.0 {
#    option routers rtr-224.example.org;
#  }
#  subnet 10.0.29.0 netmask 255.255.255.0 {
#    option routers rtr-29.example.org;
#  }
#  pool {
#    allow members of "foo";
#    range 10.17.224.10 10.17.224.250;
#  }
#  pool {
#    deny members of "foo";
#    range 10.0.29.10 10.0.29.230;
#  }
#}

/var/lib/dhcpd/dhcpd.leases < 중요한 파일

-> DHCP 서버쪽에서 DHCP 클라이언트쪽의 MAC 주소를 아는 방법
	# cat /var/lib/dhcpd/dhcpd.leases 
	or
	# ping 192.168.10.199 
	# arp -an | grep 192.168.10.199 

② 서비스 적용
# systemctl restart dhcpd

③ 로그 파일/leases 파일 확인
# tail -20 /var/log/messages   (# tail -f /var/log/messages)
Mar 24 09:01:20 linux250 dhcpd: Internet Systems Consortium DHCP Server V3.0.5-RedHat
Mar 24 09:01:20 linux250 dhcpd: Copyright 2004-2006 Internet Systems Consortium.
Mar 24 09:01:20 linux250 dhcpd: All rights reserved.
Mar 24 09:01:20 linux250 dhcpd: For info, please visit http://www.isc.org/sw/dhcp/
Mar 24 09:01:20 linux250 dhcpd: WARNING: Host declarations are global.  They are not limited to the scope you declared them in.
Mar 24 09:01:20 linux250 dhcpd: Wrote 0 deleted host decls to leases file.
Mar 24 09:01:20 linux250 dhcpd: Wrote 0 new dynamic host decls to leases file.
Mar 24 09:01:20 linux250 dhcpd: Wrote 1 leases to leases file.
Mar 24 09:01:20 linux250 dhcpd: Listening on LPF/eth1/00:0c:29:9b:6e:80/192.168.10/24
Mar 24 09:01:20 linux250 dhcpd: Sending on   LPF/eth1/00:0c:29:9b:6e:80/192.168.10/24
Mar 24 09:01:20 linux250 dhcpd: Sending on   Socket/fallback/fallback-net

# ls -l /var/lib/dhcpd 
-rw-r--r-- 1 root root 680 Mar 24 09:01 dhcpd.leases
-rw-r--r-- 1 root root 827 Mar 24 08:44 dhcpd.leases~

# cat /var/lib/dhcpd/dhcpd.leases 
아직 192.168.10.88은 배포가 되지 않았다.
```

### [EX4] (DHCP Client) DHCP 클라이언트 구성을 통한 고정 IP 구성

```bash
[server2]

# nmcli con down ens33 ; nmcli con up ens33
# ip addr show ens33
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:5c:83:f4 brd ff:ff:ff:ff:ff:ff
    inet 192.168.10.88/24 brd 192.168.10.255 scope global noprefixroute dynamic ens33
       valid_lft 474sec preferred_lft 474sec
    inet 192.168.10.252/24 brd 192.168.10.255 scope global secondary noprefixroute ens33
       valid_lft forever preferred_lft forever
    inet6 fe80::bb6c:8e6a:2b29:6949/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever

-> 고정아이피로 할당 받은것을 확인할 수 있다.

<------------------- (DHCP Server : /var/log/messages) ----------------------->

# tail -20 /var/log/messages 
Mar 24 12:59:56 linux250 dhcpd: DHCPREQUEST for 192.168.10.199 from 00:0c:29:a3:f8:2d via eth1: lease 
192.168.10.199 unavailable.
Mar 24 12:59:56 linux250 dhcpd: DHCPNAK on 192.168.10.199 to 00:0c:29:a3:f8:2d via eth1
Mar 24 12:59:59 linux250 dhcpd: DHCPDISCOVER from 00:0c:29:a3:f8:2d via eth1
Mar 24 12:59:59 linux250 dhcpd: DHCPOFFER on 192.168.10.1XX to 00:0c:29:a3:f8:2d via eth1
Mar 24 12:59:59 linux250 dhcpd: Dynamic and static leases present for 192.168.10.150.
Mar 24 12:59:59 linux250 dhcpd: Remove host declaration linxu240 or remove 192.168.10.150
Mar 24 12:59:59 linux250 dhcpd: from the dynamic address pool for 192.168.10/24
Mar 24 12:59:59 linux250 dhcpd: DHCPREQUEST for 192.168.10.1XX (192.168.10.250) from 00:0c:29:a3:f8:2d via eth1
Mar 24 12:59:59 linux250 dhcpd: DHCPACK on 192.168.10.1XX to 00:0c:29:a3:f8:2d via eth1

<------------------- (DHCP Server : /var/log/messages) ----------------------->

● DHCP 서버쪽에서 고정 IP(Static IP)를 다른것으로 변경하고 서비스를 적용하면 DHCP 클라이언트쪽에서 IP가 변경되는지 확인한다. 
● (192.168.10.1XX -> 192.168.10.150 -> 192.168.10.1XX)
```

```bash
# cat /var/lib/dhcpd/dhcpd.leases
# The format of this file is documented in the dhcpd.leases(5) manual page.
# This lease file was written by isc-dhcp-4.3.6

# authoring-byte-order entry is generated, DO NOT DELETE
authoring-byte-order little-endian;

server-duid "\000\001\000\001'\227\341\030\000\014)\231#\211";

lease 192.168.10.50 {
  starts 1 2021/01/18 06:06:55;
  ends 1 2021/01/18 06:16:55;
  cltt 1 2021/01/18 06:06:55;
  binding state active;
  next binding state free;
  rewind binding state free;
  hardware ethernet 00:0c:29:e2:26:15;
  uid "\001\000\014)\342&\025";
  client-hostname "server2";
}
lease 192.168.10.50 {
  starts 1 2021/01/18 06:09:55;
  ends 1 2021/01/18 06:19:55;
  cltt 1 2021/01/18 06:09:55;
  binding state active;
  next binding state free;
  rewind binding state free;
  hardware ethernet 00:0c:29:e2:26:15;
  uid "\001\000\014)\342&\025";
  client-hostname "server2";
}
lease 192.168.10.50 {
  starts 1 2021/01/18 06:14:55;
  ends 1 2021/01/18 06:24:55;
  cltt 1 2021/01/18 06:14:55;
  binding state active;
  next binding state free;
  rewind binding state free;
  hardware ethernet 00:0c:29:e2:26:15;
  uid "\001\000\014)\342&\025";
  client-hostname "server2";
}
lease 192.168.10.50 {
  starts 1 2021/01/18 06:19:55;
  ends 1 2021/01/18 06:29:55;
  cltt 1 2021/01/18 06:19:55;
  binding state active;
  next binding state free;
  rewind binding state free;
  hardware ethernet 00:0c:29:e2:26:15;
  uid "\001\000\014)\342&\025";
  client-hostname "server2";
}
lease 192.168.10.50 {
  starts 1 2021/01/18 06:22:45;
  ends 1 2021/01/18 06:32:45;
  cltt 1 2021/01/18 06:22:45;
  binding state active;
  next binding state free;
  rewind binding state free;
  hardware ethernet 00:0c:29:e2:26:15;
  uid "\001\000\014)\342&\025";
  client-hostname "server2";
}
# Fixed IP address
es can also be specified for hosts. These addresses
host server2.example.com {
  hardware ethernet 00:0c:29:e2:26:15;
  fixed-address 192.168.10.88;
}
```

# NTP

= time server

# 단원목표

---

- NTP 서버의 필요성
- NTP 서버 개요
- NTP 서버 동작 원리
- NTP 서버 구성

---

# NTP 서버 필요성

많은 네트워크 프로그램들은 시간 동기화가 필요하게 된다. 네트워크 상에서 서로 연동하는 시스템들 간에 시간이 일치 하지 않게 된다면 다수의 시스템 장애처리, 성능카운트, 분석, 로깅등 수많은 문제점을 갖게된다.

■ 자원 공유 서버(NFS Server)

■ 데이터베이스 서버(DB Server)

■ 로그 서버(Logging Server)

■ NMS 프로그램(Network Management Solution)

■ 암호화(Encyption)

■ 기타

```bash
  ===== WebServerA =====                   ===== NFS Server ====
	 Date: 12:00                                12:10
	        /p/file1(12:10)                  /source/file1(12:10)
	======================                   =====================
	                                                  A
	===== WebServerB =====                            |
	 Date: 12:40                                      +---- file1 생성
	        /p/file1(12:10)
	======================

[그림] 서버간의 시간 동기화 이유
```

[참고] 실무에서 많이 사용하고 있는 방법 예

```bash
실무에서는 rdate 명령어나 ntpdate, chronyc 명령어를 통해 서버간의 시간을 동기화하는 방법이 많이 사용되고 있다.

실무에서 서버의 시간을 동기화 하기 위해서 가장 많이 사용하는 방법
￭ rdate 명령어 사용하는 방법   -> crontab
￭ ntpdate 명령어 사용하는 방법 -> crontab

# cat /etc/resolv.conf
nameserver 168.126.63.1

# rdate -s time.bora.net     (# rdate -s 172.16.9.252)
Thu Apr 30 12:01:49 2009

[참고] rdate 서버: time-dgram, time-stream
or
# ntpdate -b time.bora.net   (# ntpdate -b 172.16.9.252)
28 Oct 18:08:50 ntpdate[5833]: step time server 203.248.240.140 offset 2.706436 sec

[참고] NTP 서버 구축
위와 같이 rdate/ntpdate 명령어를 사용하는 방법을 실무에서는 가장 많이 사용하고 있으면, 명령어들 수행이 잘 된다면, crontab 파일에 등록하여 정기적으로 서버의 시간을 동기화 할 수 있도록 설정한다. crontab 파일에 등록할 때는 시간을 동기화 해야 하는 시간이 중요하며, 동기화 시점은 그날의 시작하는 시간으로 설정하는 것을 권장한다.
 
# crontab -e
 1 0 * * * rdate -s time.bora.net      (time.bora.net:  210.120.246.46)

or
 **1 0 * * * chronyc -a makestep**

(결론) 
● rdate 명령어 보다는 ntpdate, chronyc 명령어를 사용하는 것을 권장한다.
● crontab 파일에 등록할 때 그날의 0시 1분에 수행하도록 하는 것을 권장한다.
```

### date 명령어

시스템 시간 정보 확인

**[SERVER1]# date**

```
2020. 07. 27. (월) 18:54:31 KST
KST - Korea Standard Time
```

UTC 시간 정보 확인

**[SERVER1]# date --utc**

```
2020. 07. 27. (월) 09:55:03 UTC
```

TIME FORMAT으로 시간 설정

**[SERVER1]# date --set 10:15:11**

```
2020. 07. 27. (월) 10:15:11 KST
```

TIME FORMAT으로 YYYY-MM-DD 변경

**[SERVER1]# date --set 2020-07-28**

```
2020. 07. 28. (화) 00:00:00 KST
```

UTC와 현재 time zone의 시간 차를 알려준다.

**[SERVER1]# date -R**

```
Tue, 28 Jul 2020 00:01:15 +0900
```

## 또다른 시간 정보 확인 명령어

timedatectl 

**[SERVER1]# timedatectl**

```
**Local time: 화 2020-07-28 00:04:02 KST           현재 시스템 시간**
Universal time: 월 2020-07-27 15:04:02 UTC       현재 UTC 시간
RTC time: 월 2020-07-27 10:03:46                 현재 하드웨어 시간
**Time zone: Asia/Seoul (KST, +0900)              설정된 time zone 정보와 UTC와의 시간 차이 확인**
**System clock synchronized: no                   시간 정보에 대하여 동기화가 이루어 지고 있는지 확인**
**NTP service: n/a                                NTP 서비스가 진행되고 있는지 확인**
RTC in local TZ: no                             RTC와의 동기화 진행 유무 확인
```
